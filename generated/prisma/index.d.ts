
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Customer
 * 
 */
export type Customer = $Result.DefaultSelection<Prisma.$CustomerPayload>
/**
 * Model Tag
 * 
 */
export type Tag = $Result.DefaultSelection<Prisma.$TagPayload>
/**
 * Model Address
 * 
 */
export type Address = $Result.DefaultSelection<Prisma.$AddressPayload>
/**
 * Model Property
 * 
 */
export type Property = $Result.DefaultSelection<Prisma.$PropertyPayload>
/**
 * Model Photo
 * 
 */
export type Photo = $Result.DefaultSelection<Prisma.$PhotoPayload>
/**
 * Model Document
 * 
 */
export type Document = $Result.DefaultSelection<Prisma.$DocumentPayload>
/**
 * Model SystemInstallation
 * 
 */
export type SystemInstallation = $Result.DefaultSelection<Prisma.$SystemInstallationPayload>
/**
 * Model ServiceRecord
 * 
 */
export type ServiceRecord = $Result.DefaultSelection<Prisma.$ServiceRecordPayload>
/**
 * Model Project
 * 
 */
export type Project = $Result.DefaultSelection<Prisma.$ProjectPayload>
/**
 * Model ProjectTeamMember
 * 
 */
export type ProjectTeamMember = $Result.DefaultSelection<Prisma.$ProjectTeamMemberPayload>
/**
 * Model TeamMember
 * 
 */
export type TeamMember = $Result.DefaultSelection<Prisma.$TeamMemberPayload>
/**
 * Model Milestone
 * 
 */
export type Milestone = $Result.DefaultSelection<Prisma.$MilestonePayload>
/**
 * Model Budget
 * 
 */
export type Budget = $Result.DefaultSelection<Prisma.$BudgetPayload>
/**
 * Model BudgetLineItem
 * 
 */
export type BudgetLineItem = $Result.DefaultSelection<Prisma.$BudgetLineItemPayload>
/**
 * Model Interaction
 * 
 */
export type Interaction = $Result.DefaultSelection<Prisma.$InteractionPayload>
/**
 * Model CustomerMetrics
 * 
 */
export type CustomerMetrics = $Result.DefaultSelection<Prisma.$CustomerMetricsPayload>
/**
 * Model Proposal
 * 
 */
export type Proposal = $Result.DefaultSelection<Prisma.$ProposalPayload>
/**
 * Model ProposalItem
 * 
 */
export type ProposalItem = $Result.DefaultSelection<Prisma.$ProposalItemPayload>
/**
 * Model Product
 * 
 */
export type Product = $Result.DefaultSelection<Prisma.$ProductPayload>
/**
 * Model ProposalPersona
 * 
 */
export type ProposalPersona = $Result.DefaultSelection<Prisma.$ProposalPersonaPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Customers
 * const customers = await prisma.customer.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Customers
   * const customers = await prisma.customer.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.customer`: Exposes CRUD operations for the **Customer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Customers
    * const customers = await prisma.customer.findMany()
    * ```
    */
  get customer(): Prisma.CustomerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tag`: Exposes CRUD operations for the **Tag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tags
    * const tags = await prisma.tag.findMany()
    * ```
    */
  get tag(): Prisma.TagDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.address`: Exposes CRUD operations for the **Address** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Addresses
    * const addresses = await prisma.address.findMany()
    * ```
    */
  get address(): Prisma.AddressDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.property`: Exposes CRUD operations for the **Property** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Properties
    * const properties = await prisma.property.findMany()
    * ```
    */
  get property(): Prisma.PropertyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.photo`: Exposes CRUD operations for the **Photo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Photos
    * const photos = await prisma.photo.findMany()
    * ```
    */
  get photo(): Prisma.PhotoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.document`: Exposes CRUD operations for the **Document** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Documents
    * const documents = await prisma.document.findMany()
    * ```
    */
  get document(): Prisma.DocumentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.systemInstallation`: Exposes CRUD operations for the **SystemInstallation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SystemInstallations
    * const systemInstallations = await prisma.systemInstallation.findMany()
    * ```
    */
  get systemInstallation(): Prisma.SystemInstallationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.serviceRecord`: Exposes CRUD operations for the **ServiceRecord** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ServiceRecords
    * const serviceRecords = await prisma.serviceRecord.findMany()
    * ```
    */
  get serviceRecord(): Prisma.ServiceRecordDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.project`: Exposes CRUD operations for the **Project** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Projects
    * const projects = await prisma.project.findMany()
    * ```
    */
  get project(): Prisma.ProjectDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.projectTeamMember`: Exposes CRUD operations for the **ProjectTeamMember** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProjectTeamMembers
    * const projectTeamMembers = await prisma.projectTeamMember.findMany()
    * ```
    */
  get projectTeamMember(): Prisma.ProjectTeamMemberDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.teamMember`: Exposes CRUD operations for the **TeamMember** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TeamMembers
    * const teamMembers = await prisma.teamMember.findMany()
    * ```
    */
  get teamMember(): Prisma.TeamMemberDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.milestone`: Exposes CRUD operations for the **Milestone** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Milestones
    * const milestones = await prisma.milestone.findMany()
    * ```
    */
  get milestone(): Prisma.MilestoneDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.budget`: Exposes CRUD operations for the **Budget** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Budgets
    * const budgets = await prisma.budget.findMany()
    * ```
    */
  get budget(): Prisma.BudgetDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.budgetLineItem`: Exposes CRUD operations for the **BudgetLineItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BudgetLineItems
    * const budgetLineItems = await prisma.budgetLineItem.findMany()
    * ```
    */
  get budgetLineItem(): Prisma.BudgetLineItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.interaction`: Exposes CRUD operations for the **Interaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Interactions
    * const interactions = await prisma.interaction.findMany()
    * ```
    */
  get interaction(): Prisma.InteractionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.customerMetrics`: Exposes CRUD operations for the **CustomerMetrics** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CustomerMetrics
    * const customerMetrics = await prisma.customerMetrics.findMany()
    * ```
    */
  get customerMetrics(): Prisma.CustomerMetricsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.proposal`: Exposes CRUD operations for the **Proposal** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Proposals
    * const proposals = await prisma.proposal.findMany()
    * ```
    */
  get proposal(): Prisma.ProposalDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.proposalItem`: Exposes CRUD operations for the **ProposalItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProposalItems
    * const proposalItems = await prisma.proposalItem.findMany()
    * ```
    */
  get proposalItem(): Prisma.ProposalItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.product`: Exposes CRUD operations for the **Product** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.product.findMany()
    * ```
    */
  get product(): Prisma.ProductDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.proposalPersona`: Exposes CRUD operations for the **ProposalPersona** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProposalPersonas
    * const proposalPersonas = await prisma.proposalPersona.findMany()
    * ```
    */
  get proposalPersona(): Prisma.ProposalPersonaDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.8.2
   * Query Engine version: 2060c79ba17c6bb9f5823312b6f6b7f4a845738e
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Customer: 'Customer',
    Tag: 'Tag',
    Address: 'Address',
    Property: 'Property',
    Photo: 'Photo',
    Document: 'Document',
    SystemInstallation: 'SystemInstallation',
    ServiceRecord: 'ServiceRecord',
    Project: 'Project',
    ProjectTeamMember: 'ProjectTeamMember',
    TeamMember: 'TeamMember',
    Milestone: 'Milestone',
    Budget: 'Budget',
    BudgetLineItem: 'BudgetLineItem',
    Interaction: 'Interaction',
    CustomerMetrics: 'CustomerMetrics',
    Proposal: 'Proposal',
    ProposalItem: 'ProposalItem',
    Product: 'Product',
    ProposalPersona: 'ProposalPersona'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "customer" | "tag" | "address" | "property" | "photo" | "document" | "systemInstallation" | "serviceRecord" | "project" | "projectTeamMember" | "teamMember" | "milestone" | "budget" | "budgetLineItem" | "interaction" | "customerMetrics" | "proposal" | "proposalItem" | "product" | "proposalPersona"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Customer: {
        payload: Prisma.$CustomerPayload<ExtArgs>
        fields: Prisma.CustomerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          findFirst: {
            args: Prisma.CustomerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          findMany: {
            args: Prisma.CustomerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          create: {
            args: Prisma.CustomerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          createMany: {
            args: Prisma.CustomerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CustomerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          delete: {
            args: Prisma.CustomerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          update: {
            args: Prisma.CustomerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          deleteMany: {
            args: Prisma.CustomerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CustomerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          upsert: {
            args: Prisma.CustomerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          aggregate: {
            args: Prisma.CustomerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomer>
          }
          groupBy: {
            args: Prisma.CustomerGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomerGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomerCountArgs<ExtArgs>
            result: $Utils.Optional<CustomerCountAggregateOutputType> | number
          }
        }
      }
      Tag: {
        payload: Prisma.$TagPayload<ExtArgs>
        fields: Prisma.TagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          findFirst: {
            args: Prisma.TagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          findMany: {
            args: Prisma.TagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>[]
          }
          create: {
            args: Prisma.TagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          createMany: {
            args: Prisma.TagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TagCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>[]
          }
          delete: {
            args: Prisma.TagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          update: {
            args: Prisma.TagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          deleteMany: {
            args: Prisma.TagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TagUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>[]
          }
          upsert: {
            args: Prisma.TagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          aggregate: {
            args: Prisma.TagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTag>
          }
          groupBy: {
            args: Prisma.TagGroupByArgs<ExtArgs>
            result: $Utils.Optional<TagGroupByOutputType>[]
          }
          count: {
            args: Prisma.TagCountArgs<ExtArgs>
            result: $Utils.Optional<TagCountAggregateOutputType> | number
          }
        }
      }
      Address: {
        payload: Prisma.$AddressPayload<ExtArgs>
        fields: Prisma.AddressFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AddressFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AddressFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          findFirst: {
            args: Prisma.AddressFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AddressFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          findMany: {
            args: Prisma.AddressFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>[]
          }
          create: {
            args: Prisma.AddressCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          createMany: {
            args: Prisma.AddressCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AddressCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>[]
          }
          delete: {
            args: Prisma.AddressDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          update: {
            args: Prisma.AddressUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          deleteMany: {
            args: Prisma.AddressDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AddressUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AddressUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>[]
          }
          upsert: {
            args: Prisma.AddressUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          aggregate: {
            args: Prisma.AddressAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAddress>
          }
          groupBy: {
            args: Prisma.AddressGroupByArgs<ExtArgs>
            result: $Utils.Optional<AddressGroupByOutputType>[]
          }
          count: {
            args: Prisma.AddressCountArgs<ExtArgs>
            result: $Utils.Optional<AddressCountAggregateOutputType> | number
          }
        }
      }
      Property: {
        payload: Prisma.$PropertyPayload<ExtArgs>
        fields: Prisma.PropertyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PropertyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PropertyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>
          }
          findFirst: {
            args: Prisma.PropertyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PropertyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>
          }
          findMany: {
            args: Prisma.PropertyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>[]
          }
          create: {
            args: Prisma.PropertyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>
          }
          createMany: {
            args: Prisma.PropertyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PropertyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>[]
          }
          delete: {
            args: Prisma.PropertyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>
          }
          update: {
            args: Prisma.PropertyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>
          }
          deleteMany: {
            args: Prisma.PropertyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PropertyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PropertyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>[]
          }
          upsert: {
            args: Prisma.PropertyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>
          }
          aggregate: {
            args: Prisma.PropertyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProperty>
          }
          groupBy: {
            args: Prisma.PropertyGroupByArgs<ExtArgs>
            result: $Utils.Optional<PropertyGroupByOutputType>[]
          }
          count: {
            args: Prisma.PropertyCountArgs<ExtArgs>
            result: $Utils.Optional<PropertyCountAggregateOutputType> | number
          }
        }
      }
      Photo: {
        payload: Prisma.$PhotoPayload<ExtArgs>
        fields: Prisma.PhotoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PhotoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhotoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PhotoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhotoPayload>
          }
          findFirst: {
            args: Prisma.PhotoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhotoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PhotoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhotoPayload>
          }
          findMany: {
            args: Prisma.PhotoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhotoPayload>[]
          }
          create: {
            args: Prisma.PhotoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhotoPayload>
          }
          createMany: {
            args: Prisma.PhotoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PhotoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhotoPayload>[]
          }
          delete: {
            args: Prisma.PhotoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhotoPayload>
          }
          update: {
            args: Prisma.PhotoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhotoPayload>
          }
          deleteMany: {
            args: Prisma.PhotoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PhotoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PhotoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhotoPayload>[]
          }
          upsert: {
            args: Prisma.PhotoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhotoPayload>
          }
          aggregate: {
            args: Prisma.PhotoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePhoto>
          }
          groupBy: {
            args: Prisma.PhotoGroupByArgs<ExtArgs>
            result: $Utils.Optional<PhotoGroupByOutputType>[]
          }
          count: {
            args: Prisma.PhotoCountArgs<ExtArgs>
            result: $Utils.Optional<PhotoCountAggregateOutputType> | number
          }
        }
      }
      Document: {
        payload: Prisma.$DocumentPayload<ExtArgs>
        fields: Prisma.DocumentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DocumentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DocumentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          findFirst: {
            args: Prisma.DocumentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DocumentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          findMany: {
            args: Prisma.DocumentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>[]
          }
          create: {
            args: Prisma.DocumentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          createMany: {
            args: Prisma.DocumentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DocumentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>[]
          }
          delete: {
            args: Prisma.DocumentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          update: {
            args: Prisma.DocumentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          deleteMany: {
            args: Prisma.DocumentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DocumentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DocumentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>[]
          }
          upsert: {
            args: Prisma.DocumentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          aggregate: {
            args: Prisma.DocumentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDocument>
          }
          groupBy: {
            args: Prisma.DocumentGroupByArgs<ExtArgs>
            result: $Utils.Optional<DocumentGroupByOutputType>[]
          }
          count: {
            args: Prisma.DocumentCountArgs<ExtArgs>
            result: $Utils.Optional<DocumentCountAggregateOutputType> | number
          }
        }
      }
      SystemInstallation: {
        payload: Prisma.$SystemInstallationPayload<ExtArgs>
        fields: Prisma.SystemInstallationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SystemInstallationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemInstallationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SystemInstallationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemInstallationPayload>
          }
          findFirst: {
            args: Prisma.SystemInstallationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemInstallationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SystemInstallationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemInstallationPayload>
          }
          findMany: {
            args: Prisma.SystemInstallationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemInstallationPayload>[]
          }
          create: {
            args: Prisma.SystemInstallationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemInstallationPayload>
          }
          createMany: {
            args: Prisma.SystemInstallationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SystemInstallationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemInstallationPayload>[]
          }
          delete: {
            args: Prisma.SystemInstallationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemInstallationPayload>
          }
          update: {
            args: Prisma.SystemInstallationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemInstallationPayload>
          }
          deleteMany: {
            args: Prisma.SystemInstallationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SystemInstallationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SystemInstallationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemInstallationPayload>[]
          }
          upsert: {
            args: Prisma.SystemInstallationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemInstallationPayload>
          }
          aggregate: {
            args: Prisma.SystemInstallationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSystemInstallation>
          }
          groupBy: {
            args: Prisma.SystemInstallationGroupByArgs<ExtArgs>
            result: $Utils.Optional<SystemInstallationGroupByOutputType>[]
          }
          count: {
            args: Prisma.SystemInstallationCountArgs<ExtArgs>
            result: $Utils.Optional<SystemInstallationCountAggregateOutputType> | number
          }
        }
      }
      ServiceRecord: {
        payload: Prisma.$ServiceRecordPayload<ExtArgs>
        fields: Prisma.ServiceRecordFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServiceRecordFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceRecordPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceRecordFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceRecordPayload>
          }
          findFirst: {
            args: Prisma.ServiceRecordFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceRecordPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceRecordFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceRecordPayload>
          }
          findMany: {
            args: Prisma.ServiceRecordFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceRecordPayload>[]
          }
          create: {
            args: Prisma.ServiceRecordCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceRecordPayload>
          }
          createMany: {
            args: Prisma.ServiceRecordCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ServiceRecordCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceRecordPayload>[]
          }
          delete: {
            args: Prisma.ServiceRecordDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceRecordPayload>
          }
          update: {
            args: Prisma.ServiceRecordUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceRecordPayload>
          }
          deleteMany: {
            args: Prisma.ServiceRecordDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceRecordUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ServiceRecordUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceRecordPayload>[]
          }
          upsert: {
            args: Prisma.ServiceRecordUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceRecordPayload>
          }
          aggregate: {
            args: Prisma.ServiceRecordAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateServiceRecord>
          }
          groupBy: {
            args: Prisma.ServiceRecordGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServiceRecordGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServiceRecordCountArgs<ExtArgs>
            result: $Utils.Optional<ServiceRecordCountAggregateOutputType> | number
          }
        }
      }
      Project: {
        payload: Prisma.$ProjectPayload<ExtArgs>
        fields: Prisma.ProjectFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          findFirst: {
            args: Prisma.ProjectFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          findMany: {
            args: Prisma.ProjectFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          create: {
            args: Prisma.ProjectCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          createMany: {
            args: Prisma.ProjectCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProjectCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          delete: {
            args: Prisma.ProjectDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          update: {
            args: Prisma.ProjectUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          deleteMany: {
            args: Prisma.ProjectDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProjectUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          upsert: {
            args: Prisma.ProjectUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          aggregate: {
            args: Prisma.ProjectAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProject>
          }
          groupBy: {
            args: Prisma.ProjectGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectCountAggregateOutputType> | number
          }
        }
      }
      ProjectTeamMember: {
        payload: Prisma.$ProjectTeamMemberPayload<ExtArgs>
        fields: Prisma.ProjectTeamMemberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectTeamMemberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectTeamMemberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectTeamMemberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectTeamMemberPayload>
          }
          findFirst: {
            args: Prisma.ProjectTeamMemberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectTeamMemberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectTeamMemberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectTeamMemberPayload>
          }
          findMany: {
            args: Prisma.ProjectTeamMemberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectTeamMemberPayload>[]
          }
          create: {
            args: Prisma.ProjectTeamMemberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectTeamMemberPayload>
          }
          createMany: {
            args: Prisma.ProjectTeamMemberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProjectTeamMemberCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectTeamMemberPayload>[]
          }
          delete: {
            args: Prisma.ProjectTeamMemberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectTeamMemberPayload>
          }
          update: {
            args: Prisma.ProjectTeamMemberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectTeamMemberPayload>
          }
          deleteMany: {
            args: Prisma.ProjectTeamMemberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectTeamMemberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProjectTeamMemberUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectTeamMemberPayload>[]
          }
          upsert: {
            args: Prisma.ProjectTeamMemberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectTeamMemberPayload>
          }
          aggregate: {
            args: Prisma.ProjectTeamMemberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProjectTeamMember>
          }
          groupBy: {
            args: Prisma.ProjectTeamMemberGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectTeamMemberGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectTeamMemberCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectTeamMemberCountAggregateOutputType> | number
          }
        }
      }
      TeamMember: {
        payload: Prisma.$TeamMemberPayload<ExtArgs>
        fields: Prisma.TeamMemberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TeamMemberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TeamMemberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>
          }
          findFirst: {
            args: Prisma.TeamMemberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TeamMemberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>
          }
          findMany: {
            args: Prisma.TeamMemberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>[]
          }
          create: {
            args: Prisma.TeamMemberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>
          }
          createMany: {
            args: Prisma.TeamMemberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TeamMemberCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>[]
          }
          delete: {
            args: Prisma.TeamMemberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>
          }
          update: {
            args: Prisma.TeamMemberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>
          }
          deleteMany: {
            args: Prisma.TeamMemberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TeamMemberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TeamMemberUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>[]
          }
          upsert: {
            args: Prisma.TeamMemberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>
          }
          aggregate: {
            args: Prisma.TeamMemberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTeamMember>
          }
          groupBy: {
            args: Prisma.TeamMemberGroupByArgs<ExtArgs>
            result: $Utils.Optional<TeamMemberGroupByOutputType>[]
          }
          count: {
            args: Prisma.TeamMemberCountArgs<ExtArgs>
            result: $Utils.Optional<TeamMemberCountAggregateOutputType> | number
          }
        }
      }
      Milestone: {
        payload: Prisma.$MilestonePayload<ExtArgs>
        fields: Prisma.MilestoneFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MilestoneFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MilestonePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MilestoneFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MilestonePayload>
          }
          findFirst: {
            args: Prisma.MilestoneFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MilestonePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MilestoneFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MilestonePayload>
          }
          findMany: {
            args: Prisma.MilestoneFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MilestonePayload>[]
          }
          create: {
            args: Prisma.MilestoneCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MilestonePayload>
          }
          createMany: {
            args: Prisma.MilestoneCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MilestoneCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MilestonePayload>[]
          }
          delete: {
            args: Prisma.MilestoneDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MilestonePayload>
          }
          update: {
            args: Prisma.MilestoneUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MilestonePayload>
          }
          deleteMany: {
            args: Prisma.MilestoneDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MilestoneUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MilestoneUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MilestonePayload>[]
          }
          upsert: {
            args: Prisma.MilestoneUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MilestonePayload>
          }
          aggregate: {
            args: Prisma.MilestoneAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMilestone>
          }
          groupBy: {
            args: Prisma.MilestoneGroupByArgs<ExtArgs>
            result: $Utils.Optional<MilestoneGroupByOutputType>[]
          }
          count: {
            args: Prisma.MilestoneCountArgs<ExtArgs>
            result: $Utils.Optional<MilestoneCountAggregateOutputType> | number
          }
        }
      }
      Budget: {
        payload: Prisma.$BudgetPayload<ExtArgs>
        fields: Prisma.BudgetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BudgetFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BudgetFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload>
          }
          findFirst: {
            args: Prisma.BudgetFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BudgetFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload>
          }
          findMany: {
            args: Prisma.BudgetFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload>[]
          }
          create: {
            args: Prisma.BudgetCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload>
          }
          createMany: {
            args: Prisma.BudgetCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BudgetCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload>[]
          }
          delete: {
            args: Prisma.BudgetDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload>
          }
          update: {
            args: Prisma.BudgetUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload>
          }
          deleteMany: {
            args: Prisma.BudgetDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BudgetUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BudgetUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload>[]
          }
          upsert: {
            args: Prisma.BudgetUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload>
          }
          aggregate: {
            args: Prisma.BudgetAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBudget>
          }
          groupBy: {
            args: Prisma.BudgetGroupByArgs<ExtArgs>
            result: $Utils.Optional<BudgetGroupByOutputType>[]
          }
          count: {
            args: Prisma.BudgetCountArgs<ExtArgs>
            result: $Utils.Optional<BudgetCountAggregateOutputType> | number
          }
        }
      }
      BudgetLineItem: {
        payload: Prisma.$BudgetLineItemPayload<ExtArgs>
        fields: Prisma.BudgetLineItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BudgetLineItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetLineItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BudgetLineItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetLineItemPayload>
          }
          findFirst: {
            args: Prisma.BudgetLineItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetLineItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BudgetLineItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetLineItemPayload>
          }
          findMany: {
            args: Prisma.BudgetLineItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetLineItemPayload>[]
          }
          create: {
            args: Prisma.BudgetLineItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetLineItemPayload>
          }
          createMany: {
            args: Prisma.BudgetLineItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BudgetLineItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetLineItemPayload>[]
          }
          delete: {
            args: Prisma.BudgetLineItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetLineItemPayload>
          }
          update: {
            args: Prisma.BudgetLineItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetLineItemPayload>
          }
          deleteMany: {
            args: Prisma.BudgetLineItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BudgetLineItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BudgetLineItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetLineItemPayload>[]
          }
          upsert: {
            args: Prisma.BudgetLineItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetLineItemPayload>
          }
          aggregate: {
            args: Prisma.BudgetLineItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBudgetLineItem>
          }
          groupBy: {
            args: Prisma.BudgetLineItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<BudgetLineItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.BudgetLineItemCountArgs<ExtArgs>
            result: $Utils.Optional<BudgetLineItemCountAggregateOutputType> | number
          }
        }
      }
      Interaction: {
        payload: Prisma.$InteractionPayload<ExtArgs>
        fields: Prisma.InteractionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InteractionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InteractionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InteractionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InteractionPayload>
          }
          findFirst: {
            args: Prisma.InteractionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InteractionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InteractionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InteractionPayload>
          }
          findMany: {
            args: Prisma.InteractionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InteractionPayload>[]
          }
          create: {
            args: Prisma.InteractionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InteractionPayload>
          }
          createMany: {
            args: Prisma.InteractionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InteractionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InteractionPayload>[]
          }
          delete: {
            args: Prisma.InteractionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InteractionPayload>
          }
          update: {
            args: Prisma.InteractionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InteractionPayload>
          }
          deleteMany: {
            args: Prisma.InteractionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InteractionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InteractionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InteractionPayload>[]
          }
          upsert: {
            args: Prisma.InteractionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InteractionPayload>
          }
          aggregate: {
            args: Prisma.InteractionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInteraction>
          }
          groupBy: {
            args: Prisma.InteractionGroupByArgs<ExtArgs>
            result: $Utils.Optional<InteractionGroupByOutputType>[]
          }
          count: {
            args: Prisma.InteractionCountArgs<ExtArgs>
            result: $Utils.Optional<InteractionCountAggregateOutputType> | number
          }
        }
      }
      CustomerMetrics: {
        payload: Prisma.$CustomerMetricsPayload<ExtArgs>
        fields: Prisma.CustomerMetricsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomerMetricsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerMetricsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomerMetricsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerMetricsPayload>
          }
          findFirst: {
            args: Prisma.CustomerMetricsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerMetricsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomerMetricsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerMetricsPayload>
          }
          findMany: {
            args: Prisma.CustomerMetricsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerMetricsPayload>[]
          }
          create: {
            args: Prisma.CustomerMetricsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerMetricsPayload>
          }
          createMany: {
            args: Prisma.CustomerMetricsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CustomerMetricsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerMetricsPayload>[]
          }
          delete: {
            args: Prisma.CustomerMetricsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerMetricsPayload>
          }
          update: {
            args: Prisma.CustomerMetricsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerMetricsPayload>
          }
          deleteMany: {
            args: Prisma.CustomerMetricsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomerMetricsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CustomerMetricsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerMetricsPayload>[]
          }
          upsert: {
            args: Prisma.CustomerMetricsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerMetricsPayload>
          }
          aggregate: {
            args: Prisma.CustomerMetricsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomerMetrics>
          }
          groupBy: {
            args: Prisma.CustomerMetricsGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomerMetricsGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomerMetricsCountArgs<ExtArgs>
            result: $Utils.Optional<CustomerMetricsCountAggregateOutputType> | number
          }
        }
      }
      Proposal: {
        payload: Prisma.$ProposalPayload<ExtArgs>
        fields: Prisma.ProposalFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProposalFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProposalPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProposalFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProposalPayload>
          }
          findFirst: {
            args: Prisma.ProposalFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProposalPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProposalFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProposalPayload>
          }
          findMany: {
            args: Prisma.ProposalFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProposalPayload>[]
          }
          create: {
            args: Prisma.ProposalCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProposalPayload>
          }
          createMany: {
            args: Prisma.ProposalCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProposalCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProposalPayload>[]
          }
          delete: {
            args: Prisma.ProposalDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProposalPayload>
          }
          update: {
            args: Prisma.ProposalUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProposalPayload>
          }
          deleteMany: {
            args: Prisma.ProposalDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProposalUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProposalUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProposalPayload>[]
          }
          upsert: {
            args: Prisma.ProposalUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProposalPayload>
          }
          aggregate: {
            args: Prisma.ProposalAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProposal>
          }
          groupBy: {
            args: Prisma.ProposalGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProposalGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProposalCountArgs<ExtArgs>
            result: $Utils.Optional<ProposalCountAggregateOutputType> | number
          }
        }
      }
      ProposalItem: {
        payload: Prisma.$ProposalItemPayload<ExtArgs>
        fields: Prisma.ProposalItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProposalItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProposalItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProposalItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProposalItemPayload>
          }
          findFirst: {
            args: Prisma.ProposalItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProposalItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProposalItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProposalItemPayload>
          }
          findMany: {
            args: Prisma.ProposalItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProposalItemPayload>[]
          }
          create: {
            args: Prisma.ProposalItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProposalItemPayload>
          }
          createMany: {
            args: Prisma.ProposalItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProposalItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProposalItemPayload>[]
          }
          delete: {
            args: Prisma.ProposalItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProposalItemPayload>
          }
          update: {
            args: Prisma.ProposalItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProposalItemPayload>
          }
          deleteMany: {
            args: Prisma.ProposalItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProposalItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProposalItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProposalItemPayload>[]
          }
          upsert: {
            args: Prisma.ProposalItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProposalItemPayload>
          }
          aggregate: {
            args: Prisma.ProposalItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProposalItem>
          }
          groupBy: {
            args: Prisma.ProposalItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProposalItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProposalItemCountArgs<ExtArgs>
            result: $Utils.Optional<ProposalItemCountAggregateOutputType> | number
          }
        }
      }
      Product: {
        payload: Prisma.$ProductPayload<ExtArgs>
        fields: Prisma.ProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findFirst: {
            args: Prisma.ProductFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findMany: {
            args: Prisma.ProductFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          create: {
            args: Prisma.ProductCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          createMany: {
            args: Prisma.ProductCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          delete: {
            args: Prisma.ProductDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          update: {
            args: Prisma.ProductUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          deleteMany: {
            args: Prisma.ProductDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          upsert: {
            args: Prisma.ProductUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          aggregate: {
            args: Prisma.ProductAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProduct>
          }
          groupBy: {
            args: Prisma.ProductGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductCountArgs<ExtArgs>
            result: $Utils.Optional<ProductCountAggregateOutputType> | number
          }
        }
      }
      ProposalPersona: {
        payload: Prisma.$ProposalPersonaPayload<ExtArgs>
        fields: Prisma.ProposalPersonaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProposalPersonaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProposalPersonaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProposalPersonaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProposalPersonaPayload>
          }
          findFirst: {
            args: Prisma.ProposalPersonaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProposalPersonaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProposalPersonaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProposalPersonaPayload>
          }
          findMany: {
            args: Prisma.ProposalPersonaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProposalPersonaPayload>[]
          }
          create: {
            args: Prisma.ProposalPersonaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProposalPersonaPayload>
          }
          createMany: {
            args: Prisma.ProposalPersonaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProposalPersonaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProposalPersonaPayload>[]
          }
          delete: {
            args: Prisma.ProposalPersonaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProposalPersonaPayload>
          }
          update: {
            args: Prisma.ProposalPersonaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProposalPersonaPayload>
          }
          deleteMany: {
            args: Prisma.ProposalPersonaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProposalPersonaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProposalPersonaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProposalPersonaPayload>[]
          }
          upsert: {
            args: Prisma.ProposalPersonaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProposalPersonaPayload>
          }
          aggregate: {
            args: Prisma.ProposalPersonaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProposalPersona>
          }
          groupBy: {
            args: Prisma.ProposalPersonaGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProposalPersonaGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProposalPersonaCountArgs<ExtArgs>
            result: $Utils.Optional<ProposalPersonaCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    customer?: CustomerOmit
    tag?: TagOmit
    address?: AddressOmit
    property?: PropertyOmit
    photo?: PhotoOmit
    document?: DocumentOmit
    systemInstallation?: SystemInstallationOmit
    serviceRecord?: ServiceRecordOmit
    project?: ProjectOmit
    projectTeamMember?: ProjectTeamMemberOmit
    teamMember?: TeamMemberOmit
    milestone?: MilestoneOmit
    budget?: BudgetOmit
    budgetLineItem?: BudgetLineItemOmit
    interaction?: InteractionOmit
    customerMetrics?: CustomerMetricsOmit
    proposal?: ProposalOmit
    proposalItem?: ProposalItemOmit
    product?: ProductOmit
    proposalPersona?: ProposalPersonaOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type CustomerCountOutputType
   */

  export type CustomerCountOutputType = {
    properties: number
    projects: number
    interactions: number
    tags: number
    proposals: number
  }

  export type CustomerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    properties?: boolean | CustomerCountOutputTypeCountPropertiesArgs
    projects?: boolean | CustomerCountOutputTypeCountProjectsArgs
    interactions?: boolean | CustomerCountOutputTypeCountInteractionsArgs
    tags?: boolean | CustomerCountOutputTypeCountTagsArgs
    proposals?: boolean | CustomerCountOutputTypeCountProposalsArgs
  }

  // Custom InputTypes
  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerCountOutputType
     */
    select?: CustomerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountPropertiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyWhereInput
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountProjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountInteractionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InteractionWhereInput
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TagWhereInput
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountProposalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProposalWhereInput
  }


  /**
   * Count Type PropertyCountOutputType
   */

  export type PropertyCountOutputType = {
    photos: number
    documents: number
    systems: number
    serviceHistory: number
    projects: number
    proposals: number
  }

  export type PropertyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    photos?: boolean | PropertyCountOutputTypeCountPhotosArgs
    documents?: boolean | PropertyCountOutputTypeCountDocumentsArgs
    systems?: boolean | PropertyCountOutputTypeCountSystemsArgs
    serviceHistory?: boolean | PropertyCountOutputTypeCountServiceHistoryArgs
    projects?: boolean | PropertyCountOutputTypeCountProjectsArgs
    proposals?: boolean | PropertyCountOutputTypeCountProposalsArgs
  }

  // Custom InputTypes
  /**
   * PropertyCountOutputType without action
   */
  export type PropertyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyCountOutputType
     */
    select?: PropertyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PropertyCountOutputType without action
   */
  export type PropertyCountOutputTypeCountPhotosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PhotoWhereInput
  }

  /**
   * PropertyCountOutputType without action
   */
  export type PropertyCountOutputTypeCountDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
  }

  /**
   * PropertyCountOutputType without action
   */
  export type PropertyCountOutputTypeCountSystemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SystemInstallationWhereInput
  }

  /**
   * PropertyCountOutputType without action
   */
  export type PropertyCountOutputTypeCountServiceHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceRecordWhereInput
  }

  /**
   * PropertyCountOutputType without action
   */
  export type PropertyCountOutputTypeCountProjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
  }

  /**
   * PropertyCountOutputType without action
   */
  export type PropertyCountOutputTypeCountProposalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProposalWhereInput
  }


  /**
   * Count Type ProjectCountOutputType
   */

  export type ProjectCountOutputType = {
    teamMembers: number
    milestones: number
    documents: number
    proposals: number
  }

  export type ProjectCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    teamMembers?: boolean | ProjectCountOutputTypeCountTeamMembersArgs
    milestones?: boolean | ProjectCountOutputTypeCountMilestonesArgs
    documents?: boolean | ProjectCountOutputTypeCountDocumentsArgs
    proposals?: boolean | ProjectCountOutputTypeCountProposalsArgs
  }

  // Custom InputTypes
  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectCountOutputType
     */
    select?: ProjectCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountTeamMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectTeamMemberWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountMilestonesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MilestoneWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountProposalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProposalWhereInput
  }


  /**
   * Count Type TeamMemberCountOutputType
   */

  export type TeamMemberCountOutputType = {
    projects: number
  }

  export type TeamMemberCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projects?: boolean | TeamMemberCountOutputTypeCountProjectsArgs
  }

  // Custom InputTypes
  /**
   * TeamMemberCountOutputType without action
   */
  export type TeamMemberCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMemberCountOutputType
     */
    select?: TeamMemberCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TeamMemberCountOutputType without action
   */
  export type TeamMemberCountOutputTypeCountProjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectTeamMemberWhereInput
  }


  /**
   * Count Type BudgetCountOutputType
   */

  export type BudgetCountOutputType = {
    lineItems: number
  }

  export type BudgetCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lineItems?: boolean | BudgetCountOutputTypeCountLineItemsArgs
  }

  // Custom InputTypes
  /**
   * BudgetCountOutputType without action
   */
  export type BudgetCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetCountOutputType
     */
    select?: BudgetCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BudgetCountOutputType without action
   */
  export type BudgetCountOutputTypeCountLineItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BudgetLineItemWhereInput
  }


  /**
   * Count Type ProposalCountOutputType
   */

  export type ProposalCountOutputType = {
    items: number
  }

  export type ProposalCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | ProposalCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes
  /**
   * ProposalCountOutputType without action
   */
  export type ProposalCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProposalCountOutputType
     */
    select?: ProposalCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProposalCountOutputType without action
   */
  export type ProposalCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProposalItemWhereInput
  }


  /**
   * Count Type ProductCountOutputType
   */

  export type ProductCountOutputType = {
    proposalItems: number
  }

  export type ProductCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    proposalItems?: boolean | ProductCountOutputTypeCountProposalItemsArgs
  }

  // Custom InputTypes
  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCountOutputType
     */
    select?: ProductCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountProposalItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProposalItemWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Customer
   */

  export type AggregateCustomer = {
    _count: CustomerCountAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  export type CustomerMinAggregateOutputType = {
    id: string | null
    type: string | null
    status: string | null
    firstName: string | null
    lastName: string | null
    company: string | null
    email: string | null
    phone: string | null
    preferredCommunication: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomerMaxAggregateOutputType = {
    id: string | null
    type: string | null
    status: string | null
    firstName: string | null
    lastName: string | null
    company: string | null
    email: string | null
    phone: string | null
    preferredCommunication: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomerCountAggregateOutputType = {
    id: number
    type: number
    status: number
    firstName: number
    lastName: number
    company: number
    email: number
    phone: number
    preferredCommunication: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CustomerMinAggregateInputType = {
    id?: true
    type?: true
    status?: true
    firstName?: true
    lastName?: true
    company?: true
    email?: true
    phone?: true
    preferredCommunication?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomerMaxAggregateInputType = {
    id?: true
    type?: true
    status?: true
    firstName?: true
    lastName?: true
    company?: true
    email?: true
    phone?: true
    preferredCommunication?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomerCountAggregateInputType = {
    id?: true
    type?: true
    status?: true
    firstName?: true
    lastName?: true
    company?: true
    email?: true
    phone?: true
    preferredCommunication?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CustomerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customer to aggregate.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Customers
    **/
    _count?: true | CustomerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerMaxAggregateInputType
  }

  export type GetCustomerAggregateType<T extends CustomerAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomer[P]>
      : GetScalarType<T[P], AggregateCustomer[P]>
  }




  export type CustomerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerWhereInput
    orderBy?: CustomerOrderByWithAggregationInput | CustomerOrderByWithAggregationInput[]
    by: CustomerScalarFieldEnum[] | CustomerScalarFieldEnum
    having?: CustomerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerCountAggregateInputType | true
    _min?: CustomerMinAggregateInputType
    _max?: CustomerMaxAggregateInputType
  }

  export type CustomerGroupByOutputType = {
    id: string
    type: string
    status: string
    firstName: string
    lastName: string
    company: string | null
    email: string
    phone: string
    preferredCommunication: string
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: CustomerCountAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  type GetCustomerGroupByPayload<T extends CustomerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerGroupByOutputType[P]>
        }
      >
    >


  export type CustomerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    status?: boolean
    firstName?: boolean
    lastName?: boolean
    company?: boolean
    email?: boolean
    phone?: boolean
    preferredCommunication?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    billingAddress?: boolean | Customer$billingAddressArgs<ExtArgs>
    properties?: boolean | Customer$propertiesArgs<ExtArgs>
    projects?: boolean | Customer$projectsArgs<ExtArgs>
    interactions?: boolean | Customer$interactionsArgs<ExtArgs>
    tags?: boolean | Customer$tagsArgs<ExtArgs>
    metrics?: boolean | Customer$metricsArgs<ExtArgs>
    proposals?: boolean | Customer$proposalsArgs<ExtArgs>
    _count?: boolean | CustomerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    status?: boolean
    firstName?: boolean
    lastName?: boolean
    company?: boolean
    email?: boolean
    phone?: boolean
    preferredCommunication?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    status?: boolean
    firstName?: boolean
    lastName?: boolean
    company?: boolean
    email?: boolean
    phone?: boolean
    preferredCommunication?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectScalar = {
    id?: boolean
    type?: boolean
    status?: boolean
    firstName?: boolean
    lastName?: boolean
    company?: boolean
    email?: boolean
    phone?: boolean
    preferredCommunication?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CustomerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type" | "status" | "firstName" | "lastName" | "company" | "email" | "phone" | "preferredCommunication" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["customer"]>
  export type CustomerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    billingAddress?: boolean | Customer$billingAddressArgs<ExtArgs>
    properties?: boolean | Customer$propertiesArgs<ExtArgs>
    projects?: boolean | Customer$projectsArgs<ExtArgs>
    interactions?: boolean | Customer$interactionsArgs<ExtArgs>
    tags?: boolean | Customer$tagsArgs<ExtArgs>
    metrics?: boolean | Customer$metricsArgs<ExtArgs>
    proposals?: boolean | Customer$proposalsArgs<ExtArgs>
    _count?: boolean | CustomerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CustomerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CustomerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CustomerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Customer"
    objects: {
      billingAddress: Prisma.$AddressPayload<ExtArgs> | null
      properties: Prisma.$PropertyPayload<ExtArgs>[]
      projects: Prisma.$ProjectPayload<ExtArgs>[]
      interactions: Prisma.$InteractionPayload<ExtArgs>[]
      tags: Prisma.$TagPayload<ExtArgs>[]
      metrics: Prisma.$CustomerMetricsPayload<ExtArgs> | null
      proposals: Prisma.$ProposalPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: string
      status: string
      firstName: string
      lastName: string
      company: string | null
      email: string
      phone: string
      preferredCommunication: string
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["customer"]>
    composites: {}
  }

  type CustomerGetPayload<S extends boolean | null | undefined | CustomerDefaultArgs> = $Result.GetResult<Prisma.$CustomerPayload, S>

  type CustomerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CustomerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CustomerCountAggregateInputType | true
    }

  export interface CustomerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Customer'], meta: { name: 'Customer' } }
    /**
     * Find zero or one Customer that matches the filter.
     * @param {CustomerFindUniqueArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomerFindUniqueArgs>(args: SelectSubset<T, CustomerFindUniqueArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Customer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CustomerFindUniqueOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomerFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomerFindFirstArgs>(args?: SelectSubset<T, CustomerFindFirstArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomerFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomerFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Customers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Customers
     * const customers = await prisma.customer.findMany()
     * 
     * // Get first 10 Customers
     * const customers = await prisma.customer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customerWithIdOnly = await prisma.customer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomerFindManyArgs>(args?: SelectSubset<T, CustomerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Customer.
     * @param {CustomerCreateArgs} args - Arguments to create a Customer.
     * @example
     * // Create one Customer
     * const Customer = await prisma.customer.create({
     *   data: {
     *     // ... data to create a Customer
     *   }
     * })
     * 
     */
    create<T extends CustomerCreateArgs>(args: SelectSubset<T, CustomerCreateArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Customers.
     * @param {CustomerCreateManyArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customer = await prisma.customer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomerCreateManyArgs>(args?: SelectSubset<T, CustomerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Customers and returns the data saved in the database.
     * @param {CustomerCreateManyAndReturnArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customer = await prisma.customer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Customers and only return the `id`
     * const customerWithIdOnly = await prisma.customer.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CustomerCreateManyAndReturnArgs>(args?: SelectSubset<T, CustomerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Customer.
     * @param {CustomerDeleteArgs} args - Arguments to delete one Customer.
     * @example
     * // Delete one Customer
     * const Customer = await prisma.customer.delete({
     *   where: {
     *     // ... filter to delete one Customer
     *   }
     * })
     * 
     */
    delete<T extends CustomerDeleteArgs>(args: SelectSubset<T, CustomerDeleteArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Customer.
     * @param {CustomerUpdateArgs} args - Arguments to update one Customer.
     * @example
     * // Update one Customer
     * const customer = await prisma.customer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomerUpdateArgs>(args: SelectSubset<T, CustomerUpdateArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Customers.
     * @param {CustomerDeleteManyArgs} args - Arguments to filter Customers to delete.
     * @example
     * // Delete a few Customers
     * const { count } = await prisma.customer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomerDeleteManyArgs>(args?: SelectSubset<T, CustomerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Customers
     * const customer = await prisma.customer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomerUpdateManyArgs>(args: SelectSubset<T, CustomerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers and returns the data updated in the database.
     * @param {CustomerUpdateManyAndReturnArgs} args - Arguments to update many Customers.
     * @example
     * // Update many Customers
     * const customer = await prisma.customer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Customers and only return the `id`
     * const customerWithIdOnly = await prisma.customer.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CustomerUpdateManyAndReturnArgs>(args: SelectSubset<T, CustomerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Customer.
     * @param {CustomerUpsertArgs} args - Arguments to update or create a Customer.
     * @example
     * // Update or create a Customer
     * const customer = await prisma.customer.upsert({
     *   create: {
     *     // ... data to create a Customer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Customer we want to update
     *   }
     * })
     */
    upsert<T extends CustomerUpsertArgs>(args: SelectSubset<T, CustomerUpsertArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerCountArgs} args - Arguments to filter Customers to count.
     * @example
     * // Count the number of Customers
     * const count = await prisma.customer.count({
     *   where: {
     *     // ... the filter for the Customers we want to count
     *   }
     * })
    **/
    count<T extends CustomerCountArgs>(
      args?: Subset<T, CustomerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerAggregateArgs>(args: Subset<T, CustomerAggregateArgs>): Prisma.PrismaPromise<GetCustomerAggregateType<T>>

    /**
     * Group by Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerGroupByArgs['orderBy'] }
        : { orderBy?: CustomerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Customer model
   */
  readonly fields: CustomerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Customer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    billingAddress<T extends Customer$billingAddressArgs<ExtArgs> = {}>(args?: Subset<T, Customer$billingAddressArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    properties<T extends Customer$propertiesArgs<ExtArgs> = {}>(args?: Subset<T, Customer$propertiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    projects<T extends Customer$projectsArgs<ExtArgs> = {}>(args?: Subset<T, Customer$projectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    interactions<T extends Customer$interactionsArgs<ExtArgs> = {}>(args?: Subset<T, Customer$interactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InteractionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tags<T extends Customer$tagsArgs<ExtArgs> = {}>(args?: Subset<T, Customer$tagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    metrics<T extends Customer$metricsArgs<ExtArgs> = {}>(args?: Subset<T, Customer$metricsArgs<ExtArgs>>): Prisma__CustomerMetricsClient<$Result.GetResult<Prisma.$CustomerMetricsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    proposals<T extends Customer$proposalsArgs<ExtArgs> = {}>(args?: Subset<T, Customer$proposalsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProposalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Customer model
   */
  interface CustomerFieldRefs {
    readonly id: FieldRef<"Customer", 'String'>
    readonly type: FieldRef<"Customer", 'String'>
    readonly status: FieldRef<"Customer", 'String'>
    readonly firstName: FieldRef<"Customer", 'String'>
    readonly lastName: FieldRef<"Customer", 'String'>
    readonly company: FieldRef<"Customer", 'String'>
    readonly email: FieldRef<"Customer", 'String'>
    readonly phone: FieldRef<"Customer", 'String'>
    readonly preferredCommunication: FieldRef<"Customer", 'String'>
    readonly notes: FieldRef<"Customer", 'String'>
    readonly createdAt: FieldRef<"Customer", 'DateTime'>
    readonly updatedAt: FieldRef<"Customer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Customer findUnique
   */
  export type CustomerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer findUniqueOrThrow
   */
  export type CustomerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer findFirst
   */
  export type CustomerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer findFirstOrThrow
   */
  export type CustomerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer findMany
   */
  export type CustomerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customers to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer create
   */
  export type CustomerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The data needed to create a Customer.
     */
    data: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
  }

  /**
   * Customer createMany
   */
  export type CustomerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Customers.
     */
    data: CustomerCreateManyInput | CustomerCreateManyInput[]
  }

  /**
   * Customer createManyAndReturn
   */
  export type CustomerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * The data used to create many Customers.
     */
    data: CustomerCreateManyInput | CustomerCreateManyInput[]
  }

  /**
   * Customer update
   */
  export type CustomerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The data needed to update a Customer.
     */
    data: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
    /**
     * Choose, which Customer to update.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer updateMany
   */
  export type CustomerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Customers.
     */
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyInput>
    /**
     * Filter which Customers to update
     */
    where?: CustomerWhereInput
    /**
     * Limit how many Customers to update.
     */
    limit?: number
  }

  /**
   * Customer updateManyAndReturn
   */
  export type CustomerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * The data used to update Customers.
     */
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyInput>
    /**
     * Filter which Customers to update
     */
    where?: CustomerWhereInput
    /**
     * Limit how many Customers to update.
     */
    limit?: number
  }

  /**
   * Customer upsert
   */
  export type CustomerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The filter to search for the Customer to update in case it exists.
     */
    where: CustomerWhereUniqueInput
    /**
     * In case the Customer found by the `where` argument doesn't exist, create a new Customer with this data.
     */
    create: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
    /**
     * In case the Customer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
  }

  /**
   * Customer delete
   */
  export type CustomerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter which Customer to delete.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer deleteMany
   */
  export type CustomerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customers to delete
     */
    where?: CustomerWhereInput
    /**
     * Limit how many Customers to delete.
     */
    limit?: number
  }

  /**
   * Customer.billingAddress
   */
  export type Customer$billingAddressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    where?: AddressWhereInput
  }

  /**
   * Customer.properties
   */
  export type Customer$propertiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    where?: PropertyWhereInput
    orderBy?: PropertyOrderByWithRelationInput | PropertyOrderByWithRelationInput[]
    cursor?: PropertyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PropertyScalarFieldEnum | PropertyScalarFieldEnum[]
  }

  /**
   * Customer.projects
   */
  export type Customer$projectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    cursor?: ProjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Customer.interactions
   */
  export type Customer$interactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interaction
     */
    select?: InteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Interaction
     */
    omit?: InteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InteractionInclude<ExtArgs> | null
    where?: InteractionWhereInput
    orderBy?: InteractionOrderByWithRelationInput | InteractionOrderByWithRelationInput[]
    cursor?: InteractionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InteractionScalarFieldEnum | InteractionScalarFieldEnum[]
  }

  /**
   * Customer.tags
   */
  export type Customer$tagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    where?: TagWhereInput
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    cursor?: TagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Customer.metrics
   */
  export type Customer$metricsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerMetrics
     */
    select?: CustomerMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerMetrics
     */
    omit?: CustomerMetricsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerMetricsInclude<ExtArgs> | null
    where?: CustomerMetricsWhereInput
  }

  /**
   * Customer.proposals
   */
  export type Customer$proposalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proposal
     */
    select?: ProposalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Proposal
     */
    omit?: ProposalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalInclude<ExtArgs> | null
    where?: ProposalWhereInput
    orderBy?: ProposalOrderByWithRelationInput | ProposalOrderByWithRelationInput[]
    cursor?: ProposalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProposalScalarFieldEnum | ProposalScalarFieldEnum[]
  }

  /**
   * Customer without action
   */
  export type CustomerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
  }


  /**
   * Model Tag
   */

  export type AggregateTag = {
    _count: TagCountAggregateOutputType | null
    _min: TagMinAggregateOutputType | null
    _max: TagMaxAggregateOutputType | null
  }

  export type TagMinAggregateOutputType = {
    id: string | null
    name: string | null
    customerId: string | null
  }

  export type TagMaxAggregateOutputType = {
    id: string | null
    name: string | null
    customerId: string | null
  }

  export type TagCountAggregateOutputType = {
    id: number
    name: number
    customerId: number
    _all: number
  }


  export type TagMinAggregateInputType = {
    id?: true
    name?: true
    customerId?: true
  }

  export type TagMaxAggregateInputType = {
    id?: true
    name?: true
    customerId?: true
  }

  export type TagCountAggregateInputType = {
    id?: true
    name?: true
    customerId?: true
    _all?: true
  }

  export type TagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tag to aggregate.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tags
    **/
    _count?: true | TagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TagMaxAggregateInputType
  }

  export type GetTagAggregateType<T extends TagAggregateArgs> = {
        [P in keyof T & keyof AggregateTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTag[P]>
      : GetScalarType<T[P], AggregateTag[P]>
  }




  export type TagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TagWhereInput
    orderBy?: TagOrderByWithAggregationInput | TagOrderByWithAggregationInput[]
    by: TagScalarFieldEnum[] | TagScalarFieldEnum
    having?: TagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TagCountAggregateInputType | true
    _min?: TagMinAggregateInputType
    _max?: TagMaxAggregateInputType
  }

  export type TagGroupByOutputType = {
    id: string
    name: string
    customerId: string
    _count: TagCountAggregateOutputType | null
    _min: TagMinAggregateOutputType | null
    _max: TagMaxAggregateOutputType | null
  }

  type GetTagGroupByPayload<T extends TagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TagGroupByOutputType[P]>
            : GetScalarType<T[P], TagGroupByOutputType[P]>
        }
      >
    >


  export type TagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    customerId?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tag"]>

  export type TagSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    customerId?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tag"]>

  export type TagSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    customerId?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tag"]>

  export type TagSelectScalar = {
    id?: boolean
    name?: boolean
    customerId?: boolean
  }

  export type TagOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "customerId", ExtArgs["result"]["tag"]>
  export type TagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }
  export type TagIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }
  export type TagIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }

  export type $TagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tag"
    objects: {
      customer: Prisma.$CustomerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      customerId: string
    }, ExtArgs["result"]["tag"]>
    composites: {}
  }

  type TagGetPayload<S extends boolean | null | undefined | TagDefaultArgs> = $Result.GetResult<Prisma.$TagPayload, S>

  type TagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TagFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TagCountAggregateInputType | true
    }

  export interface TagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tag'], meta: { name: 'Tag' } }
    /**
     * Find zero or one Tag that matches the filter.
     * @param {TagFindUniqueArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TagFindUniqueArgs>(args: SelectSubset<T, TagFindUniqueArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tag that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TagFindUniqueOrThrowArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TagFindUniqueOrThrowArgs>(args: SelectSubset<T, TagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindFirstArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TagFindFirstArgs>(args?: SelectSubset<T, TagFindFirstArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindFirstOrThrowArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TagFindFirstOrThrowArgs>(args?: SelectSubset<T, TagFindFirstOrThrowArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tags
     * const tags = await prisma.tag.findMany()
     * 
     * // Get first 10 Tags
     * const tags = await prisma.tag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tagWithIdOnly = await prisma.tag.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TagFindManyArgs>(args?: SelectSubset<T, TagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tag.
     * @param {TagCreateArgs} args - Arguments to create a Tag.
     * @example
     * // Create one Tag
     * const Tag = await prisma.tag.create({
     *   data: {
     *     // ... data to create a Tag
     *   }
     * })
     * 
     */
    create<T extends TagCreateArgs>(args: SelectSubset<T, TagCreateArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tags.
     * @param {TagCreateManyArgs} args - Arguments to create many Tags.
     * @example
     * // Create many Tags
     * const tag = await prisma.tag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TagCreateManyArgs>(args?: SelectSubset<T, TagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tags and returns the data saved in the database.
     * @param {TagCreateManyAndReturnArgs} args - Arguments to create many Tags.
     * @example
     * // Create many Tags
     * const tag = await prisma.tag.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tags and only return the `id`
     * const tagWithIdOnly = await prisma.tag.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TagCreateManyAndReturnArgs>(args?: SelectSubset<T, TagCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Tag.
     * @param {TagDeleteArgs} args - Arguments to delete one Tag.
     * @example
     * // Delete one Tag
     * const Tag = await prisma.tag.delete({
     *   where: {
     *     // ... filter to delete one Tag
     *   }
     * })
     * 
     */
    delete<T extends TagDeleteArgs>(args: SelectSubset<T, TagDeleteArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tag.
     * @param {TagUpdateArgs} args - Arguments to update one Tag.
     * @example
     * // Update one Tag
     * const tag = await prisma.tag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TagUpdateArgs>(args: SelectSubset<T, TagUpdateArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tags.
     * @param {TagDeleteManyArgs} args - Arguments to filter Tags to delete.
     * @example
     * // Delete a few Tags
     * const { count } = await prisma.tag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TagDeleteManyArgs>(args?: SelectSubset<T, TagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tags
     * const tag = await prisma.tag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TagUpdateManyArgs>(args: SelectSubset<T, TagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tags and returns the data updated in the database.
     * @param {TagUpdateManyAndReturnArgs} args - Arguments to update many Tags.
     * @example
     * // Update many Tags
     * const tag = await prisma.tag.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tags and only return the `id`
     * const tagWithIdOnly = await prisma.tag.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TagUpdateManyAndReturnArgs>(args: SelectSubset<T, TagUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Tag.
     * @param {TagUpsertArgs} args - Arguments to update or create a Tag.
     * @example
     * // Update or create a Tag
     * const tag = await prisma.tag.upsert({
     *   create: {
     *     // ... data to create a Tag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tag we want to update
     *   }
     * })
     */
    upsert<T extends TagUpsertArgs>(args: SelectSubset<T, TagUpsertArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagCountArgs} args - Arguments to filter Tags to count.
     * @example
     * // Count the number of Tags
     * const count = await prisma.tag.count({
     *   where: {
     *     // ... the filter for the Tags we want to count
     *   }
     * })
    **/
    count<T extends TagCountArgs>(
      args?: Subset<T, TagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TagAggregateArgs>(args: Subset<T, TagAggregateArgs>): Prisma.PrismaPromise<GetTagAggregateType<T>>

    /**
     * Group by Tag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TagGroupByArgs['orderBy'] }
        : { orderBy?: TagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tag model
   */
  readonly fields: TagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customer<T extends CustomerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerDefaultArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tag model
   */
  interface TagFieldRefs {
    readonly id: FieldRef<"Tag", 'String'>
    readonly name: FieldRef<"Tag", 'String'>
    readonly customerId: FieldRef<"Tag", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Tag findUnique
   */
  export type TagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag findUniqueOrThrow
   */
  export type TagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag findFirst
   */
  export type TagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tags.
     */
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag findFirstOrThrow
   */
  export type TagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tags.
     */
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag findMany
   */
  export type TagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tags to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag create
   */
  export type TagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The data needed to create a Tag.
     */
    data: XOR<TagCreateInput, TagUncheckedCreateInput>
  }

  /**
   * Tag createMany
   */
  export type TagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tags.
     */
    data: TagCreateManyInput | TagCreateManyInput[]
  }

  /**
   * Tag createManyAndReturn
   */
  export type TagCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * The data used to create many Tags.
     */
    data: TagCreateManyInput | TagCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Tag update
   */
  export type TagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The data needed to update a Tag.
     */
    data: XOR<TagUpdateInput, TagUncheckedUpdateInput>
    /**
     * Choose, which Tag to update.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag updateMany
   */
  export type TagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tags.
     */
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyInput>
    /**
     * Filter which Tags to update
     */
    where?: TagWhereInput
    /**
     * Limit how many Tags to update.
     */
    limit?: number
  }

  /**
   * Tag updateManyAndReturn
   */
  export type TagUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * The data used to update Tags.
     */
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyInput>
    /**
     * Filter which Tags to update
     */
    where?: TagWhereInput
    /**
     * Limit how many Tags to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Tag upsert
   */
  export type TagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The filter to search for the Tag to update in case it exists.
     */
    where: TagWhereUniqueInput
    /**
     * In case the Tag found by the `where` argument doesn't exist, create a new Tag with this data.
     */
    create: XOR<TagCreateInput, TagUncheckedCreateInput>
    /**
     * In case the Tag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TagUpdateInput, TagUncheckedUpdateInput>
  }

  /**
   * Tag delete
   */
  export type TagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter which Tag to delete.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag deleteMany
   */
  export type TagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tags to delete
     */
    where?: TagWhereInput
    /**
     * Limit how many Tags to delete.
     */
    limit?: number
  }

  /**
   * Tag without action
   */
  export type TagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
  }


  /**
   * Model Address
   */

  export type AggregateAddress = {
    _count: AddressCountAggregateOutputType | null
    _min: AddressMinAggregateOutputType | null
    _max: AddressMaxAggregateOutputType | null
  }

  export type AddressMinAggregateOutputType = {
    id: string | null
    street: string | null
    city: string | null
    state: string | null
    zipCode: string | null
    country: string | null
    customerId: string | null
  }

  export type AddressMaxAggregateOutputType = {
    id: string | null
    street: string | null
    city: string | null
    state: string | null
    zipCode: string | null
    country: string | null
    customerId: string | null
  }

  export type AddressCountAggregateOutputType = {
    id: number
    street: number
    city: number
    state: number
    zipCode: number
    country: number
    customerId: number
    _all: number
  }


  export type AddressMinAggregateInputType = {
    id?: true
    street?: true
    city?: true
    state?: true
    zipCode?: true
    country?: true
    customerId?: true
  }

  export type AddressMaxAggregateInputType = {
    id?: true
    street?: true
    city?: true
    state?: true
    zipCode?: true
    country?: true
    customerId?: true
  }

  export type AddressCountAggregateInputType = {
    id?: true
    street?: true
    city?: true
    state?: true
    zipCode?: true
    country?: true
    customerId?: true
    _all?: true
  }

  export type AddressAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Address to aggregate.
     */
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     */
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Addresses
    **/
    _count?: true | AddressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AddressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AddressMaxAggregateInputType
  }

  export type GetAddressAggregateType<T extends AddressAggregateArgs> = {
        [P in keyof T & keyof AggregateAddress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAddress[P]>
      : GetScalarType<T[P], AggregateAddress[P]>
  }




  export type AddressGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AddressWhereInput
    orderBy?: AddressOrderByWithAggregationInput | AddressOrderByWithAggregationInput[]
    by: AddressScalarFieldEnum[] | AddressScalarFieldEnum
    having?: AddressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AddressCountAggregateInputType | true
    _min?: AddressMinAggregateInputType
    _max?: AddressMaxAggregateInputType
  }

  export type AddressGroupByOutputType = {
    id: string
    street: string
    city: string
    state: string
    zipCode: string
    country: string
    customerId: string
    _count: AddressCountAggregateOutputType | null
    _min: AddressMinAggregateOutputType | null
    _max: AddressMaxAggregateOutputType | null
  }

  type GetAddressGroupByPayload<T extends AddressGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AddressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AddressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AddressGroupByOutputType[P]>
            : GetScalarType<T[P], AddressGroupByOutputType[P]>
        }
      >
    >


  export type AddressSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    street?: boolean
    city?: boolean
    state?: boolean
    zipCode?: boolean
    country?: boolean
    customerId?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    property?: boolean | Address$propertyArgs<ExtArgs>
  }, ExtArgs["result"]["address"]>

  export type AddressSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    street?: boolean
    city?: boolean
    state?: boolean
    zipCode?: boolean
    country?: boolean
    customerId?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["address"]>

  export type AddressSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    street?: boolean
    city?: boolean
    state?: boolean
    zipCode?: boolean
    country?: boolean
    customerId?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["address"]>

  export type AddressSelectScalar = {
    id?: boolean
    street?: boolean
    city?: boolean
    state?: boolean
    zipCode?: boolean
    country?: boolean
    customerId?: boolean
  }

  export type AddressOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "street" | "city" | "state" | "zipCode" | "country" | "customerId", ExtArgs["result"]["address"]>
  export type AddressInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    property?: boolean | Address$propertyArgs<ExtArgs>
  }
  export type AddressIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }
  export type AddressIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }

  export type $AddressPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Address"
    objects: {
      customer: Prisma.$CustomerPayload<ExtArgs>
      property: Prisma.$PropertyPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      street: string
      city: string
      state: string
      zipCode: string
      country: string
      customerId: string
    }, ExtArgs["result"]["address"]>
    composites: {}
  }

  type AddressGetPayload<S extends boolean | null | undefined | AddressDefaultArgs> = $Result.GetResult<Prisma.$AddressPayload, S>

  type AddressCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AddressFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AddressCountAggregateInputType | true
    }

  export interface AddressDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Address'], meta: { name: 'Address' } }
    /**
     * Find zero or one Address that matches the filter.
     * @param {AddressFindUniqueArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AddressFindUniqueArgs>(args: SelectSubset<T, AddressFindUniqueArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Address that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AddressFindUniqueOrThrowArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AddressFindUniqueOrThrowArgs>(args: SelectSubset<T, AddressFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Address that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressFindFirstArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AddressFindFirstArgs>(args?: SelectSubset<T, AddressFindFirstArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Address that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressFindFirstOrThrowArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AddressFindFirstOrThrowArgs>(args?: SelectSubset<T, AddressFindFirstOrThrowArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Addresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Addresses
     * const addresses = await prisma.address.findMany()
     * 
     * // Get first 10 Addresses
     * const addresses = await prisma.address.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const addressWithIdOnly = await prisma.address.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AddressFindManyArgs>(args?: SelectSubset<T, AddressFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Address.
     * @param {AddressCreateArgs} args - Arguments to create a Address.
     * @example
     * // Create one Address
     * const Address = await prisma.address.create({
     *   data: {
     *     // ... data to create a Address
     *   }
     * })
     * 
     */
    create<T extends AddressCreateArgs>(args: SelectSubset<T, AddressCreateArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Addresses.
     * @param {AddressCreateManyArgs} args - Arguments to create many Addresses.
     * @example
     * // Create many Addresses
     * const address = await prisma.address.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AddressCreateManyArgs>(args?: SelectSubset<T, AddressCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Addresses and returns the data saved in the database.
     * @param {AddressCreateManyAndReturnArgs} args - Arguments to create many Addresses.
     * @example
     * // Create many Addresses
     * const address = await prisma.address.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Addresses and only return the `id`
     * const addressWithIdOnly = await prisma.address.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AddressCreateManyAndReturnArgs>(args?: SelectSubset<T, AddressCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Address.
     * @param {AddressDeleteArgs} args - Arguments to delete one Address.
     * @example
     * // Delete one Address
     * const Address = await prisma.address.delete({
     *   where: {
     *     // ... filter to delete one Address
     *   }
     * })
     * 
     */
    delete<T extends AddressDeleteArgs>(args: SelectSubset<T, AddressDeleteArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Address.
     * @param {AddressUpdateArgs} args - Arguments to update one Address.
     * @example
     * // Update one Address
     * const address = await prisma.address.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AddressUpdateArgs>(args: SelectSubset<T, AddressUpdateArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Addresses.
     * @param {AddressDeleteManyArgs} args - Arguments to filter Addresses to delete.
     * @example
     * // Delete a few Addresses
     * const { count } = await prisma.address.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AddressDeleteManyArgs>(args?: SelectSubset<T, AddressDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Addresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Addresses
     * const address = await prisma.address.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AddressUpdateManyArgs>(args: SelectSubset<T, AddressUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Addresses and returns the data updated in the database.
     * @param {AddressUpdateManyAndReturnArgs} args - Arguments to update many Addresses.
     * @example
     * // Update many Addresses
     * const address = await prisma.address.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Addresses and only return the `id`
     * const addressWithIdOnly = await prisma.address.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AddressUpdateManyAndReturnArgs>(args: SelectSubset<T, AddressUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Address.
     * @param {AddressUpsertArgs} args - Arguments to update or create a Address.
     * @example
     * // Update or create a Address
     * const address = await prisma.address.upsert({
     *   create: {
     *     // ... data to create a Address
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Address we want to update
     *   }
     * })
     */
    upsert<T extends AddressUpsertArgs>(args: SelectSubset<T, AddressUpsertArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Addresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressCountArgs} args - Arguments to filter Addresses to count.
     * @example
     * // Count the number of Addresses
     * const count = await prisma.address.count({
     *   where: {
     *     // ... the filter for the Addresses we want to count
     *   }
     * })
    **/
    count<T extends AddressCountArgs>(
      args?: Subset<T, AddressCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AddressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Address.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AddressAggregateArgs>(args: Subset<T, AddressAggregateArgs>): Prisma.PrismaPromise<GetAddressAggregateType<T>>

    /**
     * Group by Address.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AddressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AddressGroupByArgs['orderBy'] }
        : { orderBy?: AddressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AddressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAddressGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Address model
   */
  readonly fields: AddressFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Address.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AddressClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customer<T extends CustomerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerDefaultArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    property<T extends Address$propertyArgs<ExtArgs> = {}>(args?: Subset<T, Address$propertyArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Address model
   */
  interface AddressFieldRefs {
    readonly id: FieldRef<"Address", 'String'>
    readonly street: FieldRef<"Address", 'String'>
    readonly city: FieldRef<"Address", 'String'>
    readonly state: FieldRef<"Address", 'String'>
    readonly zipCode: FieldRef<"Address", 'String'>
    readonly country: FieldRef<"Address", 'String'>
    readonly customerId: FieldRef<"Address", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Address findUnique
   */
  export type AddressFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter, which Address to fetch.
     */
    where: AddressWhereUniqueInput
  }

  /**
   * Address findUniqueOrThrow
   */
  export type AddressFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter, which Address to fetch.
     */
    where: AddressWhereUniqueInput
  }

  /**
   * Address findFirst
   */
  export type AddressFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter, which Address to fetch.
     */
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     */
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Addresses.
     */
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Addresses.
     */
    distinct?: AddressScalarFieldEnum | AddressScalarFieldEnum[]
  }

  /**
   * Address findFirstOrThrow
   */
  export type AddressFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter, which Address to fetch.
     */
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     */
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Addresses.
     */
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Addresses.
     */
    distinct?: AddressScalarFieldEnum | AddressScalarFieldEnum[]
  }

  /**
   * Address findMany
   */
  export type AddressFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter, which Addresses to fetch.
     */
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     */
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Addresses.
     */
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     */
    skip?: number
    distinct?: AddressScalarFieldEnum | AddressScalarFieldEnum[]
  }

  /**
   * Address create
   */
  export type AddressCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * The data needed to create a Address.
     */
    data: XOR<AddressCreateInput, AddressUncheckedCreateInput>
  }

  /**
   * Address createMany
   */
  export type AddressCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Addresses.
     */
    data: AddressCreateManyInput | AddressCreateManyInput[]
  }

  /**
   * Address createManyAndReturn
   */
  export type AddressCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * The data used to create many Addresses.
     */
    data: AddressCreateManyInput | AddressCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Address update
   */
  export type AddressUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * The data needed to update a Address.
     */
    data: XOR<AddressUpdateInput, AddressUncheckedUpdateInput>
    /**
     * Choose, which Address to update.
     */
    where: AddressWhereUniqueInput
  }

  /**
   * Address updateMany
   */
  export type AddressUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Addresses.
     */
    data: XOR<AddressUpdateManyMutationInput, AddressUncheckedUpdateManyInput>
    /**
     * Filter which Addresses to update
     */
    where?: AddressWhereInput
    /**
     * Limit how many Addresses to update.
     */
    limit?: number
  }

  /**
   * Address updateManyAndReturn
   */
  export type AddressUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * The data used to update Addresses.
     */
    data: XOR<AddressUpdateManyMutationInput, AddressUncheckedUpdateManyInput>
    /**
     * Filter which Addresses to update
     */
    where?: AddressWhereInput
    /**
     * Limit how many Addresses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Address upsert
   */
  export type AddressUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * The filter to search for the Address to update in case it exists.
     */
    where: AddressWhereUniqueInput
    /**
     * In case the Address found by the `where` argument doesn't exist, create a new Address with this data.
     */
    create: XOR<AddressCreateInput, AddressUncheckedCreateInput>
    /**
     * In case the Address was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AddressUpdateInput, AddressUncheckedUpdateInput>
  }

  /**
   * Address delete
   */
  export type AddressDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter which Address to delete.
     */
    where: AddressWhereUniqueInput
  }

  /**
   * Address deleteMany
   */
  export type AddressDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Addresses to delete
     */
    where?: AddressWhereInput
    /**
     * Limit how many Addresses to delete.
     */
    limit?: number
  }

  /**
   * Address.property
   */
  export type Address$propertyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    where?: PropertyWhereInput
  }

  /**
   * Address without action
   */
  export type AddressDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
  }


  /**
   * Model Property
   */

  export type AggregateProperty = {
    _count: PropertyCountAggregateOutputType | null
    _avg: PropertyAvgAggregateOutputType | null
    _sum: PropertySumAggregateOutputType | null
    _min: PropertyMinAggregateOutputType | null
    _max: PropertyMaxAggregateOutputType | null
  }

  export type PropertyAvgAggregateOutputType = {
    squareFootage: number | null
    bedrooms: number | null
    bathrooms: number | null
    yearBuilt: number | null
  }

  export type PropertySumAggregateOutputType = {
    squareFootage: number | null
    bedrooms: number | null
    bathrooms: number | null
    yearBuilt: number | null
  }

  export type PropertyMinAggregateOutputType = {
    id: string | null
    name: string | null
    type: string | null
    addressId: string | null
    squareFootage: number | null
    bedrooms: number | null
    bathrooms: number | null
    yearBuilt: number | null
    customerId: string | null
  }

  export type PropertyMaxAggregateOutputType = {
    id: string | null
    name: string | null
    type: string | null
    addressId: string | null
    squareFootage: number | null
    bedrooms: number | null
    bathrooms: number | null
    yearBuilt: number | null
    customerId: string | null
  }

  export type PropertyCountAggregateOutputType = {
    id: number
    name: number
    type: number
    addressId: number
    squareFootage: number
    bedrooms: number
    bathrooms: number
    yearBuilt: number
    customerId: number
    _all: number
  }


  export type PropertyAvgAggregateInputType = {
    squareFootage?: true
    bedrooms?: true
    bathrooms?: true
    yearBuilt?: true
  }

  export type PropertySumAggregateInputType = {
    squareFootage?: true
    bedrooms?: true
    bathrooms?: true
    yearBuilt?: true
  }

  export type PropertyMinAggregateInputType = {
    id?: true
    name?: true
    type?: true
    addressId?: true
    squareFootage?: true
    bedrooms?: true
    bathrooms?: true
    yearBuilt?: true
    customerId?: true
  }

  export type PropertyMaxAggregateInputType = {
    id?: true
    name?: true
    type?: true
    addressId?: true
    squareFootage?: true
    bedrooms?: true
    bathrooms?: true
    yearBuilt?: true
    customerId?: true
  }

  export type PropertyCountAggregateInputType = {
    id?: true
    name?: true
    type?: true
    addressId?: true
    squareFootage?: true
    bedrooms?: true
    bathrooms?: true
    yearBuilt?: true
    customerId?: true
    _all?: true
  }

  export type PropertyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Property to aggregate.
     */
    where?: PropertyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Properties to fetch.
     */
    orderBy?: PropertyOrderByWithRelationInput | PropertyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PropertyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Properties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Properties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Properties
    **/
    _count?: true | PropertyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PropertyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PropertySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PropertyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PropertyMaxAggregateInputType
  }

  export type GetPropertyAggregateType<T extends PropertyAggregateArgs> = {
        [P in keyof T & keyof AggregateProperty]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProperty[P]>
      : GetScalarType<T[P], AggregateProperty[P]>
  }




  export type PropertyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyWhereInput
    orderBy?: PropertyOrderByWithAggregationInput | PropertyOrderByWithAggregationInput[]
    by: PropertyScalarFieldEnum[] | PropertyScalarFieldEnum
    having?: PropertyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PropertyCountAggregateInputType | true
    _avg?: PropertyAvgAggregateInputType
    _sum?: PropertySumAggregateInputType
    _min?: PropertyMinAggregateInputType
    _max?: PropertyMaxAggregateInputType
  }

  export type PropertyGroupByOutputType = {
    id: string
    name: string
    type: string
    addressId: string | null
    squareFootage: number
    bedrooms: number | null
    bathrooms: number | null
    yearBuilt: number | null
    customerId: string
    _count: PropertyCountAggregateOutputType | null
    _avg: PropertyAvgAggregateOutputType | null
    _sum: PropertySumAggregateOutputType | null
    _min: PropertyMinAggregateOutputType | null
    _max: PropertyMaxAggregateOutputType | null
  }

  type GetPropertyGroupByPayload<T extends PropertyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PropertyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PropertyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PropertyGroupByOutputType[P]>
            : GetScalarType<T[P], PropertyGroupByOutputType[P]>
        }
      >
    >


  export type PropertySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    addressId?: boolean
    squareFootage?: boolean
    bedrooms?: boolean
    bathrooms?: boolean
    yearBuilt?: boolean
    customerId?: boolean
    address?: boolean | Property$addressArgs<ExtArgs>
    photos?: boolean | Property$photosArgs<ExtArgs>
    documents?: boolean | Property$documentsArgs<ExtArgs>
    systems?: boolean | Property$systemsArgs<ExtArgs>
    serviceHistory?: boolean | Property$serviceHistoryArgs<ExtArgs>
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    projects?: boolean | Property$projectsArgs<ExtArgs>
    proposals?: boolean | Property$proposalsArgs<ExtArgs>
    _count?: boolean | PropertyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["property"]>

  export type PropertySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    addressId?: boolean
    squareFootage?: boolean
    bedrooms?: boolean
    bathrooms?: boolean
    yearBuilt?: boolean
    customerId?: boolean
    address?: boolean | Property$addressArgs<ExtArgs>
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["property"]>

  export type PropertySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    addressId?: boolean
    squareFootage?: boolean
    bedrooms?: boolean
    bathrooms?: boolean
    yearBuilt?: boolean
    customerId?: boolean
    address?: boolean | Property$addressArgs<ExtArgs>
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["property"]>

  export type PropertySelectScalar = {
    id?: boolean
    name?: boolean
    type?: boolean
    addressId?: boolean
    squareFootage?: boolean
    bedrooms?: boolean
    bathrooms?: boolean
    yearBuilt?: boolean
    customerId?: boolean
  }

  export type PropertyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "type" | "addressId" | "squareFootage" | "bedrooms" | "bathrooms" | "yearBuilt" | "customerId", ExtArgs["result"]["property"]>
  export type PropertyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    address?: boolean | Property$addressArgs<ExtArgs>
    photos?: boolean | Property$photosArgs<ExtArgs>
    documents?: boolean | Property$documentsArgs<ExtArgs>
    systems?: boolean | Property$systemsArgs<ExtArgs>
    serviceHistory?: boolean | Property$serviceHistoryArgs<ExtArgs>
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    projects?: boolean | Property$projectsArgs<ExtArgs>
    proposals?: boolean | Property$proposalsArgs<ExtArgs>
    _count?: boolean | PropertyCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PropertyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    address?: boolean | Property$addressArgs<ExtArgs>
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }
  export type PropertyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    address?: boolean | Property$addressArgs<ExtArgs>
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }

  export type $PropertyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Property"
    objects: {
      address: Prisma.$AddressPayload<ExtArgs> | null
      photos: Prisma.$PhotoPayload<ExtArgs>[]
      documents: Prisma.$DocumentPayload<ExtArgs>[]
      systems: Prisma.$SystemInstallationPayload<ExtArgs>[]
      serviceHistory: Prisma.$ServiceRecordPayload<ExtArgs>[]
      customer: Prisma.$CustomerPayload<ExtArgs>
      projects: Prisma.$ProjectPayload<ExtArgs>[]
      proposals: Prisma.$ProposalPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      type: string
      addressId: string | null
      squareFootage: number
      bedrooms: number | null
      bathrooms: number | null
      yearBuilt: number | null
      customerId: string
    }, ExtArgs["result"]["property"]>
    composites: {}
  }

  type PropertyGetPayload<S extends boolean | null | undefined | PropertyDefaultArgs> = $Result.GetResult<Prisma.$PropertyPayload, S>

  type PropertyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PropertyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PropertyCountAggregateInputType | true
    }

  export interface PropertyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Property'], meta: { name: 'Property' } }
    /**
     * Find zero or one Property that matches the filter.
     * @param {PropertyFindUniqueArgs} args - Arguments to find a Property
     * @example
     * // Get one Property
     * const property = await prisma.property.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PropertyFindUniqueArgs>(args: SelectSubset<T, PropertyFindUniqueArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Property that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PropertyFindUniqueOrThrowArgs} args - Arguments to find a Property
     * @example
     * // Get one Property
     * const property = await prisma.property.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PropertyFindUniqueOrThrowArgs>(args: SelectSubset<T, PropertyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Property that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyFindFirstArgs} args - Arguments to find a Property
     * @example
     * // Get one Property
     * const property = await prisma.property.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PropertyFindFirstArgs>(args?: SelectSubset<T, PropertyFindFirstArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Property that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyFindFirstOrThrowArgs} args - Arguments to find a Property
     * @example
     * // Get one Property
     * const property = await prisma.property.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PropertyFindFirstOrThrowArgs>(args?: SelectSubset<T, PropertyFindFirstOrThrowArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Properties that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Properties
     * const properties = await prisma.property.findMany()
     * 
     * // Get first 10 Properties
     * const properties = await prisma.property.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const propertyWithIdOnly = await prisma.property.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PropertyFindManyArgs>(args?: SelectSubset<T, PropertyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Property.
     * @param {PropertyCreateArgs} args - Arguments to create a Property.
     * @example
     * // Create one Property
     * const Property = await prisma.property.create({
     *   data: {
     *     // ... data to create a Property
     *   }
     * })
     * 
     */
    create<T extends PropertyCreateArgs>(args: SelectSubset<T, PropertyCreateArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Properties.
     * @param {PropertyCreateManyArgs} args - Arguments to create many Properties.
     * @example
     * // Create many Properties
     * const property = await prisma.property.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PropertyCreateManyArgs>(args?: SelectSubset<T, PropertyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Properties and returns the data saved in the database.
     * @param {PropertyCreateManyAndReturnArgs} args - Arguments to create many Properties.
     * @example
     * // Create many Properties
     * const property = await prisma.property.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Properties and only return the `id`
     * const propertyWithIdOnly = await prisma.property.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PropertyCreateManyAndReturnArgs>(args?: SelectSubset<T, PropertyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Property.
     * @param {PropertyDeleteArgs} args - Arguments to delete one Property.
     * @example
     * // Delete one Property
     * const Property = await prisma.property.delete({
     *   where: {
     *     // ... filter to delete one Property
     *   }
     * })
     * 
     */
    delete<T extends PropertyDeleteArgs>(args: SelectSubset<T, PropertyDeleteArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Property.
     * @param {PropertyUpdateArgs} args - Arguments to update one Property.
     * @example
     * // Update one Property
     * const property = await prisma.property.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PropertyUpdateArgs>(args: SelectSubset<T, PropertyUpdateArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Properties.
     * @param {PropertyDeleteManyArgs} args - Arguments to filter Properties to delete.
     * @example
     * // Delete a few Properties
     * const { count } = await prisma.property.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PropertyDeleteManyArgs>(args?: SelectSubset<T, PropertyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Properties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Properties
     * const property = await prisma.property.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PropertyUpdateManyArgs>(args: SelectSubset<T, PropertyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Properties and returns the data updated in the database.
     * @param {PropertyUpdateManyAndReturnArgs} args - Arguments to update many Properties.
     * @example
     * // Update many Properties
     * const property = await prisma.property.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Properties and only return the `id`
     * const propertyWithIdOnly = await prisma.property.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PropertyUpdateManyAndReturnArgs>(args: SelectSubset<T, PropertyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Property.
     * @param {PropertyUpsertArgs} args - Arguments to update or create a Property.
     * @example
     * // Update or create a Property
     * const property = await prisma.property.upsert({
     *   create: {
     *     // ... data to create a Property
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Property we want to update
     *   }
     * })
     */
    upsert<T extends PropertyUpsertArgs>(args: SelectSubset<T, PropertyUpsertArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Properties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyCountArgs} args - Arguments to filter Properties to count.
     * @example
     * // Count the number of Properties
     * const count = await prisma.property.count({
     *   where: {
     *     // ... the filter for the Properties we want to count
     *   }
     * })
    **/
    count<T extends PropertyCountArgs>(
      args?: Subset<T, PropertyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PropertyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Property.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PropertyAggregateArgs>(args: Subset<T, PropertyAggregateArgs>): Prisma.PrismaPromise<GetPropertyAggregateType<T>>

    /**
     * Group by Property.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PropertyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PropertyGroupByArgs['orderBy'] }
        : { orderBy?: PropertyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PropertyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPropertyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Property model
   */
  readonly fields: PropertyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Property.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PropertyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    address<T extends Property$addressArgs<ExtArgs> = {}>(args?: Subset<T, Property$addressArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    photos<T extends Property$photosArgs<ExtArgs> = {}>(args?: Subset<T, Property$photosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PhotoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    documents<T extends Property$documentsArgs<ExtArgs> = {}>(args?: Subset<T, Property$documentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    systems<T extends Property$systemsArgs<ExtArgs> = {}>(args?: Subset<T, Property$systemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemInstallationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    serviceHistory<T extends Property$serviceHistoryArgs<ExtArgs> = {}>(args?: Subset<T, Property$serviceHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    customer<T extends CustomerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerDefaultArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    projects<T extends Property$projectsArgs<ExtArgs> = {}>(args?: Subset<T, Property$projectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    proposals<T extends Property$proposalsArgs<ExtArgs> = {}>(args?: Subset<T, Property$proposalsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProposalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Property model
   */
  interface PropertyFieldRefs {
    readonly id: FieldRef<"Property", 'String'>
    readonly name: FieldRef<"Property", 'String'>
    readonly type: FieldRef<"Property", 'String'>
    readonly addressId: FieldRef<"Property", 'String'>
    readonly squareFootage: FieldRef<"Property", 'Float'>
    readonly bedrooms: FieldRef<"Property", 'Int'>
    readonly bathrooms: FieldRef<"Property", 'Int'>
    readonly yearBuilt: FieldRef<"Property", 'Int'>
    readonly customerId: FieldRef<"Property", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Property findUnique
   */
  export type PropertyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * Filter, which Property to fetch.
     */
    where: PropertyWhereUniqueInput
  }

  /**
   * Property findUniqueOrThrow
   */
  export type PropertyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * Filter, which Property to fetch.
     */
    where: PropertyWhereUniqueInput
  }

  /**
   * Property findFirst
   */
  export type PropertyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * Filter, which Property to fetch.
     */
    where?: PropertyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Properties to fetch.
     */
    orderBy?: PropertyOrderByWithRelationInput | PropertyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Properties.
     */
    cursor?: PropertyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Properties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Properties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Properties.
     */
    distinct?: PropertyScalarFieldEnum | PropertyScalarFieldEnum[]
  }

  /**
   * Property findFirstOrThrow
   */
  export type PropertyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * Filter, which Property to fetch.
     */
    where?: PropertyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Properties to fetch.
     */
    orderBy?: PropertyOrderByWithRelationInput | PropertyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Properties.
     */
    cursor?: PropertyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Properties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Properties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Properties.
     */
    distinct?: PropertyScalarFieldEnum | PropertyScalarFieldEnum[]
  }

  /**
   * Property findMany
   */
  export type PropertyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * Filter, which Properties to fetch.
     */
    where?: PropertyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Properties to fetch.
     */
    orderBy?: PropertyOrderByWithRelationInput | PropertyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Properties.
     */
    cursor?: PropertyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Properties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Properties.
     */
    skip?: number
    distinct?: PropertyScalarFieldEnum | PropertyScalarFieldEnum[]
  }

  /**
   * Property create
   */
  export type PropertyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * The data needed to create a Property.
     */
    data: XOR<PropertyCreateInput, PropertyUncheckedCreateInput>
  }

  /**
   * Property createMany
   */
  export type PropertyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Properties.
     */
    data: PropertyCreateManyInput | PropertyCreateManyInput[]
  }

  /**
   * Property createManyAndReturn
   */
  export type PropertyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * The data used to create many Properties.
     */
    data: PropertyCreateManyInput | PropertyCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Property update
   */
  export type PropertyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * The data needed to update a Property.
     */
    data: XOR<PropertyUpdateInput, PropertyUncheckedUpdateInput>
    /**
     * Choose, which Property to update.
     */
    where: PropertyWhereUniqueInput
  }

  /**
   * Property updateMany
   */
  export type PropertyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Properties.
     */
    data: XOR<PropertyUpdateManyMutationInput, PropertyUncheckedUpdateManyInput>
    /**
     * Filter which Properties to update
     */
    where?: PropertyWhereInput
    /**
     * Limit how many Properties to update.
     */
    limit?: number
  }

  /**
   * Property updateManyAndReturn
   */
  export type PropertyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * The data used to update Properties.
     */
    data: XOR<PropertyUpdateManyMutationInput, PropertyUncheckedUpdateManyInput>
    /**
     * Filter which Properties to update
     */
    where?: PropertyWhereInput
    /**
     * Limit how many Properties to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Property upsert
   */
  export type PropertyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * The filter to search for the Property to update in case it exists.
     */
    where: PropertyWhereUniqueInput
    /**
     * In case the Property found by the `where` argument doesn't exist, create a new Property with this data.
     */
    create: XOR<PropertyCreateInput, PropertyUncheckedCreateInput>
    /**
     * In case the Property was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PropertyUpdateInput, PropertyUncheckedUpdateInput>
  }

  /**
   * Property delete
   */
  export type PropertyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * Filter which Property to delete.
     */
    where: PropertyWhereUniqueInput
  }

  /**
   * Property deleteMany
   */
  export type PropertyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Properties to delete
     */
    where?: PropertyWhereInput
    /**
     * Limit how many Properties to delete.
     */
    limit?: number
  }

  /**
   * Property.address
   */
  export type Property$addressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    where?: AddressWhereInput
  }

  /**
   * Property.photos
   */
  export type Property$photosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Photo
     */
    select?: PhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Photo
     */
    omit?: PhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhotoInclude<ExtArgs> | null
    where?: PhotoWhereInput
    orderBy?: PhotoOrderByWithRelationInput | PhotoOrderByWithRelationInput[]
    cursor?: PhotoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PhotoScalarFieldEnum | PhotoScalarFieldEnum[]
  }

  /**
   * Property.documents
   */
  export type Property$documentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    cursor?: DocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Property.systems
   */
  export type Property$systemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemInstallation
     */
    select?: SystemInstallationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemInstallation
     */
    omit?: SystemInstallationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemInstallationInclude<ExtArgs> | null
    where?: SystemInstallationWhereInput
    orderBy?: SystemInstallationOrderByWithRelationInput | SystemInstallationOrderByWithRelationInput[]
    cursor?: SystemInstallationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SystemInstallationScalarFieldEnum | SystemInstallationScalarFieldEnum[]
  }

  /**
   * Property.serviceHistory
   */
  export type Property$serviceHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceRecord
     */
    select?: ServiceRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceRecord
     */
    omit?: ServiceRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceRecordInclude<ExtArgs> | null
    where?: ServiceRecordWhereInput
    orderBy?: ServiceRecordOrderByWithRelationInput | ServiceRecordOrderByWithRelationInput[]
    cursor?: ServiceRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceRecordScalarFieldEnum | ServiceRecordScalarFieldEnum[]
  }

  /**
   * Property.projects
   */
  export type Property$projectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    cursor?: ProjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Property.proposals
   */
  export type Property$proposalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proposal
     */
    select?: ProposalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Proposal
     */
    omit?: ProposalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalInclude<ExtArgs> | null
    where?: ProposalWhereInput
    orderBy?: ProposalOrderByWithRelationInput | ProposalOrderByWithRelationInput[]
    cursor?: ProposalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProposalScalarFieldEnum | ProposalScalarFieldEnum[]
  }

  /**
   * Property without action
   */
  export type PropertyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
  }


  /**
   * Model Photo
   */

  export type AggregatePhoto = {
    _count: PhotoCountAggregateOutputType | null
    _min: PhotoMinAggregateOutputType | null
    _max: PhotoMaxAggregateOutputType | null
  }

  export type PhotoMinAggregateOutputType = {
    id: string | null
    url: string | null
    propertyId: string | null
    uploadedAt: Date | null
    uploadedBy: string | null
  }

  export type PhotoMaxAggregateOutputType = {
    id: string | null
    url: string | null
    propertyId: string | null
    uploadedAt: Date | null
    uploadedBy: string | null
  }

  export type PhotoCountAggregateOutputType = {
    id: number
    url: number
    propertyId: number
    uploadedAt: number
    uploadedBy: number
    _all: number
  }


  export type PhotoMinAggregateInputType = {
    id?: true
    url?: true
    propertyId?: true
    uploadedAt?: true
    uploadedBy?: true
  }

  export type PhotoMaxAggregateInputType = {
    id?: true
    url?: true
    propertyId?: true
    uploadedAt?: true
    uploadedBy?: true
  }

  export type PhotoCountAggregateInputType = {
    id?: true
    url?: true
    propertyId?: true
    uploadedAt?: true
    uploadedBy?: true
    _all?: true
  }

  export type PhotoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Photo to aggregate.
     */
    where?: PhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Photos to fetch.
     */
    orderBy?: PhotoOrderByWithRelationInput | PhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Photos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Photos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Photos
    **/
    _count?: true | PhotoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PhotoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PhotoMaxAggregateInputType
  }

  export type GetPhotoAggregateType<T extends PhotoAggregateArgs> = {
        [P in keyof T & keyof AggregatePhoto]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePhoto[P]>
      : GetScalarType<T[P], AggregatePhoto[P]>
  }




  export type PhotoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PhotoWhereInput
    orderBy?: PhotoOrderByWithAggregationInput | PhotoOrderByWithAggregationInput[]
    by: PhotoScalarFieldEnum[] | PhotoScalarFieldEnum
    having?: PhotoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PhotoCountAggregateInputType | true
    _min?: PhotoMinAggregateInputType
    _max?: PhotoMaxAggregateInputType
  }

  export type PhotoGroupByOutputType = {
    id: string
    url: string
    propertyId: string
    uploadedAt: Date
    uploadedBy: string
    _count: PhotoCountAggregateOutputType | null
    _min: PhotoMinAggregateOutputType | null
    _max: PhotoMaxAggregateOutputType | null
  }

  type GetPhotoGroupByPayload<T extends PhotoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PhotoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PhotoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PhotoGroupByOutputType[P]>
            : GetScalarType<T[P], PhotoGroupByOutputType[P]>
        }
      >
    >


  export type PhotoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    propertyId?: boolean
    uploadedAt?: boolean
    uploadedBy?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["photo"]>

  export type PhotoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    propertyId?: boolean
    uploadedAt?: boolean
    uploadedBy?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["photo"]>

  export type PhotoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    propertyId?: boolean
    uploadedAt?: boolean
    uploadedBy?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["photo"]>

  export type PhotoSelectScalar = {
    id?: boolean
    url?: boolean
    propertyId?: boolean
    uploadedAt?: boolean
    uploadedBy?: boolean
  }

  export type PhotoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "url" | "propertyId" | "uploadedAt" | "uploadedBy", ExtArgs["result"]["photo"]>
  export type PhotoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }
  export type PhotoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }
  export type PhotoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }

  export type $PhotoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Photo"
    objects: {
      property: Prisma.$PropertyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      url: string
      propertyId: string
      uploadedAt: Date
      uploadedBy: string
    }, ExtArgs["result"]["photo"]>
    composites: {}
  }

  type PhotoGetPayload<S extends boolean | null | undefined | PhotoDefaultArgs> = $Result.GetResult<Prisma.$PhotoPayload, S>

  type PhotoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PhotoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PhotoCountAggregateInputType | true
    }

  export interface PhotoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Photo'], meta: { name: 'Photo' } }
    /**
     * Find zero or one Photo that matches the filter.
     * @param {PhotoFindUniqueArgs} args - Arguments to find a Photo
     * @example
     * // Get one Photo
     * const photo = await prisma.photo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PhotoFindUniqueArgs>(args: SelectSubset<T, PhotoFindUniqueArgs<ExtArgs>>): Prisma__PhotoClient<$Result.GetResult<Prisma.$PhotoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Photo that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PhotoFindUniqueOrThrowArgs} args - Arguments to find a Photo
     * @example
     * // Get one Photo
     * const photo = await prisma.photo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PhotoFindUniqueOrThrowArgs>(args: SelectSubset<T, PhotoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PhotoClient<$Result.GetResult<Prisma.$PhotoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Photo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhotoFindFirstArgs} args - Arguments to find a Photo
     * @example
     * // Get one Photo
     * const photo = await prisma.photo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PhotoFindFirstArgs>(args?: SelectSubset<T, PhotoFindFirstArgs<ExtArgs>>): Prisma__PhotoClient<$Result.GetResult<Prisma.$PhotoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Photo that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhotoFindFirstOrThrowArgs} args - Arguments to find a Photo
     * @example
     * // Get one Photo
     * const photo = await prisma.photo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PhotoFindFirstOrThrowArgs>(args?: SelectSubset<T, PhotoFindFirstOrThrowArgs<ExtArgs>>): Prisma__PhotoClient<$Result.GetResult<Prisma.$PhotoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Photos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhotoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Photos
     * const photos = await prisma.photo.findMany()
     * 
     * // Get first 10 Photos
     * const photos = await prisma.photo.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const photoWithIdOnly = await prisma.photo.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PhotoFindManyArgs>(args?: SelectSubset<T, PhotoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PhotoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Photo.
     * @param {PhotoCreateArgs} args - Arguments to create a Photo.
     * @example
     * // Create one Photo
     * const Photo = await prisma.photo.create({
     *   data: {
     *     // ... data to create a Photo
     *   }
     * })
     * 
     */
    create<T extends PhotoCreateArgs>(args: SelectSubset<T, PhotoCreateArgs<ExtArgs>>): Prisma__PhotoClient<$Result.GetResult<Prisma.$PhotoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Photos.
     * @param {PhotoCreateManyArgs} args - Arguments to create many Photos.
     * @example
     * // Create many Photos
     * const photo = await prisma.photo.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PhotoCreateManyArgs>(args?: SelectSubset<T, PhotoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Photos and returns the data saved in the database.
     * @param {PhotoCreateManyAndReturnArgs} args - Arguments to create many Photos.
     * @example
     * // Create many Photos
     * const photo = await prisma.photo.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Photos and only return the `id`
     * const photoWithIdOnly = await prisma.photo.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PhotoCreateManyAndReturnArgs>(args?: SelectSubset<T, PhotoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PhotoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Photo.
     * @param {PhotoDeleteArgs} args - Arguments to delete one Photo.
     * @example
     * // Delete one Photo
     * const Photo = await prisma.photo.delete({
     *   where: {
     *     // ... filter to delete one Photo
     *   }
     * })
     * 
     */
    delete<T extends PhotoDeleteArgs>(args: SelectSubset<T, PhotoDeleteArgs<ExtArgs>>): Prisma__PhotoClient<$Result.GetResult<Prisma.$PhotoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Photo.
     * @param {PhotoUpdateArgs} args - Arguments to update one Photo.
     * @example
     * // Update one Photo
     * const photo = await prisma.photo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PhotoUpdateArgs>(args: SelectSubset<T, PhotoUpdateArgs<ExtArgs>>): Prisma__PhotoClient<$Result.GetResult<Prisma.$PhotoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Photos.
     * @param {PhotoDeleteManyArgs} args - Arguments to filter Photos to delete.
     * @example
     * // Delete a few Photos
     * const { count } = await prisma.photo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PhotoDeleteManyArgs>(args?: SelectSubset<T, PhotoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Photos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhotoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Photos
     * const photo = await prisma.photo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PhotoUpdateManyArgs>(args: SelectSubset<T, PhotoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Photos and returns the data updated in the database.
     * @param {PhotoUpdateManyAndReturnArgs} args - Arguments to update many Photos.
     * @example
     * // Update many Photos
     * const photo = await prisma.photo.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Photos and only return the `id`
     * const photoWithIdOnly = await prisma.photo.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PhotoUpdateManyAndReturnArgs>(args: SelectSubset<T, PhotoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PhotoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Photo.
     * @param {PhotoUpsertArgs} args - Arguments to update or create a Photo.
     * @example
     * // Update or create a Photo
     * const photo = await prisma.photo.upsert({
     *   create: {
     *     // ... data to create a Photo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Photo we want to update
     *   }
     * })
     */
    upsert<T extends PhotoUpsertArgs>(args: SelectSubset<T, PhotoUpsertArgs<ExtArgs>>): Prisma__PhotoClient<$Result.GetResult<Prisma.$PhotoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Photos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhotoCountArgs} args - Arguments to filter Photos to count.
     * @example
     * // Count the number of Photos
     * const count = await prisma.photo.count({
     *   where: {
     *     // ... the filter for the Photos we want to count
     *   }
     * })
    **/
    count<T extends PhotoCountArgs>(
      args?: Subset<T, PhotoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PhotoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Photo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhotoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PhotoAggregateArgs>(args: Subset<T, PhotoAggregateArgs>): Prisma.PrismaPromise<GetPhotoAggregateType<T>>

    /**
     * Group by Photo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhotoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PhotoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PhotoGroupByArgs['orderBy'] }
        : { orderBy?: PhotoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PhotoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPhotoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Photo model
   */
  readonly fields: PhotoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Photo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PhotoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    property<T extends PropertyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PropertyDefaultArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Photo model
   */
  interface PhotoFieldRefs {
    readonly id: FieldRef<"Photo", 'String'>
    readonly url: FieldRef<"Photo", 'String'>
    readonly propertyId: FieldRef<"Photo", 'String'>
    readonly uploadedAt: FieldRef<"Photo", 'DateTime'>
    readonly uploadedBy: FieldRef<"Photo", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Photo findUnique
   */
  export type PhotoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Photo
     */
    select?: PhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Photo
     */
    omit?: PhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhotoInclude<ExtArgs> | null
    /**
     * Filter, which Photo to fetch.
     */
    where: PhotoWhereUniqueInput
  }

  /**
   * Photo findUniqueOrThrow
   */
  export type PhotoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Photo
     */
    select?: PhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Photo
     */
    omit?: PhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhotoInclude<ExtArgs> | null
    /**
     * Filter, which Photo to fetch.
     */
    where: PhotoWhereUniqueInput
  }

  /**
   * Photo findFirst
   */
  export type PhotoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Photo
     */
    select?: PhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Photo
     */
    omit?: PhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhotoInclude<ExtArgs> | null
    /**
     * Filter, which Photo to fetch.
     */
    where?: PhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Photos to fetch.
     */
    orderBy?: PhotoOrderByWithRelationInput | PhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Photos.
     */
    cursor?: PhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Photos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Photos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Photos.
     */
    distinct?: PhotoScalarFieldEnum | PhotoScalarFieldEnum[]
  }

  /**
   * Photo findFirstOrThrow
   */
  export type PhotoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Photo
     */
    select?: PhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Photo
     */
    omit?: PhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhotoInclude<ExtArgs> | null
    /**
     * Filter, which Photo to fetch.
     */
    where?: PhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Photos to fetch.
     */
    orderBy?: PhotoOrderByWithRelationInput | PhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Photos.
     */
    cursor?: PhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Photos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Photos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Photos.
     */
    distinct?: PhotoScalarFieldEnum | PhotoScalarFieldEnum[]
  }

  /**
   * Photo findMany
   */
  export type PhotoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Photo
     */
    select?: PhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Photo
     */
    omit?: PhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhotoInclude<ExtArgs> | null
    /**
     * Filter, which Photos to fetch.
     */
    where?: PhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Photos to fetch.
     */
    orderBy?: PhotoOrderByWithRelationInput | PhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Photos.
     */
    cursor?: PhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Photos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Photos.
     */
    skip?: number
    distinct?: PhotoScalarFieldEnum | PhotoScalarFieldEnum[]
  }

  /**
   * Photo create
   */
  export type PhotoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Photo
     */
    select?: PhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Photo
     */
    omit?: PhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhotoInclude<ExtArgs> | null
    /**
     * The data needed to create a Photo.
     */
    data: XOR<PhotoCreateInput, PhotoUncheckedCreateInput>
  }

  /**
   * Photo createMany
   */
  export type PhotoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Photos.
     */
    data: PhotoCreateManyInput | PhotoCreateManyInput[]
  }

  /**
   * Photo createManyAndReturn
   */
  export type PhotoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Photo
     */
    select?: PhotoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Photo
     */
    omit?: PhotoOmit<ExtArgs> | null
    /**
     * The data used to create many Photos.
     */
    data: PhotoCreateManyInput | PhotoCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhotoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Photo update
   */
  export type PhotoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Photo
     */
    select?: PhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Photo
     */
    omit?: PhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhotoInclude<ExtArgs> | null
    /**
     * The data needed to update a Photo.
     */
    data: XOR<PhotoUpdateInput, PhotoUncheckedUpdateInput>
    /**
     * Choose, which Photo to update.
     */
    where: PhotoWhereUniqueInput
  }

  /**
   * Photo updateMany
   */
  export type PhotoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Photos.
     */
    data: XOR<PhotoUpdateManyMutationInput, PhotoUncheckedUpdateManyInput>
    /**
     * Filter which Photos to update
     */
    where?: PhotoWhereInput
    /**
     * Limit how many Photos to update.
     */
    limit?: number
  }

  /**
   * Photo updateManyAndReturn
   */
  export type PhotoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Photo
     */
    select?: PhotoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Photo
     */
    omit?: PhotoOmit<ExtArgs> | null
    /**
     * The data used to update Photos.
     */
    data: XOR<PhotoUpdateManyMutationInput, PhotoUncheckedUpdateManyInput>
    /**
     * Filter which Photos to update
     */
    where?: PhotoWhereInput
    /**
     * Limit how many Photos to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhotoIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Photo upsert
   */
  export type PhotoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Photo
     */
    select?: PhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Photo
     */
    omit?: PhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhotoInclude<ExtArgs> | null
    /**
     * The filter to search for the Photo to update in case it exists.
     */
    where: PhotoWhereUniqueInput
    /**
     * In case the Photo found by the `where` argument doesn't exist, create a new Photo with this data.
     */
    create: XOR<PhotoCreateInput, PhotoUncheckedCreateInput>
    /**
     * In case the Photo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PhotoUpdateInput, PhotoUncheckedUpdateInput>
  }

  /**
   * Photo delete
   */
  export type PhotoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Photo
     */
    select?: PhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Photo
     */
    omit?: PhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhotoInclude<ExtArgs> | null
    /**
     * Filter which Photo to delete.
     */
    where: PhotoWhereUniqueInput
  }

  /**
   * Photo deleteMany
   */
  export type PhotoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Photos to delete
     */
    where?: PhotoWhereInput
    /**
     * Limit how many Photos to delete.
     */
    limit?: number
  }

  /**
   * Photo without action
   */
  export type PhotoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Photo
     */
    select?: PhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Photo
     */
    omit?: PhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhotoInclude<ExtArgs> | null
  }


  /**
   * Model Document
   */

  export type AggregateDocument = {
    _count: DocumentCountAggregateOutputType | null
    _min: DocumentMinAggregateOutputType | null
    _max: DocumentMaxAggregateOutputType | null
  }

  export type DocumentMinAggregateOutputType = {
    id: string | null
    name: string | null
    url: string | null
    type: string | null
    propertyId: string | null
    projectId: string | null
    uploadedAt: Date | null
    uploadedBy: string | null
  }

  export type DocumentMaxAggregateOutputType = {
    id: string | null
    name: string | null
    url: string | null
    type: string | null
    propertyId: string | null
    projectId: string | null
    uploadedAt: Date | null
    uploadedBy: string | null
  }

  export type DocumentCountAggregateOutputType = {
    id: number
    name: number
    url: number
    type: number
    propertyId: number
    projectId: number
    uploadedAt: number
    uploadedBy: number
    _all: number
  }


  export type DocumentMinAggregateInputType = {
    id?: true
    name?: true
    url?: true
    type?: true
    propertyId?: true
    projectId?: true
    uploadedAt?: true
    uploadedBy?: true
  }

  export type DocumentMaxAggregateInputType = {
    id?: true
    name?: true
    url?: true
    type?: true
    propertyId?: true
    projectId?: true
    uploadedAt?: true
    uploadedBy?: true
  }

  export type DocumentCountAggregateInputType = {
    id?: true
    name?: true
    url?: true
    type?: true
    propertyId?: true
    projectId?: true
    uploadedAt?: true
    uploadedBy?: true
    _all?: true
  }

  export type DocumentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Document to aggregate.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Documents
    **/
    _count?: true | DocumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DocumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DocumentMaxAggregateInputType
  }

  export type GetDocumentAggregateType<T extends DocumentAggregateArgs> = {
        [P in keyof T & keyof AggregateDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDocument[P]>
      : GetScalarType<T[P], AggregateDocument[P]>
  }




  export type DocumentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithAggregationInput | DocumentOrderByWithAggregationInput[]
    by: DocumentScalarFieldEnum[] | DocumentScalarFieldEnum
    having?: DocumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DocumentCountAggregateInputType | true
    _min?: DocumentMinAggregateInputType
    _max?: DocumentMaxAggregateInputType
  }

  export type DocumentGroupByOutputType = {
    id: string
    name: string
    url: string
    type: string
    propertyId: string | null
    projectId: string | null
    uploadedAt: Date
    uploadedBy: string
    _count: DocumentCountAggregateOutputType | null
    _min: DocumentMinAggregateOutputType | null
    _max: DocumentMaxAggregateOutputType | null
  }

  type GetDocumentGroupByPayload<T extends DocumentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DocumentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DocumentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DocumentGroupByOutputType[P]>
            : GetScalarType<T[P], DocumentGroupByOutputType[P]>
        }
      >
    >


  export type DocumentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    url?: boolean
    type?: boolean
    propertyId?: boolean
    projectId?: boolean
    uploadedAt?: boolean
    uploadedBy?: boolean
    property?: boolean | Document$propertyArgs<ExtArgs>
    project?: boolean | Document$projectArgs<ExtArgs>
  }, ExtArgs["result"]["document"]>

  export type DocumentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    url?: boolean
    type?: boolean
    propertyId?: boolean
    projectId?: boolean
    uploadedAt?: boolean
    uploadedBy?: boolean
    property?: boolean | Document$propertyArgs<ExtArgs>
    project?: boolean | Document$projectArgs<ExtArgs>
  }, ExtArgs["result"]["document"]>

  export type DocumentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    url?: boolean
    type?: boolean
    propertyId?: boolean
    projectId?: boolean
    uploadedAt?: boolean
    uploadedBy?: boolean
    property?: boolean | Document$propertyArgs<ExtArgs>
    project?: boolean | Document$projectArgs<ExtArgs>
  }, ExtArgs["result"]["document"]>

  export type DocumentSelectScalar = {
    id?: boolean
    name?: boolean
    url?: boolean
    type?: boolean
    propertyId?: boolean
    projectId?: boolean
    uploadedAt?: boolean
    uploadedBy?: boolean
  }

  export type DocumentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "url" | "type" | "propertyId" | "projectId" | "uploadedAt" | "uploadedBy", ExtArgs["result"]["document"]>
  export type DocumentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | Document$propertyArgs<ExtArgs>
    project?: boolean | Document$projectArgs<ExtArgs>
  }
  export type DocumentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | Document$propertyArgs<ExtArgs>
    project?: boolean | Document$projectArgs<ExtArgs>
  }
  export type DocumentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | Document$propertyArgs<ExtArgs>
    project?: boolean | Document$projectArgs<ExtArgs>
  }

  export type $DocumentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Document"
    objects: {
      property: Prisma.$PropertyPayload<ExtArgs> | null
      project: Prisma.$ProjectPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      url: string
      type: string
      propertyId: string | null
      projectId: string | null
      uploadedAt: Date
      uploadedBy: string
    }, ExtArgs["result"]["document"]>
    composites: {}
  }

  type DocumentGetPayload<S extends boolean | null | undefined | DocumentDefaultArgs> = $Result.GetResult<Prisma.$DocumentPayload, S>

  type DocumentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DocumentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DocumentCountAggregateInputType | true
    }

  export interface DocumentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Document'], meta: { name: 'Document' } }
    /**
     * Find zero or one Document that matches the filter.
     * @param {DocumentFindUniqueArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DocumentFindUniqueArgs>(args: SelectSubset<T, DocumentFindUniqueArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Document that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DocumentFindUniqueOrThrowArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DocumentFindUniqueOrThrowArgs>(args: SelectSubset<T, DocumentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Document that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindFirstArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DocumentFindFirstArgs>(args?: SelectSubset<T, DocumentFindFirstArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Document that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindFirstOrThrowArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DocumentFindFirstOrThrowArgs>(args?: SelectSubset<T, DocumentFindFirstOrThrowArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Documents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Documents
     * const documents = await prisma.document.findMany()
     * 
     * // Get first 10 Documents
     * const documents = await prisma.document.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const documentWithIdOnly = await prisma.document.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DocumentFindManyArgs>(args?: SelectSubset<T, DocumentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Document.
     * @param {DocumentCreateArgs} args - Arguments to create a Document.
     * @example
     * // Create one Document
     * const Document = await prisma.document.create({
     *   data: {
     *     // ... data to create a Document
     *   }
     * })
     * 
     */
    create<T extends DocumentCreateArgs>(args: SelectSubset<T, DocumentCreateArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Documents.
     * @param {DocumentCreateManyArgs} args - Arguments to create many Documents.
     * @example
     * // Create many Documents
     * const document = await prisma.document.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DocumentCreateManyArgs>(args?: SelectSubset<T, DocumentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Documents and returns the data saved in the database.
     * @param {DocumentCreateManyAndReturnArgs} args - Arguments to create many Documents.
     * @example
     * // Create many Documents
     * const document = await prisma.document.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Documents and only return the `id`
     * const documentWithIdOnly = await prisma.document.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DocumentCreateManyAndReturnArgs>(args?: SelectSubset<T, DocumentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Document.
     * @param {DocumentDeleteArgs} args - Arguments to delete one Document.
     * @example
     * // Delete one Document
     * const Document = await prisma.document.delete({
     *   where: {
     *     // ... filter to delete one Document
     *   }
     * })
     * 
     */
    delete<T extends DocumentDeleteArgs>(args: SelectSubset<T, DocumentDeleteArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Document.
     * @param {DocumentUpdateArgs} args - Arguments to update one Document.
     * @example
     * // Update one Document
     * const document = await prisma.document.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DocumentUpdateArgs>(args: SelectSubset<T, DocumentUpdateArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Documents.
     * @param {DocumentDeleteManyArgs} args - Arguments to filter Documents to delete.
     * @example
     * // Delete a few Documents
     * const { count } = await prisma.document.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DocumentDeleteManyArgs>(args?: SelectSubset<T, DocumentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Documents
     * const document = await prisma.document.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DocumentUpdateManyArgs>(args: SelectSubset<T, DocumentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Documents and returns the data updated in the database.
     * @param {DocumentUpdateManyAndReturnArgs} args - Arguments to update many Documents.
     * @example
     * // Update many Documents
     * const document = await prisma.document.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Documents and only return the `id`
     * const documentWithIdOnly = await prisma.document.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DocumentUpdateManyAndReturnArgs>(args: SelectSubset<T, DocumentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Document.
     * @param {DocumentUpsertArgs} args - Arguments to update or create a Document.
     * @example
     * // Update or create a Document
     * const document = await prisma.document.upsert({
     *   create: {
     *     // ... data to create a Document
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Document we want to update
     *   }
     * })
     */
    upsert<T extends DocumentUpsertArgs>(args: SelectSubset<T, DocumentUpsertArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentCountArgs} args - Arguments to filter Documents to count.
     * @example
     * // Count the number of Documents
     * const count = await prisma.document.count({
     *   where: {
     *     // ... the filter for the Documents we want to count
     *   }
     * })
    **/
    count<T extends DocumentCountArgs>(
      args?: Subset<T, DocumentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DocumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Document.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DocumentAggregateArgs>(args: Subset<T, DocumentAggregateArgs>): Prisma.PrismaPromise<GetDocumentAggregateType<T>>

    /**
     * Group by Document.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DocumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DocumentGroupByArgs['orderBy'] }
        : { orderBy?: DocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DocumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDocumentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Document model
   */
  readonly fields: DocumentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Document.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DocumentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    property<T extends Document$propertyArgs<ExtArgs> = {}>(args?: Subset<T, Document$propertyArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    project<T extends Document$projectArgs<ExtArgs> = {}>(args?: Subset<T, Document$projectArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Document model
   */
  interface DocumentFieldRefs {
    readonly id: FieldRef<"Document", 'String'>
    readonly name: FieldRef<"Document", 'String'>
    readonly url: FieldRef<"Document", 'String'>
    readonly type: FieldRef<"Document", 'String'>
    readonly propertyId: FieldRef<"Document", 'String'>
    readonly projectId: FieldRef<"Document", 'String'>
    readonly uploadedAt: FieldRef<"Document", 'DateTime'>
    readonly uploadedBy: FieldRef<"Document", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Document findUnique
   */
  export type DocumentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document findUniqueOrThrow
   */
  export type DocumentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document findFirst
   */
  export type DocumentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Documents.
     */
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Document findFirstOrThrow
   */
  export type DocumentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Documents.
     */
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Document findMany
   */
  export type DocumentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Documents to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Document create
   */
  export type DocumentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The data needed to create a Document.
     */
    data: XOR<DocumentCreateInput, DocumentUncheckedCreateInput>
  }

  /**
   * Document createMany
   */
  export type DocumentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Documents.
     */
    data: DocumentCreateManyInput | DocumentCreateManyInput[]
  }

  /**
   * Document createManyAndReturn
   */
  export type DocumentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * The data used to create many Documents.
     */
    data: DocumentCreateManyInput | DocumentCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Document update
   */
  export type DocumentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The data needed to update a Document.
     */
    data: XOR<DocumentUpdateInput, DocumentUncheckedUpdateInput>
    /**
     * Choose, which Document to update.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document updateMany
   */
  export type DocumentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Documents.
     */
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyInput>
    /**
     * Filter which Documents to update
     */
    where?: DocumentWhereInput
    /**
     * Limit how many Documents to update.
     */
    limit?: number
  }

  /**
   * Document updateManyAndReturn
   */
  export type DocumentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * The data used to update Documents.
     */
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyInput>
    /**
     * Filter which Documents to update
     */
    where?: DocumentWhereInput
    /**
     * Limit how many Documents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Document upsert
   */
  export type DocumentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The filter to search for the Document to update in case it exists.
     */
    where: DocumentWhereUniqueInput
    /**
     * In case the Document found by the `where` argument doesn't exist, create a new Document with this data.
     */
    create: XOR<DocumentCreateInput, DocumentUncheckedCreateInput>
    /**
     * In case the Document was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DocumentUpdateInput, DocumentUncheckedUpdateInput>
  }

  /**
   * Document delete
   */
  export type DocumentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter which Document to delete.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document deleteMany
   */
  export type DocumentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Documents to delete
     */
    where?: DocumentWhereInput
    /**
     * Limit how many Documents to delete.
     */
    limit?: number
  }

  /**
   * Document.property
   */
  export type Document$propertyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    where?: PropertyWhereInput
  }

  /**
   * Document.project
   */
  export type Document$projectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
  }

  /**
   * Document without action
   */
  export type DocumentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
  }


  /**
   * Model SystemInstallation
   */

  export type AggregateSystemInstallation = {
    _count: SystemInstallationCountAggregateOutputType | null
    _min: SystemInstallationMinAggregateOutputType | null
    _max: SystemInstallationMaxAggregateOutputType | null
  }

  export type SystemInstallationMinAggregateOutputType = {
    id: string | null
    type: string | null
    details: string | null
    installDate: Date | null
    lastService: Date | null
    propertyId: string | null
  }

  export type SystemInstallationMaxAggregateOutputType = {
    id: string | null
    type: string | null
    details: string | null
    installDate: Date | null
    lastService: Date | null
    propertyId: string | null
  }

  export type SystemInstallationCountAggregateOutputType = {
    id: number
    type: number
    details: number
    installDate: number
    lastService: number
    propertyId: number
    _all: number
  }


  export type SystemInstallationMinAggregateInputType = {
    id?: true
    type?: true
    details?: true
    installDate?: true
    lastService?: true
    propertyId?: true
  }

  export type SystemInstallationMaxAggregateInputType = {
    id?: true
    type?: true
    details?: true
    installDate?: true
    lastService?: true
    propertyId?: true
  }

  export type SystemInstallationCountAggregateInputType = {
    id?: true
    type?: true
    details?: true
    installDate?: true
    lastService?: true
    propertyId?: true
    _all?: true
  }

  export type SystemInstallationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemInstallation to aggregate.
     */
    where?: SystemInstallationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemInstallations to fetch.
     */
    orderBy?: SystemInstallationOrderByWithRelationInput | SystemInstallationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SystemInstallationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemInstallations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemInstallations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SystemInstallations
    **/
    _count?: true | SystemInstallationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SystemInstallationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SystemInstallationMaxAggregateInputType
  }

  export type GetSystemInstallationAggregateType<T extends SystemInstallationAggregateArgs> = {
        [P in keyof T & keyof AggregateSystemInstallation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSystemInstallation[P]>
      : GetScalarType<T[P], AggregateSystemInstallation[P]>
  }




  export type SystemInstallationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SystemInstallationWhereInput
    orderBy?: SystemInstallationOrderByWithAggregationInput | SystemInstallationOrderByWithAggregationInput[]
    by: SystemInstallationScalarFieldEnum[] | SystemInstallationScalarFieldEnum
    having?: SystemInstallationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SystemInstallationCountAggregateInputType | true
    _min?: SystemInstallationMinAggregateInputType
    _max?: SystemInstallationMaxAggregateInputType
  }

  export type SystemInstallationGroupByOutputType = {
    id: string
    type: string
    details: string
    installDate: Date | null
    lastService: Date | null
    propertyId: string
    _count: SystemInstallationCountAggregateOutputType | null
    _min: SystemInstallationMinAggregateOutputType | null
    _max: SystemInstallationMaxAggregateOutputType | null
  }

  type GetSystemInstallationGroupByPayload<T extends SystemInstallationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SystemInstallationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SystemInstallationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SystemInstallationGroupByOutputType[P]>
            : GetScalarType<T[P], SystemInstallationGroupByOutputType[P]>
        }
      >
    >


  export type SystemInstallationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    details?: boolean
    installDate?: boolean
    lastService?: boolean
    propertyId?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["systemInstallation"]>

  export type SystemInstallationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    details?: boolean
    installDate?: boolean
    lastService?: boolean
    propertyId?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["systemInstallation"]>

  export type SystemInstallationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    details?: boolean
    installDate?: boolean
    lastService?: boolean
    propertyId?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["systemInstallation"]>

  export type SystemInstallationSelectScalar = {
    id?: boolean
    type?: boolean
    details?: boolean
    installDate?: boolean
    lastService?: boolean
    propertyId?: boolean
  }

  export type SystemInstallationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type" | "details" | "installDate" | "lastService" | "propertyId", ExtArgs["result"]["systemInstallation"]>
  export type SystemInstallationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }
  export type SystemInstallationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }
  export type SystemInstallationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }

  export type $SystemInstallationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SystemInstallation"
    objects: {
      property: Prisma.$PropertyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: string
      details: string
      installDate: Date | null
      lastService: Date | null
      propertyId: string
    }, ExtArgs["result"]["systemInstallation"]>
    composites: {}
  }

  type SystemInstallationGetPayload<S extends boolean | null | undefined | SystemInstallationDefaultArgs> = $Result.GetResult<Prisma.$SystemInstallationPayload, S>

  type SystemInstallationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SystemInstallationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SystemInstallationCountAggregateInputType | true
    }

  export interface SystemInstallationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SystemInstallation'], meta: { name: 'SystemInstallation' } }
    /**
     * Find zero or one SystemInstallation that matches the filter.
     * @param {SystemInstallationFindUniqueArgs} args - Arguments to find a SystemInstallation
     * @example
     * // Get one SystemInstallation
     * const systemInstallation = await prisma.systemInstallation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SystemInstallationFindUniqueArgs>(args: SelectSubset<T, SystemInstallationFindUniqueArgs<ExtArgs>>): Prisma__SystemInstallationClient<$Result.GetResult<Prisma.$SystemInstallationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SystemInstallation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SystemInstallationFindUniqueOrThrowArgs} args - Arguments to find a SystemInstallation
     * @example
     * // Get one SystemInstallation
     * const systemInstallation = await prisma.systemInstallation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SystemInstallationFindUniqueOrThrowArgs>(args: SelectSubset<T, SystemInstallationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SystemInstallationClient<$Result.GetResult<Prisma.$SystemInstallationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SystemInstallation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemInstallationFindFirstArgs} args - Arguments to find a SystemInstallation
     * @example
     * // Get one SystemInstallation
     * const systemInstallation = await prisma.systemInstallation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SystemInstallationFindFirstArgs>(args?: SelectSubset<T, SystemInstallationFindFirstArgs<ExtArgs>>): Prisma__SystemInstallationClient<$Result.GetResult<Prisma.$SystemInstallationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SystemInstallation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemInstallationFindFirstOrThrowArgs} args - Arguments to find a SystemInstallation
     * @example
     * // Get one SystemInstallation
     * const systemInstallation = await prisma.systemInstallation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SystemInstallationFindFirstOrThrowArgs>(args?: SelectSubset<T, SystemInstallationFindFirstOrThrowArgs<ExtArgs>>): Prisma__SystemInstallationClient<$Result.GetResult<Prisma.$SystemInstallationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SystemInstallations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemInstallationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SystemInstallations
     * const systemInstallations = await prisma.systemInstallation.findMany()
     * 
     * // Get first 10 SystemInstallations
     * const systemInstallations = await prisma.systemInstallation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const systemInstallationWithIdOnly = await prisma.systemInstallation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SystemInstallationFindManyArgs>(args?: SelectSubset<T, SystemInstallationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemInstallationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SystemInstallation.
     * @param {SystemInstallationCreateArgs} args - Arguments to create a SystemInstallation.
     * @example
     * // Create one SystemInstallation
     * const SystemInstallation = await prisma.systemInstallation.create({
     *   data: {
     *     // ... data to create a SystemInstallation
     *   }
     * })
     * 
     */
    create<T extends SystemInstallationCreateArgs>(args: SelectSubset<T, SystemInstallationCreateArgs<ExtArgs>>): Prisma__SystemInstallationClient<$Result.GetResult<Prisma.$SystemInstallationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SystemInstallations.
     * @param {SystemInstallationCreateManyArgs} args - Arguments to create many SystemInstallations.
     * @example
     * // Create many SystemInstallations
     * const systemInstallation = await prisma.systemInstallation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SystemInstallationCreateManyArgs>(args?: SelectSubset<T, SystemInstallationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SystemInstallations and returns the data saved in the database.
     * @param {SystemInstallationCreateManyAndReturnArgs} args - Arguments to create many SystemInstallations.
     * @example
     * // Create many SystemInstallations
     * const systemInstallation = await prisma.systemInstallation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SystemInstallations and only return the `id`
     * const systemInstallationWithIdOnly = await prisma.systemInstallation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SystemInstallationCreateManyAndReturnArgs>(args?: SelectSubset<T, SystemInstallationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemInstallationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SystemInstallation.
     * @param {SystemInstallationDeleteArgs} args - Arguments to delete one SystemInstallation.
     * @example
     * // Delete one SystemInstallation
     * const SystemInstallation = await prisma.systemInstallation.delete({
     *   where: {
     *     // ... filter to delete one SystemInstallation
     *   }
     * })
     * 
     */
    delete<T extends SystemInstallationDeleteArgs>(args: SelectSubset<T, SystemInstallationDeleteArgs<ExtArgs>>): Prisma__SystemInstallationClient<$Result.GetResult<Prisma.$SystemInstallationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SystemInstallation.
     * @param {SystemInstallationUpdateArgs} args - Arguments to update one SystemInstallation.
     * @example
     * // Update one SystemInstallation
     * const systemInstallation = await prisma.systemInstallation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SystemInstallationUpdateArgs>(args: SelectSubset<T, SystemInstallationUpdateArgs<ExtArgs>>): Prisma__SystemInstallationClient<$Result.GetResult<Prisma.$SystemInstallationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SystemInstallations.
     * @param {SystemInstallationDeleteManyArgs} args - Arguments to filter SystemInstallations to delete.
     * @example
     * // Delete a few SystemInstallations
     * const { count } = await prisma.systemInstallation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SystemInstallationDeleteManyArgs>(args?: SelectSubset<T, SystemInstallationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemInstallations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemInstallationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SystemInstallations
     * const systemInstallation = await prisma.systemInstallation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SystemInstallationUpdateManyArgs>(args: SelectSubset<T, SystemInstallationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemInstallations and returns the data updated in the database.
     * @param {SystemInstallationUpdateManyAndReturnArgs} args - Arguments to update many SystemInstallations.
     * @example
     * // Update many SystemInstallations
     * const systemInstallation = await prisma.systemInstallation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SystemInstallations and only return the `id`
     * const systemInstallationWithIdOnly = await prisma.systemInstallation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SystemInstallationUpdateManyAndReturnArgs>(args: SelectSubset<T, SystemInstallationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemInstallationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SystemInstallation.
     * @param {SystemInstallationUpsertArgs} args - Arguments to update or create a SystemInstallation.
     * @example
     * // Update or create a SystemInstallation
     * const systemInstallation = await prisma.systemInstallation.upsert({
     *   create: {
     *     // ... data to create a SystemInstallation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SystemInstallation we want to update
     *   }
     * })
     */
    upsert<T extends SystemInstallationUpsertArgs>(args: SelectSubset<T, SystemInstallationUpsertArgs<ExtArgs>>): Prisma__SystemInstallationClient<$Result.GetResult<Prisma.$SystemInstallationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SystemInstallations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemInstallationCountArgs} args - Arguments to filter SystemInstallations to count.
     * @example
     * // Count the number of SystemInstallations
     * const count = await prisma.systemInstallation.count({
     *   where: {
     *     // ... the filter for the SystemInstallations we want to count
     *   }
     * })
    **/
    count<T extends SystemInstallationCountArgs>(
      args?: Subset<T, SystemInstallationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SystemInstallationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SystemInstallation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemInstallationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SystemInstallationAggregateArgs>(args: Subset<T, SystemInstallationAggregateArgs>): Prisma.PrismaPromise<GetSystemInstallationAggregateType<T>>

    /**
     * Group by SystemInstallation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemInstallationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SystemInstallationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SystemInstallationGroupByArgs['orderBy'] }
        : { orderBy?: SystemInstallationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SystemInstallationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSystemInstallationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SystemInstallation model
   */
  readonly fields: SystemInstallationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SystemInstallation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SystemInstallationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    property<T extends PropertyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PropertyDefaultArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SystemInstallation model
   */
  interface SystemInstallationFieldRefs {
    readonly id: FieldRef<"SystemInstallation", 'String'>
    readonly type: FieldRef<"SystemInstallation", 'String'>
    readonly details: FieldRef<"SystemInstallation", 'String'>
    readonly installDate: FieldRef<"SystemInstallation", 'DateTime'>
    readonly lastService: FieldRef<"SystemInstallation", 'DateTime'>
    readonly propertyId: FieldRef<"SystemInstallation", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SystemInstallation findUnique
   */
  export type SystemInstallationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemInstallation
     */
    select?: SystemInstallationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemInstallation
     */
    omit?: SystemInstallationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemInstallationInclude<ExtArgs> | null
    /**
     * Filter, which SystemInstallation to fetch.
     */
    where: SystemInstallationWhereUniqueInput
  }

  /**
   * SystemInstallation findUniqueOrThrow
   */
  export type SystemInstallationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemInstallation
     */
    select?: SystemInstallationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemInstallation
     */
    omit?: SystemInstallationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemInstallationInclude<ExtArgs> | null
    /**
     * Filter, which SystemInstallation to fetch.
     */
    where: SystemInstallationWhereUniqueInput
  }

  /**
   * SystemInstallation findFirst
   */
  export type SystemInstallationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemInstallation
     */
    select?: SystemInstallationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemInstallation
     */
    omit?: SystemInstallationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemInstallationInclude<ExtArgs> | null
    /**
     * Filter, which SystemInstallation to fetch.
     */
    where?: SystemInstallationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemInstallations to fetch.
     */
    orderBy?: SystemInstallationOrderByWithRelationInput | SystemInstallationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemInstallations.
     */
    cursor?: SystemInstallationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemInstallations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemInstallations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemInstallations.
     */
    distinct?: SystemInstallationScalarFieldEnum | SystemInstallationScalarFieldEnum[]
  }

  /**
   * SystemInstallation findFirstOrThrow
   */
  export type SystemInstallationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemInstallation
     */
    select?: SystemInstallationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemInstallation
     */
    omit?: SystemInstallationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemInstallationInclude<ExtArgs> | null
    /**
     * Filter, which SystemInstallation to fetch.
     */
    where?: SystemInstallationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemInstallations to fetch.
     */
    orderBy?: SystemInstallationOrderByWithRelationInput | SystemInstallationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemInstallations.
     */
    cursor?: SystemInstallationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemInstallations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemInstallations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemInstallations.
     */
    distinct?: SystemInstallationScalarFieldEnum | SystemInstallationScalarFieldEnum[]
  }

  /**
   * SystemInstallation findMany
   */
  export type SystemInstallationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemInstallation
     */
    select?: SystemInstallationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemInstallation
     */
    omit?: SystemInstallationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemInstallationInclude<ExtArgs> | null
    /**
     * Filter, which SystemInstallations to fetch.
     */
    where?: SystemInstallationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemInstallations to fetch.
     */
    orderBy?: SystemInstallationOrderByWithRelationInput | SystemInstallationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SystemInstallations.
     */
    cursor?: SystemInstallationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemInstallations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemInstallations.
     */
    skip?: number
    distinct?: SystemInstallationScalarFieldEnum | SystemInstallationScalarFieldEnum[]
  }

  /**
   * SystemInstallation create
   */
  export type SystemInstallationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemInstallation
     */
    select?: SystemInstallationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemInstallation
     */
    omit?: SystemInstallationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemInstallationInclude<ExtArgs> | null
    /**
     * The data needed to create a SystemInstallation.
     */
    data: XOR<SystemInstallationCreateInput, SystemInstallationUncheckedCreateInput>
  }

  /**
   * SystemInstallation createMany
   */
  export type SystemInstallationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SystemInstallations.
     */
    data: SystemInstallationCreateManyInput | SystemInstallationCreateManyInput[]
  }

  /**
   * SystemInstallation createManyAndReturn
   */
  export type SystemInstallationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemInstallation
     */
    select?: SystemInstallationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SystemInstallation
     */
    omit?: SystemInstallationOmit<ExtArgs> | null
    /**
     * The data used to create many SystemInstallations.
     */
    data: SystemInstallationCreateManyInput | SystemInstallationCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemInstallationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SystemInstallation update
   */
  export type SystemInstallationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemInstallation
     */
    select?: SystemInstallationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemInstallation
     */
    omit?: SystemInstallationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemInstallationInclude<ExtArgs> | null
    /**
     * The data needed to update a SystemInstallation.
     */
    data: XOR<SystemInstallationUpdateInput, SystemInstallationUncheckedUpdateInput>
    /**
     * Choose, which SystemInstallation to update.
     */
    where: SystemInstallationWhereUniqueInput
  }

  /**
   * SystemInstallation updateMany
   */
  export type SystemInstallationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SystemInstallations.
     */
    data: XOR<SystemInstallationUpdateManyMutationInput, SystemInstallationUncheckedUpdateManyInput>
    /**
     * Filter which SystemInstallations to update
     */
    where?: SystemInstallationWhereInput
    /**
     * Limit how many SystemInstallations to update.
     */
    limit?: number
  }

  /**
   * SystemInstallation updateManyAndReturn
   */
  export type SystemInstallationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemInstallation
     */
    select?: SystemInstallationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SystemInstallation
     */
    omit?: SystemInstallationOmit<ExtArgs> | null
    /**
     * The data used to update SystemInstallations.
     */
    data: XOR<SystemInstallationUpdateManyMutationInput, SystemInstallationUncheckedUpdateManyInput>
    /**
     * Filter which SystemInstallations to update
     */
    where?: SystemInstallationWhereInput
    /**
     * Limit how many SystemInstallations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemInstallationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SystemInstallation upsert
   */
  export type SystemInstallationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemInstallation
     */
    select?: SystemInstallationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemInstallation
     */
    omit?: SystemInstallationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemInstallationInclude<ExtArgs> | null
    /**
     * The filter to search for the SystemInstallation to update in case it exists.
     */
    where: SystemInstallationWhereUniqueInput
    /**
     * In case the SystemInstallation found by the `where` argument doesn't exist, create a new SystemInstallation with this data.
     */
    create: XOR<SystemInstallationCreateInput, SystemInstallationUncheckedCreateInput>
    /**
     * In case the SystemInstallation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SystemInstallationUpdateInput, SystemInstallationUncheckedUpdateInput>
  }

  /**
   * SystemInstallation delete
   */
  export type SystemInstallationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemInstallation
     */
    select?: SystemInstallationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemInstallation
     */
    omit?: SystemInstallationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemInstallationInclude<ExtArgs> | null
    /**
     * Filter which SystemInstallation to delete.
     */
    where: SystemInstallationWhereUniqueInput
  }

  /**
   * SystemInstallation deleteMany
   */
  export type SystemInstallationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemInstallations to delete
     */
    where?: SystemInstallationWhereInput
    /**
     * Limit how many SystemInstallations to delete.
     */
    limit?: number
  }

  /**
   * SystemInstallation without action
   */
  export type SystemInstallationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemInstallation
     */
    select?: SystemInstallationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemInstallation
     */
    omit?: SystemInstallationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemInstallationInclude<ExtArgs> | null
  }


  /**
   * Model ServiceRecord
   */

  export type AggregateServiceRecord = {
    _count: ServiceRecordCountAggregateOutputType | null
    _avg: ServiceRecordAvgAggregateOutputType | null
    _sum: ServiceRecordSumAggregateOutputType | null
    _min: ServiceRecordMinAggregateOutputType | null
    _max: ServiceRecordMaxAggregateOutputType | null
  }

  export type ServiceRecordAvgAggregateOutputType = {
    cost: number | null
  }

  export type ServiceRecordSumAggregateOutputType = {
    cost: number | null
  }

  export type ServiceRecordMinAggregateOutputType = {
    id: string | null
    date: Date | null
    type: string | null
    description: string | null
    technician: string | null
    cost: number | null
    propertyId: string | null
  }

  export type ServiceRecordMaxAggregateOutputType = {
    id: string | null
    date: Date | null
    type: string | null
    description: string | null
    technician: string | null
    cost: number | null
    propertyId: string | null
  }

  export type ServiceRecordCountAggregateOutputType = {
    id: number
    date: number
    type: number
    description: number
    technician: number
    cost: number
    propertyId: number
    _all: number
  }


  export type ServiceRecordAvgAggregateInputType = {
    cost?: true
  }

  export type ServiceRecordSumAggregateInputType = {
    cost?: true
  }

  export type ServiceRecordMinAggregateInputType = {
    id?: true
    date?: true
    type?: true
    description?: true
    technician?: true
    cost?: true
    propertyId?: true
  }

  export type ServiceRecordMaxAggregateInputType = {
    id?: true
    date?: true
    type?: true
    description?: true
    technician?: true
    cost?: true
    propertyId?: true
  }

  export type ServiceRecordCountAggregateInputType = {
    id?: true
    date?: true
    type?: true
    description?: true
    technician?: true
    cost?: true
    propertyId?: true
    _all?: true
  }

  export type ServiceRecordAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceRecord to aggregate.
     */
    where?: ServiceRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceRecords to fetch.
     */
    orderBy?: ServiceRecordOrderByWithRelationInput | ServiceRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ServiceRecords
    **/
    _count?: true | ServiceRecordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServiceRecordAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServiceRecordSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceRecordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceRecordMaxAggregateInputType
  }

  export type GetServiceRecordAggregateType<T extends ServiceRecordAggregateArgs> = {
        [P in keyof T & keyof AggregateServiceRecord]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServiceRecord[P]>
      : GetScalarType<T[P], AggregateServiceRecord[P]>
  }




  export type ServiceRecordGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceRecordWhereInput
    orderBy?: ServiceRecordOrderByWithAggregationInput | ServiceRecordOrderByWithAggregationInput[]
    by: ServiceRecordScalarFieldEnum[] | ServiceRecordScalarFieldEnum
    having?: ServiceRecordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceRecordCountAggregateInputType | true
    _avg?: ServiceRecordAvgAggregateInputType
    _sum?: ServiceRecordSumAggregateInputType
    _min?: ServiceRecordMinAggregateInputType
    _max?: ServiceRecordMaxAggregateInputType
  }

  export type ServiceRecordGroupByOutputType = {
    id: string
    date: Date
    type: string
    description: string
    technician: string
    cost: number
    propertyId: string
    _count: ServiceRecordCountAggregateOutputType | null
    _avg: ServiceRecordAvgAggregateOutputType | null
    _sum: ServiceRecordSumAggregateOutputType | null
    _min: ServiceRecordMinAggregateOutputType | null
    _max: ServiceRecordMaxAggregateOutputType | null
  }

  type GetServiceRecordGroupByPayload<T extends ServiceRecordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceRecordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceRecordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceRecordGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceRecordGroupByOutputType[P]>
        }
      >
    >


  export type ServiceRecordSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    type?: boolean
    description?: boolean
    technician?: boolean
    cost?: boolean
    propertyId?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["serviceRecord"]>

  export type ServiceRecordSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    type?: boolean
    description?: boolean
    technician?: boolean
    cost?: boolean
    propertyId?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["serviceRecord"]>

  export type ServiceRecordSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    type?: boolean
    description?: boolean
    technician?: boolean
    cost?: boolean
    propertyId?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["serviceRecord"]>

  export type ServiceRecordSelectScalar = {
    id?: boolean
    date?: boolean
    type?: boolean
    description?: boolean
    technician?: boolean
    cost?: boolean
    propertyId?: boolean
  }

  export type ServiceRecordOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "date" | "type" | "description" | "technician" | "cost" | "propertyId", ExtArgs["result"]["serviceRecord"]>
  export type ServiceRecordInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }
  export type ServiceRecordIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }
  export type ServiceRecordIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }

  export type $ServiceRecordPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ServiceRecord"
    objects: {
      property: Prisma.$PropertyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      date: Date
      type: string
      description: string
      technician: string
      cost: number
      propertyId: string
    }, ExtArgs["result"]["serviceRecord"]>
    composites: {}
  }

  type ServiceRecordGetPayload<S extends boolean | null | undefined | ServiceRecordDefaultArgs> = $Result.GetResult<Prisma.$ServiceRecordPayload, S>

  type ServiceRecordCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ServiceRecordFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ServiceRecordCountAggregateInputType | true
    }

  export interface ServiceRecordDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ServiceRecord'], meta: { name: 'ServiceRecord' } }
    /**
     * Find zero or one ServiceRecord that matches the filter.
     * @param {ServiceRecordFindUniqueArgs} args - Arguments to find a ServiceRecord
     * @example
     * // Get one ServiceRecord
     * const serviceRecord = await prisma.serviceRecord.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiceRecordFindUniqueArgs>(args: SelectSubset<T, ServiceRecordFindUniqueArgs<ExtArgs>>): Prisma__ServiceRecordClient<$Result.GetResult<Prisma.$ServiceRecordPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ServiceRecord that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ServiceRecordFindUniqueOrThrowArgs} args - Arguments to find a ServiceRecord
     * @example
     * // Get one ServiceRecord
     * const serviceRecord = await prisma.serviceRecord.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiceRecordFindUniqueOrThrowArgs>(args: SelectSubset<T, ServiceRecordFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServiceRecordClient<$Result.GetResult<Prisma.$ServiceRecordPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServiceRecord that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceRecordFindFirstArgs} args - Arguments to find a ServiceRecord
     * @example
     * // Get one ServiceRecord
     * const serviceRecord = await prisma.serviceRecord.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiceRecordFindFirstArgs>(args?: SelectSubset<T, ServiceRecordFindFirstArgs<ExtArgs>>): Prisma__ServiceRecordClient<$Result.GetResult<Prisma.$ServiceRecordPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServiceRecord that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceRecordFindFirstOrThrowArgs} args - Arguments to find a ServiceRecord
     * @example
     * // Get one ServiceRecord
     * const serviceRecord = await prisma.serviceRecord.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiceRecordFindFirstOrThrowArgs>(args?: SelectSubset<T, ServiceRecordFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServiceRecordClient<$Result.GetResult<Prisma.$ServiceRecordPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ServiceRecords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceRecordFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ServiceRecords
     * const serviceRecords = await prisma.serviceRecord.findMany()
     * 
     * // Get first 10 ServiceRecords
     * const serviceRecords = await prisma.serviceRecord.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceRecordWithIdOnly = await prisma.serviceRecord.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ServiceRecordFindManyArgs>(args?: SelectSubset<T, ServiceRecordFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ServiceRecord.
     * @param {ServiceRecordCreateArgs} args - Arguments to create a ServiceRecord.
     * @example
     * // Create one ServiceRecord
     * const ServiceRecord = await prisma.serviceRecord.create({
     *   data: {
     *     // ... data to create a ServiceRecord
     *   }
     * })
     * 
     */
    create<T extends ServiceRecordCreateArgs>(args: SelectSubset<T, ServiceRecordCreateArgs<ExtArgs>>): Prisma__ServiceRecordClient<$Result.GetResult<Prisma.$ServiceRecordPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ServiceRecords.
     * @param {ServiceRecordCreateManyArgs} args - Arguments to create many ServiceRecords.
     * @example
     * // Create many ServiceRecords
     * const serviceRecord = await prisma.serviceRecord.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServiceRecordCreateManyArgs>(args?: SelectSubset<T, ServiceRecordCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ServiceRecords and returns the data saved in the database.
     * @param {ServiceRecordCreateManyAndReturnArgs} args - Arguments to create many ServiceRecords.
     * @example
     * // Create many ServiceRecords
     * const serviceRecord = await prisma.serviceRecord.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ServiceRecords and only return the `id`
     * const serviceRecordWithIdOnly = await prisma.serviceRecord.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ServiceRecordCreateManyAndReturnArgs>(args?: SelectSubset<T, ServiceRecordCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceRecordPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ServiceRecord.
     * @param {ServiceRecordDeleteArgs} args - Arguments to delete one ServiceRecord.
     * @example
     * // Delete one ServiceRecord
     * const ServiceRecord = await prisma.serviceRecord.delete({
     *   where: {
     *     // ... filter to delete one ServiceRecord
     *   }
     * })
     * 
     */
    delete<T extends ServiceRecordDeleteArgs>(args: SelectSubset<T, ServiceRecordDeleteArgs<ExtArgs>>): Prisma__ServiceRecordClient<$Result.GetResult<Prisma.$ServiceRecordPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ServiceRecord.
     * @param {ServiceRecordUpdateArgs} args - Arguments to update one ServiceRecord.
     * @example
     * // Update one ServiceRecord
     * const serviceRecord = await prisma.serviceRecord.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServiceRecordUpdateArgs>(args: SelectSubset<T, ServiceRecordUpdateArgs<ExtArgs>>): Prisma__ServiceRecordClient<$Result.GetResult<Prisma.$ServiceRecordPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ServiceRecords.
     * @param {ServiceRecordDeleteManyArgs} args - Arguments to filter ServiceRecords to delete.
     * @example
     * // Delete a few ServiceRecords
     * const { count } = await prisma.serviceRecord.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServiceRecordDeleteManyArgs>(args?: SelectSubset<T, ServiceRecordDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceRecordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ServiceRecords
     * const serviceRecord = await prisma.serviceRecord.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServiceRecordUpdateManyArgs>(args: SelectSubset<T, ServiceRecordUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceRecords and returns the data updated in the database.
     * @param {ServiceRecordUpdateManyAndReturnArgs} args - Arguments to update many ServiceRecords.
     * @example
     * // Update many ServiceRecords
     * const serviceRecord = await prisma.serviceRecord.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ServiceRecords and only return the `id`
     * const serviceRecordWithIdOnly = await prisma.serviceRecord.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ServiceRecordUpdateManyAndReturnArgs>(args: SelectSubset<T, ServiceRecordUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceRecordPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ServiceRecord.
     * @param {ServiceRecordUpsertArgs} args - Arguments to update or create a ServiceRecord.
     * @example
     * // Update or create a ServiceRecord
     * const serviceRecord = await prisma.serviceRecord.upsert({
     *   create: {
     *     // ... data to create a ServiceRecord
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ServiceRecord we want to update
     *   }
     * })
     */
    upsert<T extends ServiceRecordUpsertArgs>(args: SelectSubset<T, ServiceRecordUpsertArgs<ExtArgs>>): Prisma__ServiceRecordClient<$Result.GetResult<Prisma.$ServiceRecordPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ServiceRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceRecordCountArgs} args - Arguments to filter ServiceRecords to count.
     * @example
     * // Count the number of ServiceRecords
     * const count = await prisma.serviceRecord.count({
     *   where: {
     *     // ... the filter for the ServiceRecords we want to count
     *   }
     * })
    **/
    count<T extends ServiceRecordCountArgs>(
      args?: Subset<T, ServiceRecordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceRecordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ServiceRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceRecordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceRecordAggregateArgs>(args: Subset<T, ServiceRecordAggregateArgs>): Prisma.PrismaPromise<GetServiceRecordAggregateType<T>>

    /**
     * Group by ServiceRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceRecordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceRecordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceRecordGroupByArgs['orderBy'] }
        : { orderBy?: ServiceRecordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceRecordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceRecordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ServiceRecord model
   */
  readonly fields: ServiceRecordFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ServiceRecord.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceRecordClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    property<T extends PropertyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PropertyDefaultArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ServiceRecord model
   */
  interface ServiceRecordFieldRefs {
    readonly id: FieldRef<"ServiceRecord", 'String'>
    readonly date: FieldRef<"ServiceRecord", 'DateTime'>
    readonly type: FieldRef<"ServiceRecord", 'String'>
    readonly description: FieldRef<"ServiceRecord", 'String'>
    readonly technician: FieldRef<"ServiceRecord", 'String'>
    readonly cost: FieldRef<"ServiceRecord", 'Float'>
    readonly propertyId: FieldRef<"ServiceRecord", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ServiceRecord findUnique
   */
  export type ServiceRecordFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceRecord
     */
    select?: ServiceRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceRecord
     */
    omit?: ServiceRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceRecordInclude<ExtArgs> | null
    /**
     * Filter, which ServiceRecord to fetch.
     */
    where: ServiceRecordWhereUniqueInput
  }

  /**
   * ServiceRecord findUniqueOrThrow
   */
  export type ServiceRecordFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceRecord
     */
    select?: ServiceRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceRecord
     */
    omit?: ServiceRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceRecordInclude<ExtArgs> | null
    /**
     * Filter, which ServiceRecord to fetch.
     */
    where: ServiceRecordWhereUniqueInput
  }

  /**
   * ServiceRecord findFirst
   */
  export type ServiceRecordFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceRecord
     */
    select?: ServiceRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceRecord
     */
    omit?: ServiceRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceRecordInclude<ExtArgs> | null
    /**
     * Filter, which ServiceRecord to fetch.
     */
    where?: ServiceRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceRecords to fetch.
     */
    orderBy?: ServiceRecordOrderByWithRelationInput | ServiceRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceRecords.
     */
    cursor?: ServiceRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceRecords.
     */
    distinct?: ServiceRecordScalarFieldEnum | ServiceRecordScalarFieldEnum[]
  }

  /**
   * ServiceRecord findFirstOrThrow
   */
  export type ServiceRecordFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceRecord
     */
    select?: ServiceRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceRecord
     */
    omit?: ServiceRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceRecordInclude<ExtArgs> | null
    /**
     * Filter, which ServiceRecord to fetch.
     */
    where?: ServiceRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceRecords to fetch.
     */
    orderBy?: ServiceRecordOrderByWithRelationInput | ServiceRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceRecords.
     */
    cursor?: ServiceRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceRecords.
     */
    distinct?: ServiceRecordScalarFieldEnum | ServiceRecordScalarFieldEnum[]
  }

  /**
   * ServiceRecord findMany
   */
  export type ServiceRecordFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceRecord
     */
    select?: ServiceRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceRecord
     */
    omit?: ServiceRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceRecordInclude<ExtArgs> | null
    /**
     * Filter, which ServiceRecords to fetch.
     */
    where?: ServiceRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceRecords to fetch.
     */
    orderBy?: ServiceRecordOrderByWithRelationInput | ServiceRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ServiceRecords.
     */
    cursor?: ServiceRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceRecords.
     */
    skip?: number
    distinct?: ServiceRecordScalarFieldEnum | ServiceRecordScalarFieldEnum[]
  }

  /**
   * ServiceRecord create
   */
  export type ServiceRecordCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceRecord
     */
    select?: ServiceRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceRecord
     */
    omit?: ServiceRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceRecordInclude<ExtArgs> | null
    /**
     * The data needed to create a ServiceRecord.
     */
    data: XOR<ServiceRecordCreateInput, ServiceRecordUncheckedCreateInput>
  }

  /**
   * ServiceRecord createMany
   */
  export type ServiceRecordCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ServiceRecords.
     */
    data: ServiceRecordCreateManyInput | ServiceRecordCreateManyInput[]
  }

  /**
   * ServiceRecord createManyAndReturn
   */
  export type ServiceRecordCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceRecord
     */
    select?: ServiceRecordSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceRecord
     */
    omit?: ServiceRecordOmit<ExtArgs> | null
    /**
     * The data used to create many ServiceRecords.
     */
    data: ServiceRecordCreateManyInput | ServiceRecordCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceRecordIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ServiceRecord update
   */
  export type ServiceRecordUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceRecord
     */
    select?: ServiceRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceRecord
     */
    omit?: ServiceRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceRecordInclude<ExtArgs> | null
    /**
     * The data needed to update a ServiceRecord.
     */
    data: XOR<ServiceRecordUpdateInput, ServiceRecordUncheckedUpdateInput>
    /**
     * Choose, which ServiceRecord to update.
     */
    where: ServiceRecordWhereUniqueInput
  }

  /**
   * ServiceRecord updateMany
   */
  export type ServiceRecordUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ServiceRecords.
     */
    data: XOR<ServiceRecordUpdateManyMutationInput, ServiceRecordUncheckedUpdateManyInput>
    /**
     * Filter which ServiceRecords to update
     */
    where?: ServiceRecordWhereInput
    /**
     * Limit how many ServiceRecords to update.
     */
    limit?: number
  }

  /**
   * ServiceRecord updateManyAndReturn
   */
  export type ServiceRecordUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceRecord
     */
    select?: ServiceRecordSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceRecord
     */
    omit?: ServiceRecordOmit<ExtArgs> | null
    /**
     * The data used to update ServiceRecords.
     */
    data: XOR<ServiceRecordUpdateManyMutationInput, ServiceRecordUncheckedUpdateManyInput>
    /**
     * Filter which ServiceRecords to update
     */
    where?: ServiceRecordWhereInput
    /**
     * Limit how many ServiceRecords to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceRecordIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ServiceRecord upsert
   */
  export type ServiceRecordUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceRecord
     */
    select?: ServiceRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceRecord
     */
    omit?: ServiceRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceRecordInclude<ExtArgs> | null
    /**
     * The filter to search for the ServiceRecord to update in case it exists.
     */
    where: ServiceRecordWhereUniqueInput
    /**
     * In case the ServiceRecord found by the `where` argument doesn't exist, create a new ServiceRecord with this data.
     */
    create: XOR<ServiceRecordCreateInput, ServiceRecordUncheckedCreateInput>
    /**
     * In case the ServiceRecord was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceRecordUpdateInput, ServiceRecordUncheckedUpdateInput>
  }

  /**
   * ServiceRecord delete
   */
  export type ServiceRecordDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceRecord
     */
    select?: ServiceRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceRecord
     */
    omit?: ServiceRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceRecordInclude<ExtArgs> | null
    /**
     * Filter which ServiceRecord to delete.
     */
    where: ServiceRecordWhereUniqueInput
  }

  /**
   * ServiceRecord deleteMany
   */
  export type ServiceRecordDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceRecords to delete
     */
    where?: ServiceRecordWhereInput
    /**
     * Limit how many ServiceRecords to delete.
     */
    limit?: number
  }

  /**
   * ServiceRecord without action
   */
  export type ServiceRecordDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceRecord
     */
    select?: ServiceRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceRecord
     */
    omit?: ServiceRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceRecordInclude<ExtArgs> | null
  }


  /**
   * Model Project
   */

  export type AggregateProject = {
    _count: ProjectCountAggregateOutputType | null
    _min: ProjectMinAggregateOutputType | null
    _max: ProjectMaxAggregateOutputType | null
  }

  export type ProjectMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    status: string | null
    startDate: Date | null
    endDate: Date | null
    propertyId: string | null
    customerId: string | null
  }

  export type ProjectMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    status: string | null
    startDate: Date | null
    endDate: Date | null
    propertyId: string | null
    customerId: string | null
  }

  export type ProjectCountAggregateOutputType = {
    id: number
    name: number
    description: number
    status: number
    startDate: number
    endDate: number
    propertyId: number
    customerId: number
    _all: number
  }


  export type ProjectMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    status?: true
    startDate?: true
    endDate?: true
    propertyId?: true
    customerId?: true
  }

  export type ProjectMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    status?: true
    startDate?: true
    endDate?: true
    propertyId?: true
    customerId?: true
  }

  export type ProjectCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    status?: true
    startDate?: true
    endDate?: true
    propertyId?: true
    customerId?: true
    _all?: true
  }

  export type ProjectAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Project to aggregate.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Projects
    **/
    _count?: true | ProjectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectMaxAggregateInputType
  }

  export type GetProjectAggregateType<T extends ProjectAggregateArgs> = {
        [P in keyof T & keyof AggregateProject]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProject[P]>
      : GetScalarType<T[P], AggregateProject[P]>
  }




  export type ProjectGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithAggregationInput | ProjectOrderByWithAggregationInput[]
    by: ProjectScalarFieldEnum[] | ProjectScalarFieldEnum
    having?: ProjectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectCountAggregateInputType | true
    _min?: ProjectMinAggregateInputType
    _max?: ProjectMaxAggregateInputType
  }

  export type ProjectGroupByOutputType = {
    id: string
    name: string
    description: string
    status: string
    startDate: Date
    endDate: Date | null
    propertyId: string
    customerId: string
    _count: ProjectCountAggregateOutputType | null
    _min: ProjectMinAggregateOutputType | null
    _max: ProjectMaxAggregateOutputType | null
  }

  type GetProjectGroupByPayload<T extends ProjectGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectGroupByOutputType[P]>
        }
      >
    >


  export type ProjectSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    startDate?: boolean
    endDate?: boolean
    propertyId?: boolean
    customerId?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    teamMembers?: boolean | Project$teamMembersArgs<ExtArgs>
    milestones?: boolean | Project$milestonesArgs<ExtArgs>
    budget?: boolean | Project$budgetArgs<ExtArgs>
    documents?: boolean | Project$documentsArgs<ExtArgs>
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    proposals?: boolean | Project$proposalsArgs<ExtArgs>
    _count?: boolean | ProjectCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["project"]>

  export type ProjectSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    startDate?: boolean
    endDate?: boolean
    propertyId?: boolean
    customerId?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["project"]>

  export type ProjectSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    startDate?: boolean
    endDate?: boolean
    propertyId?: boolean
    customerId?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["project"]>

  export type ProjectSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    startDate?: boolean
    endDate?: boolean
    propertyId?: boolean
    customerId?: boolean
  }

  export type ProjectOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "status" | "startDate" | "endDate" | "propertyId" | "customerId", ExtArgs["result"]["project"]>
  export type ProjectInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    teamMembers?: boolean | Project$teamMembersArgs<ExtArgs>
    milestones?: boolean | Project$milestonesArgs<ExtArgs>
    budget?: boolean | Project$budgetArgs<ExtArgs>
    documents?: boolean | Project$documentsArgs<ExtArgs>
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    proposals?: boolean | Project$proposalsArgs<ExtArgs>
    _count?: boolean | ProjectCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProjectIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }
  export type ProjectIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }

  export type $ProjectPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Project"
    objects: {
      property: Prisma.$PropertyPayload<ExtArgs>
      teamMembers: Prisma.$ProjectTeamMemberPayload<ExtArgs>[]
      milestones: Prisma.$MilestonePayload<ExtArgs>[]
      budget: Prisma.$BudgetPayload<ExtArgs> | null
      documents: Prisma.$DocumentPayload<ExtArgs>[]
      customer: Prisma.$CustomerPayload<ExtArgs>
      proposals: Prisma.$ProposalPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string
      status: string
      startDate: Date
      endDate: Date | null
      propertyId: string
      customerId: string
    }, ExtArgs["result"]["project"]>
    composites: {}
  }

  type ProjectGetPayload<S extends boolean | null | undefined | ProjectDefaultArgs> = $Result.GetResult<Prisma.$ProjectPayload, S>

  type ProjectCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProjectFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProjectCountAggregateInputType | true
    }

  export interface ProjectDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Project'], meta: { name: 'Project' } }
    /**
     * Find zero or one Project that matches the filter.
     * @param {ProjectFindUniqueArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectFindUniqueArgs>(args: SelectSubset<T, ProjectFindUniqueArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Project that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProjectFindUniqueOrThrowArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Project that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindFirstArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectFindFirstArgs>(args?: SelectSubset<T, ProjectFindFirstArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Project that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindFirstOrThrowArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Projects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Projects
     * const projects = await prisma.project.findMany()
     * 
     * // Get first 10 Projects
     * const projects = await prisma.project.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectWithIdOnly = await prisma.project.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProjectFindManyArgs>(args?: SelectSubset<T, ProjectFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Project.
     * @param {ProjectCreateArgs} args - Arguments to create a Project.
     * @example
     * // Create one Project
     * const Project = await prisma.project.create({
     *   data: {
     *     // ... data to create a Project
     *   }
     * })
     * 
     */
    create<T extends ProjectCreateArgs>(args: SelectSubset<T, ProjectCreateArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Projects.
     * @param {ProjectCreateManyArgs} args - Arguments to create many Projects.
     * @example
     * // Create many Projects
     * const project = await prisma.project.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectCreateManyArgs>(args?: SelectSubset<T, ProjectCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Projects and returns the data saved in the database.
     * @param {ProjectCreateManyAndReturnArgs} args - Arguments to create many Projects.
     * @example
     * // Create many Projects
     * const project = await prisma.project.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Projects and only return the `id`
     * const projectWithIdOnly = await prisma.project.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProjectCreateManyAndReturnArgs>(args?: SelectSubset<T, ProjectCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Project.
     * @param {ProjectDeleteArgs} args - Arguments to delete one Project.
     * @example
     * // Delete one Project
     * const Project = await prisma.project.delete({
     *   where: {
     *     // ... filter to delete one Project
     *   }
     * })
     * 
     */
    delete<T extends ProjectDeleteArgs>(args: SelectSubset<T, ProjectDeleteArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Project.
     * @param {ProjectUpdateArgs} args - Arguments to update one Project.
     * @example
     * // Update one Project
     * const project = await prisma.project.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectUpdateArgs>(args: SelectSubset<T, ProjectUpdateArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Projects.
     * @param {ProjectDeleteManyArgs} args - Arguments to filter Projects to delete.
     * @example
     * // Delete a few Projects
     * const { count } = await prisma.project.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectDeleteManyArgs>(args?: SelectSubset<T, ProjectDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Projects
     * const project = await prisma.project.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectUpdateManyArgs>(args: SelectSubset<T, ProjectUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Projects and returns the data updated in the database.
     * @param {ProjectUpdateManyAndReturnArgs} args - Arguments to update many Projects.
     * @example
     * // Update many Projects
     * const project = await prisma.project.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Projects and only return the `id`
     * const projectWithIdOnly = await prisma.project.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProjectUpdateManyAndReturnArgs>(args: SelectSubset<T, ProjectUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Project.
     * @param {ProjectUpsertArgs} args - Arguments to update or create a Project.
     * @example
     * // Update or create a Project
     * const project = await prisma.project.upsert({
     *   create: {
     *     // ... data to create a Project
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Project we want to update
     *   }
     * })
     */
    upsert<T extends ProjectUpsertArgs>(args: SelectSubset<T, ProjectUpsertArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectCountArgs} args - Arguments to filter Projects to count.
     * @example
     * // Count the number of Projects
     * const count = await prisma.project.count({
     *   where: {
     *     // ... the filter for the Projects we want to count
     *   }
     * })
    **/
    count<T extends ProjectCountArgs>(
      args?: Subset<T, ProjectCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Project.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectAggregateArgs>(args: Subset<T, ProjectAggregateArgs>): Prisma.PrismaPromise<GetProjectAggregateType<T>>

    /**
     * Group by Project.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectGroupByArgs['orderBy'] }
        : { orderBy?: ProjectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Project model
   */
  readonly fields: ProjectFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Project.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    property<T extends PropertyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PropertyDefaultArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    teamMembers<T extends Project$teamMembersArgs<ExtArgs> = {}>(args?: Subset<T, Project$teamMembersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectTeamMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    milestones<T extends Project$milestonesArgs<ExtArgs> = {}>(args?: Subset<T, Project$milestonesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    budget<T extends Project$budgetArgs<ExtArgs> = {}>(args?: Subset<T, Project$budgetArgs<ExtArgs>>): Prisma__BudgetClient<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    documents<T extends Project$documentsArgs<ExtArgs> = {}>(args?: Subset<T, Project$documentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    customer<T extends CustomerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerDefaultArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    proposals<T extends Project$proposalsArgs<ExtArgs> = {}>(args?: Subset<T, Project$proposalsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProposalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Project model
   */
  interface ProjectFieldRefs {
    readonly id: FieldRef<"Project", 'String'>
    readonly name: FieldRef<"Project", 'String'>
    readonly description: FieldRef<"Project", 'String'>
    readonly status: FieldRef<"Project", 'String'>
    readonly startDate: FieldRef<"Project", 'DateTime'>
    readonly endDate: FieldRef<"Project", 'DateTime'>
    readonly propertyId: FieldRef<"Project", 'String'>
    readonly customerId: FieldRef<"Project", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Project findUnique
   */
  export type ProjectFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project findUniqueOrThrow
   */
  export type ProjectFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project findFirst
   */
  export type ProjectFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Projects.
     */
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project findFirstOrThrow
   */
  export type ProjectFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Projects.
     */
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project findMany
   */
  export type ProjectFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Projects to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project create
   */
  export type ProjectCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The data needed to create a Project.
     */
    data: XOR<ProjectCreateInput, ProjectUncheckedCreateInput>
  }

  /**
   * Project createMany
   */
  export type ProjectCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Projects.
     */
    data: ProjectCreateManyInput | ProjectCreateManyInput[]
  }

  /**
   * Project createManyAndReturn
   */
  export type ProjectCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * The data used to create many Projects.
     */
    data: ProjectCreateManyInput | ProjectCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Project update
   */
  export type ProjectUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The data needed to update a Project.
     */
    data: XOR<ProjectUpdateInput, ProjectUncheckedUpdateInput>
    /**
     * Choose, which Project to update.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project updateMany
   */
  export type ProjectUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Projects.
     */
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyInput>
    /**
     * Filter which Projects to update
     */
    where?: ProjectWhereInput
    /**
     * Limit how many Projects to update.
     */
    limit?: number
  }

  /**
   * Project updateManyAndReturn
   */
  export type ProjectUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * The data used to update Projects.
     */
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyInput>
    /**
     * Filter which Projects to update
     */
    where?: ProjectWhereInput
    /**
     * Limit how many Projects to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Project upsert
   */
  export type ProjectUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The filter to search for the Project to update in case it exists.
     */
    where: ProjectWhereUniqueInput
    /**
     * In case the Project found by the `where` argument doesn't exist, create a new Project with this data.
     */
    create: XOR<ProjectCreateInput, ProjectUncheckedCreateInput>
    /**
     * In case the Project was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectUpdateInput, ProjectUncheckedUpdateInput>
  }

  /**
   * Project delete
   */
  export type ProjectDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter which Project to delete.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project deleteMany
   */
  export type ProjectDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Projects to delete
     */
    where?: ProjectWhereInput
    /**
     * Limit how many Projects to delete.
     */
    limit?: number
  }

  /**
   * Project.teamMembers
   */
  export type Project$teamMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectTeamMember
     */
    select?: ProjectTeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectTeamMember
     */
    omit?: ProjectTeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectTeamMemberInclude<ExtArgs> | null
    where?: ProjectTeamMemberWhereInput
    orderBy?: ProjectTeamMemberOrderByWithRelationInput | ProjectTeamMemberOrderByWithRelationInput[]
    cursor?: ProjectTeamMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectTeamMemberScalarFieldEnum | ProjectTeamMemberScalarFieldEnum[]
  }

  /**
   * Project.milestones
   */
  export type Project$milestonesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Milestone
     */
    omit?: MilestoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilestoneInclude<ExtArgs> | null
    where?: MilestoneWhereInput
    orderBy?: MilestoneOrderByWithRelationInput | MilestoneOrderByWithRelationInput[]
    cursor?: MilestoneWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MilestoneScalarFieldEnum | MilestoneScalarFieldEnum[]
  }

  /**
   * Project.budget
   */
  export type Project$budgetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Budget
     */
    omit?: BudgetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
    where?: BudgetWhereInput
  }

  /**
   * Project.documents
   */
  export type Project$documentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    cursor?: DocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Project.proposals
   */
  export type Project$proposalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proposal
     */
    select?: ProposalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Proposal
     */
    omit?: ProposalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalInclude<ExtArgs> | null
    where?: ProposalWhereInput
    orderBy?: ProposalOrderByWithRelationInput | ProposalOrderByWithRelationInput[]
    cursor?: ProposalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProposalScalarFieldEnum | ProposalScalarFieldEnum[]
  }

  /**
   * Project without action
   */
  export type ProjectDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
  }


  /**
   * Model ProjectTeamMember
   */

  export type AggregateProjectTeamMember = {
    _count: ProjectTeamMemberCountAggregateOutputType | null
    _min: ProjectTeamMemberMinAggregateOutputType | null
    _max: ProjectTeamMemberMaxAggregateOutputType | null
  }

  export type ProjectTeamMemberMinAggregateOutputType = {
    id: string | null
    projectId: string | null
    teamMemberId: string | null
  }

  export type ProjectTeamMemberMaxAggregateOutputType = {
    id: string | null
    projectId: string | null
    teamMemberId: string | null
  }

  export type ProjectTeamMemberCountAggregateOutputType = {
    id: number
    projectId: number
    teamMemberId: number
    _all: number
  }


  export type ProjectTeamMemberMinAggregateInputType = {
    id?: true
    projectId?: true
    teamMemberId?: true
  }

  export type ProjectTeamMemberMaxAggregateInputType = {
    id?: true
    projectId?: true
    teamMemberId?: true
  }

  export type ProjectTeamMemberCountAggregateInputType = {
    id?: true
    projectId?: true
    teamMemberId?: true
    _all?: true
  }

  export type ProjectTeamMemberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectTeamMember to aggregate.
     */
    where?: ProjectTeamMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectTeamMembers to fetch.
     */
    orderBy?: ProjectTeamMemberOrderByWithRelationInput | ProjectTeamMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectTeamMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectTeamMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectTeamMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProjectTeamMembers
    **/
    _count?: true | ProjectTeamMemberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectTeamMemberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectTeamMemberMaxAggregateInputType
  }

  export type GetProjectTeamMemberAggregateType<T extends ProjectTeamMemberAggregateArgs> = {
        [P in keyof T & keyof AggregateProjectTeamMember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProjectTeamMember[P]>
      : GetScalarType<T[P], AggregateProjectTeamMember[P]>
  }




  export type ProjectTeamMemberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectTeamMemberWhereInput
    orderBy?: ProjectTeamMemberOrderByWithAggregationInput | ProjectTeamMemberOrderByWithAggregationInput[]
    by: ProjectTeamMemberScalarFieldEnum[] | ProjectTeamMemberScalarFieldEnum
    having?: ProjectTeamMemberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectTeamMemberCountAggregateInputType | true
    _min?: ProjectTeamMemberMinAggregateInputType
    _max?: ProjectTeamMemberMaxAggregateInputType
  }

  export type ProjectTeamMemberGroupByOutputType = {
    id: string
    projectId: string
    teamMemberId: string
    _count: ProjectTeamMemberCountAggregateOutputType | null
    _min: ProjectTeamMemberMinAggregateOutputType | null
    _max: ProjectTeamMemberMaxAggregateOutputType | null
  }

  type GetProjectTeamMemberGroupByPayload<T extends ProjectTeamMemberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectTeamMemberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectTeamMemberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectTeamMemberGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectTeamMemberGroupByOutputType[P]>
        }
      >
    >


  export type ProjectTeamMemberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    teamMemberId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    teamMember?: boolean | TeamMemberDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectTeamMember"]>

  export type ProjectTeamMemberSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    teamMemberId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    teamMember?: boolean | TeamMemberDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectTeamMember"]>

  export type ProjectTeamMemberSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    teamMemberId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    teamMember?: boolean | TeamMemberDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectTeamMember"]>

  export type ProjectTeamMemberSelectScalar = {
    id?: boolean
    projectId?: boolean
    teamMemberId?: boolean
  }

  export type ProjectTeamMemberOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "projectId" | "teamMemberId", ExtArgs["result"]["projectTeamMember"]>
  export type ProjectTeamMemberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    teamMember?: boolean | TeamMemberDefaultArgs<ExtArgs>
  }
  export type ProjectTeamMemberIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    teamMember?: boolean | TeamMemberDefaultArgs<ExtArgs>
  }
  export type ProjectTeamMemberIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    teamMember?: boolean | TeamMemberDefaultArgs<ExtArgs>
  }

  export type $ProjectTeamMemberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProjectTeamMember"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      teamMember: Prisma.$TeamMemberPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      projectId: string
      teamMemberId: string
    }, ExtArgs["result"]["projectTeamMember"]>
    composites: {}
  }

  type ProjectTeamMemberGetPayload<S extends boolean | null | undefined | ProjectTeamMemberDefaultArgs> = $Result.GetResult<Prisma.$ProjectTeamMemberPayload, S>

  type ProjectTeamMemberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProjectTeamMemberFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProjectTeamMemberCountAggregateInputType | true
    }

  export interface ProjectTeamMemberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProjectTeamMember'], meta: { name: 'ProjectTeamMember' } }
    /**
     * Find zero or one ProjectTeamMember that matches the filter.
     * @param {ProjectTeamMemberFindUniqueArgs} args - Arguments to find a ProjectTeamMember
     * @example
     * // Get one ProjectTeamMember
     * const projectTeamMember = await prisma.projectTeamMember.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectTeamMemberFindUniqueArgs>(args: SelectSubset<T, ProjectTeamMemberFindUniqueArgs<ExtArgs>>): Prisma__ProjectTeamMemberClient<$Result.GetResult<Prisma.$ProjectTeamMemberPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProjectTeamMember that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProjectTeamMemberFindUniqueOrThrowArgs} args - Arguments to find a ProjectTeamMember
     * @example
     * // Get one ProjectTeamMember
     * const projectTeamMember = await prisma.projectTeamMember.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectTeamMemberFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectTeamMemberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectTeamMemberClient<$Result.GetResult<Prisma.$ProjectTeamMemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProjectTeamMember that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectTeamMemberFindFirstArgs} args - Arguments to find a ProjectTeamMember
     * @example
     * // Get one ProjectTeamMember
     * const projectTeamMember = await prisma.projectTeamMember.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectTeamMemberFindFirstArgs>(args?: SelectSubset<T, ProjectTeamMemberFindFirstArgs<ExtArgs>>): Prisma__ProjectTeamMemberClient<$Result.GetResult<Prisma.$ProjectTeamMemberPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProjectTeamMember that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectTeamMemberFindFirstOrThrowArgs} args - Arguments to find a ProjectTeamMember
     * @example
     * // Get one ProjectTeamMember
     * const projectTeamMember = await prisma.projectTeamMember.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectTeamMemberFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectTeamMemberFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectTeamMemberClient<$Result.GetResult<Prisma.$ProjectTeamMemberPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProjectTeamMembers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectTeamMemberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProjectTeamMembers
     * const projectTeamMembers = await prisma.projectTeamMember.findMany()
     * 
     * // Get first 10 ProjectTeamMembers
     * const projectTeamMembers = await prisma.projectTeamMember.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectTeamMemberWithIdOnly = await prisma.projectTeamMember.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProjectTeamMemberFindManyArgs>(args?: SelectSubset<T, ProjectTeamMemberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectTeamMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProjectTeamMember.
     * @param {ProjectTeamMemberCreateArgs} args - Arguments to create a ProjectTeamMember.
     * @example
     * // Create one ProjectTeamMember
     * const ProjectTeamMember = await prisma.projectTeamMember.create({
     *   data: {
     *     // ... data to create a ProjectTeamMember
     *   }
     * })
     * 
     */
    create<T extends ProjectTeamMemberCreateArgs>(args: SelectSubset<T, ProjectTeamMemberCreateArgs<ExtArgs>>): Prisma__ProjectTeamMemberClient<$Result.GetResult<Prisma.$ProjectTeamMemberPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProjectTeamMembers.
     * @param {ProjectTeamMemberCreateManyArgs} args - Arguments to create many ProjectTeamMembers.
     * @example
     * // Create many ProjectTeamMembers
     * const projectTeamMember = await prisma.projectTeamMember.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectTeamMemberCreateManyArgs>(args?: SelectSubset<T, ProjectTeamMemberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProjectTeamMembers and returns the data saved in the database.
     * @param {ProjectTeamMemberCreateManyAndReturnArgs} args - Arguments to create many ProjectTeamMembers.
     * @example
     * // Create many ProjectTeamMembers
     * const projectTeamMember = await prisma.projectTeamMember.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProjectTeamMembers and only return the `id`
     * const projectTeamMemberWithIdOnly = await prisma.projectTeamMember.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProjectTeamMemberCreateManyAndReturnArgs>(args?: SelectSubset<T, ProjectTeamMemberCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectTeamMemberPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProjectTeamMember.
     * @param {ProjectTeamMemberDeleteArgs} args - Arguments to delete one ProjectTeamMember.
     * @example
     * // Delete one ProjectTeamMember
     * const ProjectTeamMember = await prisma.projectTeamMember.delete({
     *   where: {
     *     // ... filter to delete one ProjectTeamMember
     *   }
     * })
     * 
     */
    delete<T extends ProjectTeamMemberDeleteArgs>(args: SelectSubset<T, ProjectTeamMemberDeleteArgs<ExtArgs>>): Prisma__ProjectTeamMemberClient<$Result.GetResult<Prisma.$ProjectTeamMemberPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProjectTeamMember.
     * @param {ProjectTeamMemberUpdateArgs} args - Arguments to update one ProjectTeamMember.
     * @example
     * // Update one ProjectTeamMember
     * const projectTeamMember = await prisma.projectTeamMember.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectTeamMemberUpdateArgs>(args: SelectSubset<T, ProjectTeamMemberUpdateArgs<ExtArgs>>): Prisma__ProjectTeamMemberClient<$Result.GetResult<Prisma.$ProjectTeamMemberPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProjectTeamMembers.
     * @param {ProjectTeamMemberDeleteManyArgs} args - Arguments to filter ProjectTeamMembers to delete.
     * @example
     * // Delete a few ProjectTeamMembers
     * const { count } = await prisma.projectTeamMember.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectTeamMemberDeleteManyArgs>(args?: SelectSubset<T, ProjectTeamMemberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectTeamMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectTeamMemberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProjectTeamMembers
     * const projectTeamMember = await prisma.projectTeamMember.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectTeamMemberUpdateManyArgs>(args: SelectSubset<T, ProjectTeamMemberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectTeamMembers and returns the data updated in the database.
     * @param {ProjectTeamMemberUpdateManyAndReturnArgs} args - Arguments to update many ProjectTeamMembers.
     * @example
     * // Update many ProjectTeamMembers
     * const projectTeamMember = await prisma.projectTeamMember.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProjectTeamMembers and only return the `id`
     * const projectTeamMemberWithIdOnly = await prisma.projectTeamMember.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProjectTeamMemberUpdateManyAndReturnArgs>(args: SelectSubset<T, ProjectTeamMemberUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectTeamMemberPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProjectTeamMember.
     * @param {ProjectTeamMemberUpsertArgs} args - Arguments to update or create a ProjectTeamMember.
     * @example
     * // Update or create a ProjectTeamMember
     * const projectTeamMember = await prisma.projectTeamMember.upsert({
     *   create: {
     *     // ... data to create a ProjectTeamMember
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProjectTeamMember we want to update
     *   }
     * })
     */
    upsert<T extends ProjectTeamMemberUpsertArgs>(args: SelectSubset<T, ProjectTeamMemberUpsertArgs<ExtArgs>>): Prisma__ProjectTeamMemberClient<$Result.GetResult<Prisma.$ProjectTeamMemberPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProjectTeamMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectTeamMemberCountArgs} args - Arguments to filter ProjectTeamMembers to count.
     * @example
     * // Count the number of ProjectTeamMembers
     * const count = await prisma.projectTeamMember.count({
     *   where: {
     *     // ... the filter for the ProjectTeamMembers we want to count
     *   }
     * })
    **/
    count<T extends ProjectTeamMemberCountArgs>(
      args?: Subset<T, ProjectTeamMemberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectTeamMemberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProjectTeamMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectTeamMemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectTeamMemberAggregateArgs>(args: Subset<T, ProjectTeamMemberAggregateArgs>): Prisma.PrismaPromise<GetProjectTeamMemberAggregateType<T>>

    /**
     * Group by ProjectTeamMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectTeamMemberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectTeamMemberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectTeamMemberGroupByArgs['orderBy'] }
        : { orderBy?: ProjectTeamMemberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectTeamMemberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectTeamMemberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProjectTeamMember model
   */
  readonly fields: ProjectTeamMemberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProjectTeamMember.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectTeamMemberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    teamMember<T extends TeamMemberDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeamMemberDefaultArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProjectTeamMember model
   */
  interface ProjectTeamMemberFieldRefs {
    readonly id: FieldRef<"ProjectTeamMember", 'String'>
    readonly projectId: FieldRef<"ProjectTeamMember", 'String'>
    readonly teamMemberId: FieldRef<"ProjectTeamMember", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ProjectTeamMember findUnique
   */
  export type ProjectTeamMemberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectTeamMember
     */
    select?: ProjectTeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectTeamMember
     */
    omit?: ProjectTeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectTeamMemberInclude<ExtArgs> | null
    /**
     * Filter, which ProjectTeamMember to fetch.
     */
    where: ProjectTeamMemberWhereUniqueInput
  }

  /**
   * ProjectTeamMember findUniqueOrThrow
   */
  export type ProjectTeamMemberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectTeamMember
     */
    select?: ProjectTeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectTeamMember
     */
    omit?: ProjectTeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectTeamMemberInclude<ExtArgs> | null
    /**
     * Filter, which ProjectTeamMember to fetch.
     */
    where: ProjectTeamMemberWhereUniqueInput
  }

  /**
   * ProjectTeamMember findFirst
   */
  export type ProjectTeamMemberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectTeamMember
     */
    select?: ProjectTeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectTeamMember
     */
    omit?: ProjectTeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectTeamMemberInclude<ExtArgs> | null
    /**
     * Filter, which ProjectTeamMember to fetch.
     */
    where?: ProjectTeamMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectTeamMembers to fetch.
     */
    orderBy?: ProjectTeamMemberOrderByWithRelationInput | ProjectTeamMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectTeamMembers.
     */
    cursor?: ProjectTeamMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectTeamMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectTeamMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectTeamMembers.
     */
    distinct?: ProjectTeamMemberScalarFieldEnum | ProjectTeamMemberScalarFieldEnum[]
  }

  /**
   * ProjectTeamMember findFirstOrThrow
   */
  export type ProjectTeamMemberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectTeamMember
     */
    select?: ProjectTeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectTeamMember
     */
    omit?: ProjectTeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectTeamMemberInclude<ExtArgs> | null
    /**
     * Filter, which ProjectTeamMember to fetch.
     */
    where?: ProjectTeamMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectTeamMembers to fetch.
     */
    orderBy?: ProjectTeamMemberOrderByWithRelationInput | ProjectTeamMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectTeamMembers.
     */
    cursor?: ProjectTeamMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectTeamMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectTeamMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectTeamMembers.
     */
    distinct?: ProjectTeamMemberScalarFieldEnum | ProjectTeamMemberScalarFieldEnum[]
  }

  /**
   * ProjectTeamMember findMany
   */
  export type ProjectTeamMemberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectTeamMember
     */
    select?: ProjectTeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectTeamMember
     */
    omit?: ProjectTeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectTeamMemberInclude<ExtArgs> | null
    /**
     * Filter, which ProjectTeamMembers to fetch.
     */
    where?: ProjectTeamMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectTeamMembers to fetch.
     */
    orderBy?: ProjectTeamMemberOrderByWithRelationInput | ProjectTeamMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProjectTeamMembers.
     */
    cursor?: ProjectTeamMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectTeamMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectTeamMembers.
     */
    skip?: number
    distinct?: ProjectTeamMemberScalarFieldEnum | ProjectTeamMemberScalarFieldEnum[]
  }

  /**
   * ProjectTeamMember create
   */
  export type ProjectTeamMemberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectTeamMember
     */
    select?: ProjectTeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectTeamMember
     */
    omit?: ProjectTeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectTeamMemberInclude<ExtArgs> | null
    /**
     * The data needed to create a ProjectTeamMember.
     */
    data: XOR<ProjectTeamMemberCreateInput, ProjectTeamMemberUncheckedCreateInput>
  }

  /**
   * ProjectTeamMember createMany
   */
  export type ProjectTeamMemberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProjectTeamMembers.
     */
    data: ProjectTeamMemberCreateManyInput | ProjectTeamMemberCreateManyInput[]
  }

  /**
   * ProjectTeamMember createManyAndReturn
   */
  export type ProjectTeamMemberCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectTeamMember
     */
    select?: ProjectTeamMemberSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectTeamMember
     */
    omit?: ProjectTeamMemberOmit<ExtArgs> | null
    /**
     * The data used to create many ProjectTeamMembers.
     */
    data: ProjectTeamMemberCreateManyInput | ProjectTeamMemberCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectTeamMemberIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProjectTeamMember update
   */
  export type ProjectTeamMemberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectTeamMember
     */
    select?: ProjectTeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectTeamMember
     */
    omit?: ProjectTeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectTeamMemberInclude<ExtArgs> | null
    /**
     * The data needed to update a ProjectTeamMember.
     */
    data: XOR<ProjectTeamMemberUpdateInput, ProjectTeamMemberUncheckedUpdateInput>
    /**
     * Choose, which ProjectTeamMember to update.
     */
    where: ProjectTeamMemberWhereUniqueInput
  }

  /**
   * ProjectTeamMember updateMany
   */
  export type ProjectTeamMemberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProjectTeamMembers.
     */
    data: XOR<ProjectTeamMemberUpdateManyMutationInput, ProjectTeamMemberUncheckedUpdateManyInput>
    /**
     * Filter which ProjectTeamMembers to update
     */
    where?: ProjectTeamMemberWhereInput
    /**
     * Limit how many ProjectTeamMembers to update.
     */
    limit?: number
  }

  /**
   * ProjectTeamMember updateManyAndReturn
   */
  export type ProjectTeamMemberUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectTeamMember
     */
    select?: ProjectTeamMemberSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectTeamMember
     */
    omit?: ProjectTeamMemberOmit<ExtArgs> | null
    /**
     * The data used to update ProjectTeamMembers.
     */
    data: XOR<ProjectTeamMemberUpdateManyMutationInput, ProjectTeamMemberUncheckedUpdateManyInput>
    /**
     * Filter which ProjectTeamMembers to update
     */
    where?: ProjectTeamMemberWhereInput
    /**
     * Limit how many ProjectTeamMembers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectTeamMemberIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProjectTeamMember upsert
   */
  export type ProjectTeamMemberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectTeamMember
     */
    select?: ProjectTeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectTeamMember
     */
    omit?: ProjectTeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectTeamMemberInclude<ExtArgs> | null
    /**
     * The filter to search for the ProjectTeamMember to update in case it exists.
     */
    where: ProjectTeamMemberWhereUniqueInput
    /**
     * In case the ProjectTeamMember found by the `where` argument doesn't exist, create a new ProjectTeamMember with this data.
     */
    create: XOR<ProjectTeamMemberCreateInput, ProjectTeamMemberUncheckedCreateInput>
    /**
     * In case the ProjectTeamMember was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectTeamMemberUpdateInput, ProjectTeamMemberUncheckedUpdateInput>
  }

  /**
   * ProjectTeamMember delete
   */
  export type ProjectTeamMemberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectTeamMember
     */
    select?: ProjectTeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectTeamMember
     */
    omit?: ProjectTeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectTeamMemberInclude<ExtArgs> | null
    /**
     * Filter which ProjectTeamMember to delete.
     */
    where: ProjectTeamMemberWhereUniqueInput
  }

  /**
   * ProjectTeamMember deleteMany
   */
  export type ProjectTeamMemberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectTeamMembers to delete
     */
    where?: ProjectTeamMemberWhereInput
    /**
     * Limit how many ProjectTeamMembers to delete.
     */
    limit?: number
  }

  /**
   * ProjectTeamMember without action
   */
  export type ProjectTeamMemberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectTeamMember
     */
    select?: ProjectTeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectTeamMember
     */
    omit?: ProjectTeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectTeamMemberInclude<ExtArgs> | null
  }


  /**
   * Model TeamMember
   */

  export type AggregateTeamMember = {
    _count: TeamMemberCountAggregateOutputType | null
    _min: TeamMemberMinAggregateOutputType | null
    _max: TeamMemberMaxAggregateOutputType | null
  }

  export type TeamMemberMinAggregateOutputType = {
    id: string | null
    name: string | null
    role: string | null
    email: string | null
    phone: string | null
  }

  export type TeamMemberMaxAggregateOutputType = {
    id: string | null
    name: string | null
    role: string | null
    email: string | null
    phone: string | null
  }

  export type TeamMemberCountAggregateOutputType = {
    id: number
    name: number
    role: number
    email: number
    phone: number
    _all: number
  }


  export type TeamMemberMinAggregateInputType = {
    id?: true
    name?: true
    role?: true
    email?: true
    phone?: true
  }

  export type TeamMemberMaxAggregateInputType = {
    id?: true
    name?: true
    role?: true
    email?: true
    phone?: true
  }

  export type TeamMemberCountAggregateInputType = {
    id?: true
    name?: true
    role?: true
    email?: true
    phone?: true
    _all?: true
  }

  export type TeamMemberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TeamMember to aggregate.
     */
    where?: TeamMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamMembers to fetch.
     */
    orderBy?: TeamMemberOrderByWithRelationInput | TeamMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TeamMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TeamMembers
    **/
    _count?: true | TeamMemberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeamMemberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeamMemberMaxAggregateInputType
  }

  export type GetTeamMemberAggregateType<T extends TeamMemberAggregateArgs> = {
        [P in keyof T & keyof AggregateTeamMember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeamMember[P]>
      : GetScalarType<T[P], AggregateTeamMember[P]>
  }




  export type TeamMemberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamMemberWhereInput
    orderBy?: TeamMemberOrderByWithAggregationInput | TeamMemberOrderByWithAggregationInput[]
    by: TeamMemberScalarFieldEnum[] | TeamMemberScalarFieldEnum
    having?: TeamMemberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeamMemberCountAggregateInputType | true
    _min?: TeamMemberMinAggregateInputType
    _max?: TeamMemberMaxAggregateInputType
  }

  export type TeamMemberGroupByOutputType = {
    id: string
    name: string
    role: string
    email: string
    phone: string
    _count: TeamMemberCountAggregateOutputType | null
    _min: TeamMemberMinAggregateOutputType | null
    _max: TeamMemberMaxAggregateOutputType | null
  }

  type GetTeamMemberGroupByPayload<T extends TeamMemberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TeamMemberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeamMemberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeamMemberGroupByOutputType[P]>
            : GetScalarType<T[P], TeamMemberGroupByOutputType[P]>
        }
      >
    >


  export type TeamMemberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    role?: boolean
    email?: boolean
    phone?: boolean
    projects?: boolean | TeamMember$projectsArgs<ExtArgs>
    _count?: boolean | TeamMemberCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teamMember"]>

  export type TeamMemberSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    role?: boolean
    email?: boolean
    phone?: boolean
  }, ExtArgs["result"]["teamMember"]>

  export type TeamMemberSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    role?: boolean
    email?: boolean
    phone?: boolean
  }, ExtArgs["result"]["teamMember"]>

  export type TeamMemberSelectScalar = {
    id?: boolean
    name?: boolean
    role?: boolean
    email?: boolean
    phone?: boolean
  }

  export type TeamMemberOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "role" | "email" | "phone", ExtArgs["result"]["teamMember"]>
  export type TeamMemberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projects?: boolean | TeamMember$projectsArgs<ExtArgs>
    _count?: boolean | TeamMemberCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TeamMemberIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type TeamMemberIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TeamMemberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TeamMember"
    objects: {
      projects: Prisma.$ProjectTeamMemberPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      role: string
      email: string
      phone: string
    }, ExtArgs["result"]["teamMember"]>
    composites: {}
  }

  type TeamMemberGetPayload<S extends boolean | null | undefined | TeamMemberDefaultArgs> = $Result.GetResult<Prisma.$TeamMemberPayload, S>

  type TeamMemberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TeamMemberFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TeamMemberCountAggregateInputType | true
    }

  export interface TeamMemberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TeamMember'], meta: { name: 'TeamMember' } }
    /**
     * Find zero or one TeamMember that matches the filter.
     * @param {TeamMemberFindUniqueArgs} args - Arguments to find a TeamMember
     * @example
     * // Get one TeamMember
     * const teamMember = await prisma.teamMember.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TeamMemberFindUniqueArgs>(args: SelectSubset<T, TeamMemberFindUniqueArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TeamMember that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TeamMemberFindUniqueOrThrowArgs} args - Arguments to find a TeamMember
     * @example
     * // Get one TeamMember
     * const teamMember = await prisma.teamMember.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TeamMemberFindUniqueOrThrowArgs>(args: SelectSubset<T, TeamMemberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TeamMember that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberFindFirstArgs} args - Arguments to find a TeamMember
     * @example
     * // Get one TeamMember
     * const teamMember = await prisma.teamMember.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TeamMemberFindFirstArgs>(args?: SelectSubset<T, TeamMemberFindFirstArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TeamMember that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberFindFirstOrThrowArgs} args - Arguments to find a TeamMember
     * @example
     * // Get one TeamMember
     * const teamMember = await prisma.teamMember.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TeamMemberFindFirstOrThrowArgs>(args?: SelectSubset<T, TeamMemberFindFirstOrThrowArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TeamMembers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TeamMembers
     * const teamMembers = await prisma.teamMember.findMany()
     * 
     * // Get first 10 TeamMembers
     * const teamMembers = await prisma.teamMember.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const teamMemberWithIdOnly = await prisma.teamMember.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TeamMemberFindManyArgs>(args?: SelectSubset<T, TeamMemberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TeamMember.
     * @param {TeamMemberCreateArgs} args - Arguments to create a TeamMember.
     * @example
     * // Create one TeamMember
     * const TeamMember = await prisma.teamMember.create({
     *   data: {
     *     // ... data to create a TeamMember
     *   }
     * })
     * 
     */
    create<T extends TeamMemberCreateArgs>(args: SelectSubset<T, TeamMemberCreateArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TeamMembers.
     * @param {TeamMemberCreateManyArgs} args - Arguments to create many TeamMembers.
     * @example
     * // Create many TeamMembers
     * const teamMember = await prisma.teamMember.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TeamMemberCreateManyArgs>(args?: SelectSubset<T, TeamMemberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TeamMembers and returns the data saved in the database.
     * @param {TeamMemberCreateManyAndReturnArgs} args - Arguments to create many TeamMembers.
     * @example
     * // Create many TeamMembers
     * const teamMember = await prisma.teamMember.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TeamMembers and only return the `id`
     * const teamMemberWithIdOnly = await prisma.teamMember.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TeamMemberCreateManyAndReturnArgs>(args?: SelectSubset<T, TeamMemberCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TeamMember.
     * @param {TeamMemberDeleteArgs} args - Arguments to delete one TeamMember.
     * @example
     * // Delete one TeamMember
     * const TeamMember = await prisma.teamMember.delete({
     *   where: {
     *     // ... filter to delete one TeamMember
     *   }
     * })
     * 
     */
    delete<T extends TeamMemberDeleteArgs>(args: SelectSubset<T, TeamMemberDeleteArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TeamMember.
     * @param {TeamMemberUpdateArgs} args - Arguments to update one TeamMember.
     * @example
     * // Update one TeamMember
     * const teamMember = await prisma.teamMember.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TeamMemberUpdateArgs>(args: SelectSubset<T, TeamMemberUpdateArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TeamMembers.
     * @param {TeamMemberDeleteManyArgs} args - Arguments to filter TeamMembers to delete.
     * @example
     * // Delete a few TeamMembers
     * const { count } = await prisma.teamMember.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TeamMemberDeleteManyArgs>(args?: SelectSubset<T, TeamMemberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TeamMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TeamMembers
     * const teamMember = await prisma.teamMember.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TeamMemberUpdateManyArgs>(args: SelectSubset<T, TeamMemberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TeamMembers and returns the data updated in the database.
     * @param {TeamMemberUpdateManyAndReturnArgs} args - Arguments to update many TeamMembers.
     * @example
     * // Update many TeamMembers
     * const teamMember = await prisma.teamMember.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TeamMembers and only return the `id`
     * const teamMemberWithIdOnly = await prisma.teamMember.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TeamMemberUpdateManyAndReturnArgs>(args: SelectSubset<T, TeamMemberUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TeamMember.
     * @param {TeamMemberUpsertArgs} args - Arguments to update or create a TeamMember.
     * @example
     * // Update or create a TeamMember
     * const teamMember = await prisma.teamMember.upsert({
     *   create: {
     *     // ... data to create a TeamMember
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TeamMember we want to update
     *   }
     * })
     */
    upsert<T extends TeamMemberUpsertArgs>(args: SelectSubset<T, TeamMemberUpsertArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TeamMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberCountArgs} args - Arguments to filter TeamMembers to count.
     * @example
     * // Count the number of TeamMembers
     * const count = await prisma.teamMember.count({
     *   where: {
     *     // ... the filter for the TeamMembers we want to count
     *   }
     * })
    **/
    count<T extends TeamMemberCountArgs>(
      args?: Subset<T, TeamMemberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeamMemberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TeamMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeamMemberAggregateArgs>(args: Subset<T, TeamMemberAggregateArgs>): Prisma.PrismaPromise<GetTeamMemberAggregateType<T>>

    /**
     * Group by TeamMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TeamMemberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeamMemberGroupByArgs['orderBy'] }
        : { orderBy?: TeamMemberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TeamMemberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeamMemberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TeamMember model
   */
  readonly fields: TeamMemberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TeamMember.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TeamMemberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    projects<T extends TeamMember$projectsArgs<ExtArgs> = {}>(args?: Subset<T, TeamMember$projectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectTeamMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TeamMember model
   */
  interface TeamMemberFieldRefs {
    readonly id: FieldRef<"TeamMember", 'String'>
    readonly name: FieldRef<"TeamMember", 'String'>
    readonly role: FieldRef<"TeamMember", 'String'>
    readonly email: FieldRef<"TeamMember", 'String'>
    readonly phone: FieldRef<"TeamMember", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TeamMember findUnique
   */
  export type TeamMemberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * Filter, which TeamMember to fetch.
     */
    where: TeamMemberWhereUniqueInput
  }

  /**
   * TeamMember findUniqueOrThrow
   */
  export type TeamMemberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * Filter, which TeamMember to fetch.
     */
    where: TeamMemberWhereUniqueInput
  }

  /**
   * TeamMember findFirst
   */
  export type TeamMemberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * Filter, which TeamMember to fetch.
     */
    where?: TeamMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamMembers to fetch.
     */
    orderBy?: TeamMemberOrderByWithRelationInput | TeamMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeamMembers.
     */
    cursor?: TeamMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeamMembers.
     */
    distinct?: TeamMemberScalarFieldEnum | TeamMemberScalarFieldEnum[]
  }

  /**
   * TeamMember findFirstOrThrow
   */
  export type TeamMemberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * Filter, which TeamMember to fetch.
     */
    where?: TeamMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamMembers to fetch.
     */
    orderBy?: TeamMemberOrderByWithRelationInput | TeamMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeamMembers.
     */
    cursor?: TeamMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeamMembers.
     */
    distinct?: TeamMemberScalarFieldEnum | TeamMemberScalarFieldEnum[]
  }

  /**
   * TeamMember findMany
   */
  export type TeamMemberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * Filter, which TeamMembers to fetch.
     */
    where?: TeamMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamMembers to fetch.
     */
    orderBy?: TeamMemberOrderByWithRelationInput | TeamMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TeamMembers.
     */
    cursor?: TeamMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamMembers.
     */
    skip?: number
    distinct?: TeamMemberScalarFieldEnum | TeamMemberScalarFieldEnum[]
  }

  /**
   * TeamMember create
   */
  export type TeamMemberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * The data needed to create a TeamMember.
     */
    data: XOR<TeamMemberCreateInput, TeamMemberUncheckedCreateInput>
  }

  /**
   * TeamMember createMany
   */
  export type TeamMemberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TeamMembers.
     */
    data: TeamMemberCreateManyInput | TeamMemberCreateManyInput[]
  }

  /**
   * TeamMember createManyAndReturn
   */
  export type TeamMemberCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * The data used to create many TeamMembers.
     */
    data: TeamMemberCreateManyInput | TeamMemberCreateManyInput[]
  }

  /**
   * TeamMember update
   */
  export type TeamMemberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * The data needed to update a TeamMember.
     */
    data: XOR<TeamMemberUpdateInput, TeamMemberUncheckedUpdateInput>
    /**
     * Choose, which TeamMember to update.
     */
    where: TeamMemberWhereUniqueInput
  }

  /**
   * TeamMember updateMany
   */
  export type TeamMemberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TeamMembers.
     */
    data: XOR<TeamMemberUpdateManyMutationInput, TeamMemberUncheckedUpdateManyInput>
    /**
     * Filter which TeamMembers to update
     */
    where?: TeamMemberWhereInput
    /**
     * Limit how many TeamMembers to update.
     */
    limit?: number
  }

  /**
   * TeamMember updateManyAndReturn
   */
  export type TeamMemberUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * The data used to update TeamMembers.
     */
    data: XOR<TeamMemberUpdateManyMutationInput, TeamMemberUncheckedUpdateManyInput>
    /**
     * Filter which TeamMembers to update
     */
    where?: TeamMemberWhereInput
    /**
     * Limit how many TeamMembers to update.
     */
    limit?: number
  }

  /**
   * TeamMember upsert
   */
  export type TeamMemberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * The filter to search for the TeamMember to update in case it exists.
     */
    where: TeamMemberWhereUniqueInput
    /**
     * In case the TeamMember found by the `where` argument doesn't exist, create a new TeamMember with this data.
     */
    create: XOR<TeamMemberCreateInput, TeamMemberUncheckedCreateInput>
    /**
     * In case the TeamMember was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TeamMemberUpdateInput, TeamMemberUncheckedUpdateInput>
  }

  /**
   * TeamMember delete
   */
  export type TeamMemberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * Filter which TeamMember to delete.
     */
    where: TeamMemberWhereUniqueInput
  }

  /**
   * TeamMember deleteMany
   */
  export type TeamMemberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TeamMembers to delete
     */
    where?: TeamMemberWhereInput
    /**
     * Limit how many TeamMembers to delete.
     */
    limit?: number
  }

  /**
   * TeamMember.projects
   */
  export type TeamMember$projectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectTeamMember
     */
    select?: ProjectTeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectTeamMember
     */
    omit?: ProjectTeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectTeamMemberInclude<ExtArgs> | null
    where?: ProjectTeamMemberWhereInput
    orderBy?: ProjectTeamMemberOrderByWithRelationInput | ProjectTeamMemberOrderByWithRelationInput[]
    cursor?: ProjectTeamMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectTeamMemberScalarFieldEnum | ProjectTeamMemberScalarFieldEnum[]
  }

  /**
   * TeamMember without action
   */
  export type TeamMemberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
  }


  /**
   * Model Milestone
   */

  export type AggregateMilestone = {
    _count: MilestoneCountAggregateOutputType | null
    _min: MilestoneMinAggregateOutputType | null
    _max: MilestoneMaxAggregateOutputType | null
  }

  export type MilestoneMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    status: string | null
    dueDate: Date | null
    completedDate: Date | null
    assignedTo: string | null
    projectId: string | null
  }

  export type MilestoneMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    status: string | null
    dueDate: Date | null
    completedDate: Date | null
    assignedTo: string | null
    projectId: string | null
  }

  export type MilestoneCountAggregateOutputType = {
    id: number
    name: number
    description: number
    status: number
    dueDate: number
    completedDate: number
    assignedTo: number
    projectId: number
    _all: number
  }


  export type MilestoneMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    status?: true
    dueDate?: true
    completedDate?: true
    assignedTo?: true
    projectId?: true
  }

  export type MilestoneMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    status?: true
    dueDate?: true
    completedDate?: true
    assignedTo?: true
    projectId?: true
  }

  export type MilestoneCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    status?: true
    dueDate?: true
    completedDate?: true
    assignedTo?: true
    projectId?: true
    _all?: true
  }

  export type MilestoneAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Milestone to aggregate.
     */
    where?: MilestoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Milestones to fetch.
     */
    orderBy?: MilestoneOrderByWithRelationInput | MilestoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MilestoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Milestones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Milestones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Milestones
    **/
    _count?: true | MilestoneCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MilestoneMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MilestoneMaxAggregateInputType
  }

  export type GetMilestoneAggregateType<T extends MilestoneAggregateArgs> = {
        [P in keyof T & keyof AggregateMilestone]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMilestone[P]>
      : GetScalarType<T[P], AggregateMilestone[P]>
  }




  export type MilestoneGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MilestoneWhereInput
    orderBy?: MilestoneOrderByWithAggregationInput | MilestoneOrderByWithAggregationInput[]
    by: MilestoneScalarFieldEnum[] | MilestoneScalarFieldEnum
    having?: MilestoneScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MilestoneCountAggregateInputType | true
    _min?: MilestoneMinAggregateInputType
    _max?: MilestoneMaxAggregateInputType
  }

  export type MilestoneGroupByOutputType = {
    id: string
    name: string
    description: string
    status: string
    dueDate: Date
    completedDate: Date | null
    assignedTo: string | null
    projectId: string
    _count: MilestoneCountAggregateOutputType | null
    _min: MilestoneMinAggregateOutputType | null
    _max: MilestoneMaxAggregateOutputType | null
  }

  type GetMilestoneGroupByPayload<T extends MilestoneGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MilestoneGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MilestoneGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MilestoneGroupByOutputType[P]>
            : GetScalarType<T[P], MilestoneGroupByOutputType[P]>
        }
      >
    >


  export type MilestoneSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    dueDate?: boolean
    completedDate?: boolean
    assignedTo?: boolean
    projectId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["milestone"]>

  export type MilestoneSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    dueDate?: boolean
    completedDate?: boolean
    assignedTo?: boolean
    projectId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["milestone"]>

  export type MilestoneSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    dueDate?: boolean
    completedDate?: boolean
    assignedTo?: boolean
    projectId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["milestone"]>

  export type MilestoneSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    dueDate?: boolean
    completedDate?: boolean
    assignedTo?: boolean
    projectId?: boolean
  }

  export type MilestoneOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "status" | "dueDate" | "completedDate" | "assignedTo" | "projectId", ExtArgs["result"]["milestone"]>
  export type MilestoneInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type MilestoneIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type MilestoneIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $MilestonePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Milestone"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string
      status: string
      dueDate: Date
      completedDate: Date | null
      assignedTo: string | null
      projectId: string
    }, ExtArgs["result"]["milestone"]>
    composites: {}
  }

  type MilestoneGetPayload<S extends boolean | null | undefined | MilestoneDefaultArgs> = $Result.GetResult<Prisma.$MilestonePayload, S>

  type MilestoneCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MilestoneFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MilestoneCountAggregateInputType | true
    }

  export interface MilestoneDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Milestone'], meta: { name: 'Milestone' } }
    /**
     * Find zero or one Milestone that matches the filter.
     * @param {MilestoneFindUniqueArgs} args - Arguments to find a Milestone
     * @example
     * // Get one Milestone
     * const milestone = await prisma.milestone.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MilestoneFindUniqueArgs>(args: SelectSubset<T, MilestoneFindUniqueArgs<ExtArgs>>): Prisma__MilestoneClient<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Milestone that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MilestoneFindUniqueOrThrowArgs} args - Arguments to find a Milestone
     * @example
     * // Get one Milestone
     * const milestone = await prisma.milestone.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MilestoneFindUniqueOrThrowArgs>(args: SelectSubset<T, MilestoneFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MilestoneClient<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Milestone that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MilestoneFindFirstArgs} args - Arguments to find a Milestone
     * @example
     * // Get one Milestone
     * const milestone = await prisma.milestone.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MilestoneFindFirstArgs>(args?: SelectSubset<T, MilestoneFindFirstArgs<ExtArgs>>): Prisma__MilestoneClient<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Milestone that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MilestoneFindFirstOrThrowArgs} args - Arguments to find a Milestone
     * @example
     * // Get one Milestone
     * const milestone = await prisma.milestone.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MilestoneFindFirstOrThrowArgs>(args?: SelectSubset<T, MilestoneFindFirstOrThrowArgs<ExtArgs>>): Prisma__MilestoneClient<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Milestones that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MilestoneFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Milestones
     * const milestones = await prisma.milestone.findMany()
     * 
     * // Get first 10 Milestones
     * const milestones = await prisma.milestone.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const milestoneWithIdOnly = await prisma.milestone.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MilestoneFindManyArgs>(args?: SelectSubset<T, MilestoneFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Milestone.
     * @param {MilestoneCreateArgs} args - Arguments to create a Milestone.
     * @example
     * // Create one Milestone
     * const Milestone = await prisma.milestone.create({
     *   data: {
     *     // ... data to create a Milestone
     *   }
     * })
     * 
     */
    create<T extends MilestoneCreateArgs>(args: SelectSubset<T, MilestoneCreateArgs<ExtArgs>>): Prisma__MilestoneClient<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Milestones.
     * @param {MilestoneCreateManyArgs} args - Arguments to create many Milestones.
     * @example
     * // Create many Milestones
     * const milestone = await prisma.milestone.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MilestoneCreateManyArgs>(args?: SelectSubset<T, MilestoneCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Milestones and returns the data saved in the database.
     * @param {MilestoneCreateManyAndReturnArgs} args - Arguments to create many Milestones.
     * @example
     * // Create many Milestones
     * const milestone = await prisma.milestone.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Milestones and only return the `id`
     * const milestoneWithIdOnly = await prisma.milestone.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MilestoneCreateManyAndReturnArgs>(args?: SelectSubset<T, MilestoneCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Milestone.
     * @param {MilestoneDeleteArgs} args - Arguments to delete one Milestone.
     * @example
     * // Delete one Milestone
     * const Milestone = await prisma.milestone.delete({
     *   where: {
     *     // ... filter to delete one Milestone
     *   }
     * })
     * 
     */
    delete<T extends MilestoneDeleteArgs>(args: SelectSubset<T, MilestoneDeleteArgs<ExtArgs>>): Prisma__MilestoneClient<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Milestone.
     * @param {MilestoneUpdateArgs} args - Arguments to update one Milestone.
     * @example
     * // Update one Milestone
     * const milestone = await prisma.milestone.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MilestoneUpdateArgs>(args: SelectSubset<T, MilestoneUpdateArgs<ExtArgs>>): Prisma__MilestoneClient<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Milestones.
     * @param {MilestoneDeleteManyArgs} args - Arguments to filter Milestones to delete.
     * @example
     * // Delete a few Milestones
     * const { count } = await prisma.milestone.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MilestoneDeleteManyArgs>(args?: SelectSubset<T, MilestoneDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Milestones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MilestoneUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Milestones
     * const milestone = await prisma.milestone.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MilestoneUpdateManyArgs>(args: SelectSubset<T, MilestoneUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Milestones and returns the data updated in the database.
     * @param {MilestoneUpdateManyAndReturnArgs} args - Arguments to update many Milestones.
     * @example
     * // Update many Milestones
     * const milestone = await prisma.milestone.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Milestones and only return the `id`
     * const milestoneWithIdOnly = await prisma.milestone.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MilestoneUpdateManyAndReturnArgs>(args: SelectSubset<T, MilestoneUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Milestone.
     * @param {MilestoneUpsertArgs} args - Arguments to update or create a Milestone.
     * @example
     * // Update or create a Milestone
     * const milestone = await prisma.milestone.upsert({
     *   create: {
     *     // ... data to create a Milestone
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Milestone we want to update
     *   }
     * })
     */
    upsert<T extends MilestoneUpsertArgs>(args: SelectSubset<T, MilestoneUpsertArgs<ExtArgs>>): Prisma__MilestoneClient<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Milestones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MilestoneCountArgs} args - Arguments to filter Milestones to count.
     * @example
     * // Count the number of Milestones
     * const count = await prisma.milestone.count({
     *   where: {
     *     // ... the filter for the Milestones we want to count
     *   }
     * })
    **/
    count<T extends MilestoneCountArgs>(
      args?: Subset<T, MilestoneCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MilestoneCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Milestone.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MilestoneAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MilestoneAggregateArgs>(args: Subset<T, MilestoneAggregateArgs>): Prisma.PrismaPromise<GetMilestoneAggregateType<T>>

    /**
     * Group by Milestone.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MilestoneGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MilestoneGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MilestoneGroupByArgs['orderBy'] }
        : { orderBy?: MilestoneGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MilestoneGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMilestoneGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Milestone model
   */
  readonly fields: MilestoneFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Milestone.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MilestoneClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Milestone model
   */
  interface MilestoneFieldRefs {
    readonly id: FieldRef<"Milestone", 'String'>
    readonly name: FieldRef<"Milestone", 'String'>
    readonly description: FieldRef<"Milestone", 'String'>
    readonly status: FieldRef<"Milestone", 'String'>
    readonly dueDate: FieldRef<"Milestone", 'DateTime'>
    readonly completedDate: FieldRef<"Milestone", 'DateTime'>
    readonly assignedTo: FieldRef<"Milestone", 'String'>
    readonly projectId: FieldRef<"Milestone", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Milestone findUnique
   */
  export type MilestoneFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Milestone
     */
    omit?: MilestoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilestoneInclude<ExtArgs> | null
    /**
     * Filter, which Milestone to fetch.
     */
    where: MilestoneWhereUniqueInput
  }

  /**
   * Milestone findUniqueOrThrow
   */
  export type MilestoneFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Milestone
     */
    omit?: MilestoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilestoneInclude<ExtArgs> | null
    /**
     * Filter, which Milestone to fetch.
     */
    where: MilestoneWhereUniqueInput
  }

  /**
   * Milestone findFirst
   */
  export type MilestoneFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Milestone
     */
    omit?: MilestoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilestoneInclude<ExtArgs> | null
    /**
     * Filter, which Milestone to fetch.
     */
    where?: MilestoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Milestones to fetch.
     */
    orderBy?: MilestoneOrderByWithRelationInput | MilestoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Milestones.
     */
    cursor?: MilestoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Milestones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Milestones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Milestones.
     */
    distinct?: MilestoneScalarFieldEnum | MilestoneScalarFieldEnum[]
  }

  /**
   * Milestone findFirstOrThrow
   */
  export type MilestoneFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Milestone
     */
    omit?: MilestoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilestoneInclude<ExtArgs> | null
    /**
     * Filter, which Milestone to fetch.
     */
    where?: MilestoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Milestones to fetch.
     */
    orderBy?: MilestoneOrderByWithRelationInput | MilestoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Milestones.
     */
    cursor?: MilestoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Milestones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Milestones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Milestones.
     */
    distinct?: MilestoneScalarFieldEnum | MilestoneScalarFieldEnum[]
  }

  /**
   * Milestone findMany
   */
  export type MilestoneFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Milestone
     */
    omit?: MilestoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilestoneInclude<ExtArgs> | null
    /**
     * Filter, which Milestones to fetch.
     */
    where?: MilestoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Milestones to fetch.
     */
    orderBy?: MilestoneOrderByWithRelationInput | MilestoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Milestones.
     */
    cursor?: MilestoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Milestones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Milestones.
     */
    skip?: number
    distinct?: MilestoneScalarFieldEnum | MilestoneScalarFieldEnum[]
  }

  /**
   * Milestone create
   */
  export type MilestoneCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Milestone
     */
    omit?: MilestoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilestoneInclude<ExtArgs> | null
    /**
     * The data needed to create a Milestone.
     */
    data: XOR<MilestoneCreateInput, MilestoneUncheckedCreateInput>
  }

  /**
   * Milestone createMany
   */
  export type MilestoneCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Milestones.
     */
    data: MilestoneCreateManyInput | MilestoneCreateManyInput[]
  }

  /**
   * Milestone createManyAndReturn
   */
  export type MilestoneCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Milestone
     */
    omit?: MilestoneOmit<ExtArgs> | null
    /**
     * The data used to create many Milestones.
     */
    data: MilestoneCreateManyInput | MilestoneCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilestoneIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Milestone update
   */
  export type MilestoneUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Milestone
     */
    omit?: MilestoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilestoneInclude<ExtArgs> | null
    /**
     * The data needed to update a Milestone.
     */
    data: XOR<MilestoneUpdateInput, MilestoneUncheckedUpdateInput>
    /**
     * Choose, which Milestone to update.
     */
    where: MilestoneWhereUniqueInput
  }

  /**
   * Milestone updateMany
   */
  export type MilestoneUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Milestones.
     */
    data: XOR<MilestoneUpdateManyMutationInput, MilestoneUncheckedUpdateManyInput>
    /**
     * Filter which Milestones to update
     */
    where?: MilestoneWhereInput
    /**
     * Limit how many Milestones to update.
     */
    limit?: number
  }

  /**
   * Milestone updateManyAndReturn
   */
  export type MilestoneUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Milestone
     */
    omit?: MilestoneOmit<ExtArgs> | null
    /**
     * The data used to update Milestones.
     */
    data: XOR<MilestoneUpdateManyMutationInput, MilestoneUncheckedUpdateManyInput>
    /**
     * Filter which Milestones to update
     */
    where?: MilestoneWhereInput
    /**
     * Limit how many Milestones to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilestoneIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Milestone upsert
   */
  export type MilestoneUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Milestone
     */
    omit?: MilestoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilestoneInclude<ExtArgs> | null
    /**
     * The filter to search for the Milestone to update in case it exists.
     */
    where: MilestoneWhereUniqueInput
    /**
     * In case the Milestone found by the `where` argument doesn't exist, create a new Milestone with this data.
     */
    create: XOR<MilestoneCreateInput, MilestoneUncheckedCreateInput>
    /**
     * In case the Milestone was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MilestoneUpdateInput, MilestoneUncheckedUpdateInput>
  }

  /**
   * Milestone delete
   */
  export type MilestoneDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Milestone
     */
    omit?: MilestoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilestoneInclude<ExtArgs> | null
    /**
     * Filter which Milestone to delete.
     */
    where: MilestoneWhereUniqueInput
  }

  /**
   * Milestone deleteMany
   */
  export type MilestoneDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Milestones to delete
     */
    where?: MilestoneWhereInput
    /**
     * Limit how many Milestones to delete.
     */
    limit?: number
  }

  /**
   * Milestone without action
   */
  export type MilestoneDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Milestone
     */
    omit?: MilestoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilestoneInclude<ExtArgs> | null
  }


  /**
   * Model Budget
   */

  export type AggregateBudget = {
    _count: BudgetCountAggregateOutputType | null
    _avg: BudgetAvgAggregateOutputType | null
    _sum: BudgetSumAggregateOutputType | null
    _min: BudgetMinAggregateOutputType | null
    _max: BudgetMaxAggregateOutputType | null
  }

  export type BudgetAvgAggregateOutputType = {
    total: number | null
    spent: number | null
    remaining: number | null
  }

  export type BudgetSumAggregateOutputType = {
    total: number | null
    spent: number | null
    remaining: number | null
  }

  export type BudgetMinAggregateOutputType = {
    id: string | null
    currency: string | null
    total: number | null
    spent: number | null
    remaining: number | null
    projectId: string | null
  }

  export type BudgetMaxAggregateOutputType = {
    id: string | null
    currency: string | null
    total: number | null
    spent: number | null
    remaining: number | null
    projectId: string | null
  }

  export type BudgetCountAggregateOutputType = {
    id: number
    currency: number
    total: number
    spent: number
    remaining: number
    projectId: number
    _all: number
  }


  export type BudgetAvgAggregateInputType = {
    total?: true
    spent?: true
    remaining?: true
  }

  export type BudgetSumAggregateInputType = {
    total?: true
    spent?: true
    remaining?: true
  }

  export type BudgetMinAggregateInputType = {
    id?: true
    currency?: true
    total?: true
    spent?: true
    remaining?: true
    projectId?: true
  }

  export type BudgetMaxAggregateInputType = {
    id?: true
    currency?: true
    total?: true
    spent?: true
    remaining?: true
    projectId?: true
  }

  export type BudgetCountAggregateInputType = {
    id?: true
    currency?: true
    total?: true
    spent?: true
    remaining?: true
    projectId?: true
    _all?: true
  }

  export type BudgetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Budget to aggregate.
     */
    where?: BudgetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Budgets to fetch.
     */
    orderBy?: BudgetOrderByWithRelationInput | BudgetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BudgetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Budgets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Budgets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Budgets
    **/
    _count?: true | BudgetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BudgetAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BudgetSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BudgetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BudgetMaxAggregateInputType
  }

  export type GetBudgetAggregateType<T extends BudgetAggregateArgs> = {
        [P in keyof T & keyof AggregateBudget]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBudget[P]>
      : GetScalarType<T[P], AggregateBudget[P]>
  }




  export type BudgetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BudgetWhereInput
    orderBy?: BudgetOrderByWithAggregationInput | BudgetOrderByWithAggregationInput[]
    by: BudgetScalarFieldEnum[] | BudgetScalarFieldEnum
    having?: BudgetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BudgetCountAggregateInputType | true
    _avg?: BudgetAvgAggregateInputType
    _sum?: BudgetSumAggregateInputType
    _min?: BudgetMinAggregateInputType
    _max?: BudgetMaxAggregateInputType
  }

  export type BudgetGroupByOutputType = {
    id: string
    currency: string
    total: number
    spent: number
    remaining: number
    projectId: string
    _count: BudgetCountAggregateOutputType | null
    _avg: BudgetAvgAggregateOutputType | null
    _sum: BudgetSumAggregateOutputType | null
    _min: BudgetMinAggregateOutputType | null
    _max: BudgetMaxAggregateOutputType | null
  }

  type GetBudgetGroupByPayload<T extends BudgetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BudgetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BudgetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BudgetGroupByOutputType[P]>
            : GetScalarType<T[P], BudgetGroupByOutputType[P]>
        }
      >
    >


  export type BudgetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    currency?: boolean
    total?: boolean
    spent?: boolean
    remaining?: boolean
    projectId?: boolean
    lineItems?: boolean | Budget$lineItemsArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    _count?: boolean | BudgetCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["budget"]>

  export type BudgetSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    currency?: boolean
    total?: boolean
    spent?: boolean
    remaining?: boolean
    projectId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["budget"]>

  export type BudgetSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    currency?: boolean
    total?: boolean
    spent?: boolean
    remaining?: boolean
    projectId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["budget"]>

  export type BudgetSelectScalar = {
    id?: boolean
    currency?: boolean
    total?: boolean
    spent?: boolean
    remaining?: boolean
    projectId?: boolean
  }

  export type BudgetOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "currency" | "total" | "spent" | "remaining" | "projectId", ExtArgs["result"]["budget"]>
  export type BudgetInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lineItems?: boolean | Budget$lineItemsArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    _count?: boolean | BudgetCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BudgetIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type BudgetIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $BudgetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Budget"
    objects: {
      lineItems: Prisma.$BudgetLineItemPayload<ExtArgs>[]
      project: Prisma.$ProjectPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      currency: string
      total: number
      spent: number
      remaining: number
      projectId: string
    }, ExtArgs["result"]["budget"]>
    composites: {}
  }

  type BudgetGetPayload<S extends boolean | null | undefined | BudgetDefaultArgs> = $Result.GetResult<Prisma.$BudgetPayload, S>

  type BudgetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BudgetFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BudgetCountAggregateInputType | true
    }

  export interface BudgetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Budget'], meta: { name: 'Budget' } }
    /**
     * Find zero or one Budget that matches the filter.
     * @param {BudgetFindUniqueArgs} args - Arguments to find a Budget
     * @example
     * // Get one Budget
     * const budget = await prisma.budget.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BudgetFindUniqueArgs>(args: SelectSubset<T, BudgetFindUniqueArgs<ExtArgs>>): Prisma__BudgetClient<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Budget that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BudgetFindUniqueOrThrowArgs} args - Arguments to find a Budget
     * @example
     * // Get one Budget
     * const budget = await prisma.budget.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BudgetFindUniqueOrThrowArgs>(args: SelectSubset<T, BudgetFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BudgetClient<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Budget that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetFindFirstArgs} args - Arguments to find a Budget
     * @example
     * // Get one Budget
     * const budget = await prisma.budget.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BudgetFindFirstArgs>(args?: SelectSubset<T, BudgetFindFirstArgs<ExtArgs>>): Prisma__BudgetClient<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Budget that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetFindFirstOrThrowArgs} args - Arguments to find a Budget
     * @example
     * // Get one Budget
     * const budget = await prisma.budget.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BudgetFindFirstOrThrowArgs>(args?: SelectSubset<T, BudgetFindFirstOrThrowArgs<ExtArgs>>): Prisma__BudgetClient<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Budgets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Budgets
     * const budgets = await prisma.budget.findMany()
     * 
     * // Get first 10 Budgets
     * const budgets = await prisma.budget.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const budgetWithIdOnly = await prisma.budget.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BudgetFindManyArgs>(args?: SelectSubset<T, BudgetFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Budget.
     * @param {BudgetCreateArgs} args - Arguments to create a Budget.
     * @example
     * // Create one Budget
     * const Budget = await prisma.budget.create({
     *   data: {
     *     // ... data to create a Budget
     *   }
     * })
     * 
     */
    create<T extends BudgetCreateArgs>(args: SelectSubset<T, BudgetCreateArgs<ExtArgs>>): Prisma__BudgetClient<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Budgets.
     * @param {BudgetCreateManyArgs} args - Arguments to create many Budgets.
     * @example
     * // Create many Budgets
     * const budget = await prisma.budget.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BudgetCreateManyArgs>(args?: SelectSubset<T, BudgetCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Budgets and returns the data saved in the database.
     * @param {BudgetCreateManyAndReturnArgs} args - Arguments to create many Budgets.
     * @example
     * // Create many Budgets
     * const budget = await prisma.budget.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Budgets and only return the `id`
     * const budgetWithIdOnly = await prisma.budget.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BudgetCreateManyAndReturnArgs>(args?: SelectSubset<T, BudgetCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Budget.
     * @param {BudgetDeleteArgs} args - Arguments to delete one Budget.
     * @example
     * // Delete one Budget
     * const Budget = await prisma.budget.delete({
     *   where: {
     *     // ... filter to delete one Budget
     *   }
     * })
     * 
     */
    delete<T extends BudgetDeleteArgs>(args: SelectSubset<T, BudgetDeleteArgs<ExtArgs>>): Prisma__BudgetClient<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Budget.
     * @param {BudgetUpdateArgs} args - Arguments to update one Budget.
     * @example
     * // Update one Budget
     * const budget = await prisma.budget.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BudgetUpdateArgs>(args: SelectSubset<T, BudgetUpdateArgs<ExtArgs>>): Prisma__BudgetClient<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Budgets.
     * @param {BudgetDeleteManyArgs} args - Arguments to filter Budgets to delete.
     * @example
     * // Delete a few Budgets
     * const { count } = await prisma.budget.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BudgetDeleteManyArgs>(args?: SelectSubset<T, BudgetDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Budgets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Budgets
     * const budget = await prisma.budget.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BudgetUpdateManyArgs>(args: SelectSubset<T, BudgetUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Budgets and returns the data updated in the database.
     * @param {BudgetUpdateManyAndReturnArgs} args - Arguments to update many Budgets.
     * @example
     * // Update many Budgets
     * const budget = await prisma.budget.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Budgets and only return the `id`
     * const budgetWithIdOnly = await prisma.budget.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BudgetUpdateManyAndReturnArgs>(args: SelectSubset<T, BudgetUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Budget.
     * @param {BudgetUpsertArgs} args - Arguments to update or create a Budget.
     * @example
     * // Update or create a Budget
     * const budget = await prisma.budget.upsert({
     *   create: {
     *     // ... data to create a Budget
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Budget we want to update
     *   }
     * })
     */
    upsert<T extends BudgetUpsertArgs>(args: SelectSubset<T, BudgetUpsertArgs<ExtArgs>>): Prisma__BudgetClient<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Budgets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetCountArgs} args - Arguments to filter Budgets to count.
     * @example
     * // Count the number of Budgets
     * const count = await prisma.budget.count({
     *   where: {
     *     // ... the filter for the Budgets we want to count
     *   }
     * })
    **/
    count<T extends BudgetCountArgs>(
      args?: Subset<T, BudgetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BudgetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Budget.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BudgetAggregateArgs>(args: Subset<T, BudgetAggregateArgs>): Prisma.PrismaPromise<GetBudgetAggregateType<T>>

    /**
     * Group by Budget.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BudgetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BudgetGroupByArgs['orderBy'] }
        : { orderBy?: BudgetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BudgetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBudgetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Budget model
   */
  readonly fields: BudgetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Budget.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BudgetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    lineItems<T extends Budget$lineItemsArgs<ExtArgs> = {}>(args?: Subset<T, Budget$lineItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BudgetLineItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Budget model
   */
  interface BudgetFieldRefs {
    readonly id: FieldRef<"Budget", 'String'>
    readonly currency: FieldRef<"Budget", 'String'>
    readonly total: FieldRef<"Budget", 'Float'>
    readonly spent: FieldRef<"Budget", 'Float'>
    readonly remaining: FieldRef<"Budget", 'Float'>
    readonly projectId: FieldRef<"Budget", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Budget findUnique
   */
  export type BudgetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Budget
     */
    omit?: BudgetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
    /**
     * Filter, which Budget to fetch.
     */
    where: BudgetWhereUniqueInput
  }

  /**
   * Budget findUniqueOrThrow
   */
  export type BudgetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Budget
     */
    omit?: BudgetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
    /**
     * Filter, which Budget to fetch.
     */
    where: BudgetWhereUniqueInput
  }

  /**
   * Budget findFirst
   */
  export type BudgetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Budget
     */
    omit?: BudgetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
    /**
     * Filter, which Budget to fetch.
     */
    where?: BudgetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Budgets to fetch.
     */
    orderBy?: BudgetOrderByWithRelationInput | BudgetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Budgets.
     */
    cursor?: BudgetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Budgets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Budgets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Budgets.
     */
    distinct?: BudgetScalarFieldEnum | BudgetScalarFieldEnum[]
  }

  /**
   * Budget findFirstOrThrow
   */
  export type BudgetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Budget
     */
    omit?: BudgetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
    /**
     * Filter, which Budget to fetch.
     */
    where?: BudgetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Budgets to fetch.
     */
    orderBy?: BudgetOrderByWithRelationInput | BudgetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Budgets.
     */
    cursor?: BudgetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Budgets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Budgets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Budgets.
     */
    distinct?: BudgetScalarFieldEnum | BudgetScalarFieldEnum[]
  }

  /**
   * Budget findMany
   */
  export type BudgetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Budget
     */
    omit?: BudgetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
    /**
     * Filter, which Budgets to fetch.
     */
    where?: BudgetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Budgets to fetch.
     */
    orderBy?: BudgetOrderByWithRelationInput | BudgetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Budgets.
     */
    cursor?: BudgetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Budgets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Budgets.
     */
    skip?: number
    distinct?: BudgetScalarFieldEnum | BudgetScalarFieldEnum[]
  }

  /**
   * Budget create
   */
  export type BudgetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Budget
     */
    omit?: BudgetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
    /**
     * The data needed to create a Budget.
     */
    data: XOR<BudgetCreateInput, BudgetUncheckedCreateInput>
  }

  /**
   * Budget createMany
   */
  export type BudgetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Budgets.
     */
    data: BudgetCreateManyInput | BudgetCreateManyInput[]
  }

  /**
   * Budget createManyAndReturn
   */
  export type BudgetCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Budget
     */
    omit?: BudgetOmit<ExtArgs> | null
    /**
     * The data used to create many Budgets.
     */
    data: BudgetCreateManyInput | BudgetCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Budget update
   */
  export type BudgetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Budget
     */
    omit?: BudgetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
    /**
     * The data needed to update a Budget.
     */
    data: XOR<BudgetUpdateInput, BudgetUncheckedUpdateInput>
    /**
     * Choose, which Budget to update.
     */
    where: BudgetWhereUniqueInput
  }

  /**
   * Budget updateMany
   */
  export type BudgetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Budgets.
     */
    data: XOR<BudgetUpdateManyMutationInput, BudgetUncheckedUpdateManyInput>
    /**
     * Filter which Budgets to update
     */
    where?: BudgetWhereInput
    /**
     * Limit how many Budgets to update.
     */
    limit?: number
  }

  /**
   * Budget updateManyAndReturn
   */
  export type BudgetUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Budget
     */
    omit?: BudgetOmit<ExtArgs> | null
    /**
     * The data used to update Budgets.
     */
    data: XOR<BudgetUpdateManyMutationInput, BudgetUncheckedUpdateManyInput>
    /**
     * Filter which Budgets to update
     */
    where?: BudgetWhereInput
    /**
     * Limit how many Budgets to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Budget upsert
   */
  export type BudgetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Budget
     */
    omit?: BudgetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
    /**
     * The filter to search for the Budget to update in case it exists.
     */
    where: BudgetWhereUniqueInput
    /**
     * In case the Budget found by the `where` argument doesn't exist, create a new Budget with this data.
     */
    create: XOR<BudgetCreateInput, BudgetUncheckedCreateInput>
    /**
     * In case the Budget was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BudgetUpdateInput, BudgetUncheckedUpdateInput>
  }

  /**
   * Budget delete
   */
  export type BudgetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Budget
     */
    omit?: BudgetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
    /**
     * Filter which Budget to delete.
     */
    where: BudgetWhereUniqueInput
  }

  /**
   * Budget deleteMany
   */
  export type BudgetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Budgets to delete
     */
    where?: BudgetWhereInput
    /**
     * Limit how many Budgets to delete.
     */
    limit?: number
  }

  /**
   * Budget.lineItems
   */
  export type Budget$lineItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetLineItem
     */
    select?: BudgetLineItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BudgetLineItem
     */
    omit?: BudgetLineItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetLineItemInclude<ExtArgs> | null
    where?: BudgetLineItemWhereInput
    orderBy?: BudgetLineItemOrderByWithRelationInput | BudgetLineItemOrderByWithRelationInput[]
    cursor?: BudgetLineItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BudgetLineItemScalarFieldEnum | BudgetLineItemScalarFieldEnum[]
  }

  /**
   * Budget without action
   */
  export type BudgetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Budget
     */
    omit?: BudgetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
  }


  /**
   * Model BudgetLineItem
   */

  export type AggregateBudgetLineItem = {
    _count: BudgetLineItemCountAggregateOutputType | null
    _avg: BudgetLineItemAvgAggregateOutputType | null
    _sum: BudgetLineItemSumAggregateOutputType | null
    _min: BudgetLineItemMinAggregateOutputType | null
    _max: BudgetLineItemMaxAggregateOutputType | null
  }

  export type BudgetLineItemAvgAggregateOutputType = {
    amount: number | null
  }

  export type BudgetLineItemSumAggregateOutputType = {
    amount: number | null
  }

  export type BudgetLineItemMinAggregateOutputType = {
    id: string | null
    description: string | null
    amount: number | null
    category: string | null
    budgetId: string | null
  }

  export type BudgetLineItemMaxAggregateOutputType = {
    id: string | null
    description: string | null
    amount: number | null
    category: string | null
    budgetId: string | null
  }

  export type BudgetLineItemCountAggregateOutputType = {
    id: number
    description: number
    amount: number
    category: number
    budgetId: number
    _all: number
  }


  export type BudgetLineItemAvgAggregateInputType = {
    amount?: true
  }

  export type BudgetLineItemSumAggregateInputType = {
    amount?: true
  }

  export type BudgetLineItemMinAggregateInputType = {
    id?: true
    description?: true
    amount?: true
    category?: true
    budgetId?: true
  }

  export type BudgetLineItemMaxAggregateInputType = {
    id?: true
    description?: true
    amount?: true
    category?: true
    budgetId?: true
  }

  export type BudgetLineItemCountAggregateInputType = {
    id?: true
    description?: true
    amount?: true
    category?: true
    budgetId?: true
    _all?: true
  }

  export type BudgetLineItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BudgetLineItem to aggregate.
     */
    where?: BudgetLineItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BudgetLineItems to fetch.
     */
    orderBy?: BudgetLineItemOrderByWithRelationInput | BudgetLineItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BudgetLineItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BudgetLineItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BudgetLineItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BudgetLineItems
    **/
    _count?: true | BudgetLineItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BudgetLineItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BudgetLineItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BudgetLineItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BudgetLineItemMaxAggregateInputType
  }

  export type GetBudgetLineItemAggregateType<T extends BudgetLineItemAggregateArgs> = {
        [P in keyof T & keyof AggregateBudgetLineItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBudgetLineItem[P]>
      : GetScalarType<T[P], AggregateBudgetLineItem[P]>
  }




  export type BudgetLineItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BudgetLineItemWhereInput
    orderBy?: BudgetLineItemOrderByWithAggregationInput | BudgetLineItemOrderByWithAggregationInput[]
    by: BudgetLineItemScalarFieldEnum[] | BudgetLineItemScalarFieldEnum
    having?: BudgetLineItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BudgetLineItemCountAggregateInputType | true
    _avg?: BudgetLineItemAvgAggregateInputType
    _sum?: BudgetLineItemSumAggregateInputType
    _min?: BudgetLineItemMinAggregateInputType
    _max?: BudgetLineItemMaxAggregateInputType
  }

  export type BudgetLineItemGroupByOutputType = {
    id: string
    description: string
    amount: number
    category: string
    budgetId: string
    _count: BudgetLineItemCountAggregateOutputType | null
    _avg: BudgetLineItemAvgAggregateOutputType | null
    _sum: BudgetLineItemSumAggregateOutputType | null
    _min: BudgetLineItemMinAggregateOutputType | null
    _max: BudgetLineItemMaxAggregateOutputType | null
  }

  type GetBudgetLineItemGroupByPayload<T extends BudgetLineItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BudgetLineItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BudgetLineItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BudgetLineItemGroupByOutputType[P]>
            : GetScalarType<T[P], BudgetLineItemGroupByOutputType[P]>
        }
      >
    >


  export type BudgetLineItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    description?: boolean
    amount?: boolean
    category?: boolean
    budgetId?: boolean
    budget?: boolean | BudgetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["budgetLineItem"]>

  export type BudgetLineItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    description?: boolean
    amount?: boolean
    category?: boolean
    budgetId?: boolean
    budget?: boolean | BudgetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["budgetLineItem"]>

  export type BudgetLineItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    description?: boolean
    amount?: boolean
    category?: boolean
    budgetId?: boolean
    budget?: boolean | BudgetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["budgetLineItem"]>

  export type BudgetLineItemSelectScalar = {
    id?: boolean
    description?: boolean
    amount?: boolean
    category?: boolean
    budgetId?: boolean
  }

  export type BudgetLineItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "description" | "amount" | "category" | "budgetId", ExtArgs["result"]["budgetLineItem"]>
  export type BudgetLineItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    budget?: boolean | BudgetDefaultArgs<ExtArgs>
  }
  export type BudgetLineItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    budget?: boolean | BudgetDefaultArgs<ExtArgs>
  }
  export type BudgetLineItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    budget?: boolean | BudgetDefaultArgs<ExtArgs>
  }

  export type $BudgetLineItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BudgetLineItem"
    objects: {
      budget: Prisma.$BudgetPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      description: string
      amount: number
      category: string
      budgetId: string
    }, ExtArgs["result"]["budgetLineItem"]>
    composites: {}
  }

  type BudgetLineItemGetPayload<S extends boolean | null | undefined | BudgetLineItemDefaultArgs> = $Result.GetResult<Prisma.$BudgetLineItemPayload, S>

  type BudgetLineItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BudgetLineItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BudgetLineItemCountAggregateInputType | true
    }

  export interface BudgetLineItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BudgetLineItem'], meta: { name: 'BudgetLineItem' } }
    /**
     * Find zero or one BudgetLineItem that matches the filter.
     * @param {BudgetLineItemFindUniqueArgs} args - Arguments to find a BudgetLineItem
     * @example
     * // Get one BudgetLineItem
     * const budgetLineItem = await prisma.budgetLineItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BudgetLineItemFindUniqueArgs>(args: SelectSubset<T, BudgetLineItemFindUniqueArgs<ExtArgs>>): Prisma__BudgetLineItemClient<$Result.GetResult<Prisma.$BudgetLineItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BudgetLineItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BudgetLineItemFindUniqueOrThrowArgs} args - Arguments to find a BudgetLineItem
     * @example
     * // Get one BudgetLineItem
     * const budgetLineItem = await prisma.budgetLineItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BudgetLineItemFindUniqueOrThrowArgs>(args: SelectSubset<T, BudgetLineItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BudgetLineItemClient<$Result.GetResult<Prisma.$BudgetLineItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BudgetLineItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetLineItemFindFirstArgs} args - Arguments to find a BudgetLineItem
     * @example
     * // Get one BudgetLineItem
     * const budgetLineItem = await prisma.budgetLineItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BudgetLineItemFindFirstArgs>(args?: SelectSubset<T, BudgetLineItemFindFirstArgs<ExtArgs>>): Prisma__BudgetLineItemClient<$Result.GetResult<Prisma.$BudgetLineItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BudgetLineItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetLineItemFindFirstOrThrowArgs} args - Arguments to find a BudgetLineItem
     * @example
     * // Get one BudgetLineItem
     * const budgetLineItem = await prisma.budgetLineItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BudgetLineItemFindFirstOrThrowArgs>(args?: SelectSubset<T, BudgetLineItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__BudgetLineItemClient<$Result.GetResult<Prisma.$BudgetLineItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BudgetLineItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetLineItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BudgetLineItems
     * const budgetLineItems = await prisma.budgetLineItem.findMany()
     * 
     * // Get first 10 BudgetLineItems
     * const budgetLineItems = await prisma.budgetLineItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const budgetLineItemWithIdOnly = await prisma.budgetLineItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BudgetLineItemFindManyArgs>(args?: SelectSubset<T, BudgetLineItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BudgetLineItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BudgetLineItem.
     * @param {BudgetLineItemCreateArgs} args - Arguments to create a BudgetLineItem.
     * @example
     * // Create one BudgetLineItem
     * const BudgetLineItem = await prisma.budgetLineItem.create({
     *   data: {
     *     // ... data to create a BudgetLineItem
     *   }
     * })
     * 
     */
    create<T extends BudgetLineItemCreateArgs>(args: SelectSubset<T, BudgetLineItemCreateArgs<ExtArgs>>): Prisma__BudgetLineItemClient<$Result.GetResult<Prisma.$BudgetLineItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BudgetLineItems.
     * @param {BudgetLineItemCreateManyArgs} args - Arguments to create many BudgetLineItems.
     * @example
     * // Create many BudgetLineItems
     * const budgetLineItem = await prisma.budgetLineItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BudgetLineItemCreateManyArgs>(args?: SelectSubset<T, BudgetLineItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BudgetLineItems and returns the data saved in the database.
     * @param {BudgetLineItemCreateManyAndReturnArgs} args - Arguments to create many BudgetLineItems.
     * @example
     * // Create many BudgetLineItems
     * const budgetLineItem = await prisma.budgetLineItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BudgetLineItems and only return the `id`
     * const budgetLineItemWithIdOnly = await prisma.budgetLineItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BudgetLineItemCreateManyAndReturnArgs>(args?: SelectSubset<T, BudgetLineItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BudgetLineItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BudgetLineItem.
     * @param {BudgetLineItemDeleteArgs} args - Arguments to delete one BudgetLineItem.
     * @example
     * // Delete one BudgetLineItem
     * const BudgetLineItem = await prisma.budgetLineItem.delete({
     *   where: {
     *     // ... filter to delete one BudgetLineItem
     *   }
     * })
     * 
     */
    delete<T extends BudgetLineItemDeleteArgs>(args: SelectSubset<T, BudgetLineItemDeleteArgs<ExtArgs>>): Prisma__BudgetLineItemClient<$Result.GetResult<Prisma.$BudgetLineItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BudgetLineItem.
     * @param {BudgetLineItemUpdateArgs} args - Arguments to update one BudgetLineItem.
     * @example
     * // Update one BudgetLineItem
     * const budgetLineItem = await prisma.budgetLineItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BudgetLineItemUpdateArgs>(args: SelectSubset<T, BudgetLineItemUpdateArgs<ExtArgs>>): Prisma__BudgetLineItemClient<$Result.GetResult<Prisma.$BudgetLineItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BudgetLineItems.
     * @param {BudgetLineItemDeleteManyArgs} args - Arguments to filter BudgetLineItems to delete.
     * @example
     * // Delete a few BudgetLineItems
     * const { count } = await prisma.budgetLineItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BudgetLineItemDeleteManyArgs>(args?: SelectSubset<T, BudgetLineItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BudgetLineItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetLineItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BudgetLineItems
     * const budgetLineItem = await prisma.budgetLineItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BudgetLineItemUpdateManyArgs>(args: SelectSubset<T, BudgetLineItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BudgetLineItems and returns the data updated in the database.
     * @param {BudgetLineItemUpdateManyAndReturnArgs} args - Arguments to update many BudgetLineItems.
     * @example
     * // Update many BudgetLineItems
     * const budgetLineItem = await prisma.budgetLineItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BudgetLineItems and only return the `id`
     * const budgetLineItemWithIdOnly = await prisma.budgetLineItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BudgetLineItemUpdateManyAndReturnArgs>(args: SelectSubset<T, BudgetLineItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BudgetLineItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BudgetLineItem.
     * @param {BudgetLineItemUpsertArgs} args - Arguments to update or create a BudgetLineItem.
     * @example
     * // Update or create a BudgetLineItem
     * const budgetLineItem = await prisma.budgetLineItem.upsert({
     *   create: {
     *     // ... data to create a BudgetLineItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BudgetLineItem we want to update
     *   }
     * })
     */
    upsert<T extends BudgetLineItemUpsertArgs>(args: SelectSubset<T, BudgetLineItemUpsertArgs<ExtArgs>>): Prisma__BudgetLineItemClient<$Result.GetResult<Prisma.$BudgetLineItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BudgetLineItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetLineItemCountArgs} args - Arguments to filter BudgetLineItems to count.
     * @example
     * // Count the number of BudgetLineItems
     * const count = await prisma.budgetLineItem.count({
     *   where: {
     *     // ... the filter for the BudgetLineItems we want to count
     *   }
     * })
    **/
    count<T extends BudgetLineItemCountArgs>(
      args?: Subset<T, BudgetLineItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BudgetLineItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BudgetLineItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetLineItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BudgetLineItemAggregateArgs>(args: Subset<T, BudgetLineItemAggregateArgs>): Prisma.PrismaPromise<GetBudgetLineItemAggregateType<T>>

    /**
     * Group by BudgetLineItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetLineItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BudgetLineItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BudgetLineItemGroupByArgs['orderBy'] }
        : { orderBy?: BudgetLineItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BudgetLineItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBudgetLineItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BudgetLineItem model
   */
  readonly fields: BudgetLineItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BudgetLineItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BudgetLineItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    budget<T extends BudgetDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BudgetDefaultArgs<ExtArgs>>): Prisma__BudgetClient<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BudgetLineItem model
   */
  interface BudgetLineItemFieldRefs {
    readonly id: FieldRef<"BudgetLineItem", 'String'>
    readonly description: FieldRef<"BudgetLineItem", 'String'>
    readonly amount: FieldRef<"BudgetLineItem", 'Float'>
    readonly category: FieldRef<"BudgetLineItem", 'String'>
    readonly budgetId: FieldRef<"BudgetLineItem", 'String'>
  }
    

  // Custom InputTypes
  /**
   * BudgetLineItem findUnique
   */
  export type BudgetLineItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetLineItem
     */
    select?: BudgetLineItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BudgetLineItem
     */
    omit?: BudgetLineItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetLineItemInclude<ExtArgs> | null
    /**
     * Filter, which BudgetLineItem to fetch.
     */
    where: BudgetLineItemWhereUniqueInput
  }

  /**
   * BudgetLineItem findUniqueOrThrow
   */
  export type BudgetLineItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetLineItem
     */
    select?: BudgetLineItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BudgetLineItem
     */
    omit?: BudgetLineItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetLineItemInclude<ExtArgs> | null
    /**
     * Filter, which BudgetLineItem to fetch.
     */
    where: BudgetLineItemWhereUniqueInput
  }

  /**
   * BudgetLineItem findFirst
   */
  export type BudgetLineItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetLineItem
     */
    select?: BudgetLineItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BudgetLineItem
     */
    omit?: BudgetLineItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetLineItemInclude<ExtArgs> | null
    /**
     * Filter, which BudgetLineItem to fetch.
     */
    where?: BudgetLineItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BudgetLineItems to fetch.
     */
    orderBy?: BudgetLineItemOrderByWithRelationInput | BudgetLineItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BudgetLineItems.
     */
    cursor?: BudgetLineItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BudgetLineItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BudgetLineItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BudgetLineItems.
     */
    distinct?: BudgetLineItemScalarFieldEnum | BudgetLineItemScalarFieldEnum[]
  }

  /**
   * BudgetLineItem findFirstOrThrow
   */
  export type BudgetLineItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetLineItem
     */
    select?: BudgetLineItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BudgetLineItem
     */
    omit?: BudgetLineItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetLineItemInclude<ExtArgs> | null
    /**
     * Filter, which BudgetLineItem to fetch.
     */
    where?: BudgetLineItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BudgetLineItems to fetch.
     */
    orderBy?: BudgetLineItemOrderByWithRelationInput | BudgetLineItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BudgetLineItems.
     */
    cursor?: BudgetLineItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BudgetLineItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BudgetLineItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BudgetLineItems.
     */
    distinct?: BudgetLineItemScalarFieldEnum | BudgetLineItemScalarFieldEnum[]
  }

  /**
   * BudgetLineItem findMany
   */
  export type BudgetLineItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetLineItem
     */
    select?: BudgetLineItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BudgetLineItem
     */
    omit?: BudgetLineItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetLineItemInclude<ExtArgs> | null
    /**
     * Filter, which BudgetLineItems to fetch.
     */
    where?: BudgetLineItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BudgetLineItems to fetch.
     */
    orderBy?: BudgetLineItemOrderByWithRelationInput | BudgetLineItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BudgetLineItems.
     */
    cursor?: BudgetLineItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BudgetLineItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BudgetLineItems.
     */
    skip?: number
    distinct?: BudgetLineItemScalarFieldEnum | BudgetLineItemScalarFieldEnum[]
  }

  /**
   * BudgetLineItem create
   */
  export type BudgetLineItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetLineItem
     */
    select?: BudgetLineItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BudgetLineItem
     */
    omit?: BudgetLineItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetLineItemInclude<ExtArgs> | null
    /**
     * The data needed to create a BudgetLineItem.
     */
    data: XOR<BudgetLineItemCreateInput, BudgetLineItemUncheckedCreateInput>
  }

  /**
   * BudgetLineItem createMany
   */
  export type BudgetLineItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BudgetLineItems.
     */
    data: BudgetLineItemCreateManyInput | BudgetLineItemCreateManyInput[]
  }

  /**
   * BudgetLineItem createManyAndReturn
   */
  export type BudgetLineItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetLineItem
     */
    select?: BudgetLineItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BudgetLineItem
     */
    omit?: BudgetLineItemOmit<ExtArgs> | null
    /**
     * The data used to create many BudgetLineItems.
     */
    data: BudgetLineItemCreateManyInput | BudgetLineItemCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetLineItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BudgetLineItem update
   */
  export type BudgetLineItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetLineItem
     */
    select?: BudgetLineItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BudgetLineItem
     */
    omit?: BudgetLineItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetLineItemInclude<ExtArgs> | null
    /**
     * The data needed to update a BudgetLineItem.
     */
    data: XOR<BudgetLineItemUpdateInput, BudgetLineItemUncheckedUpdateInput>
    /**
     * Choose, which BudgetLineItem to update.
     */
    where: BudgetLineItemWhereUniqueInput
  }

  /**
   * BudgetLineItem updateMany
   */
  export type BudgetLineItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BudgetLineItems.
     */
    data: XOR<BudgetLineItemUpdateManyMutationInput, BudgetLineItemUncheckedUpdateManyInput>
    /**
     * Filter which BudgetLineItems to update
     */
    where?: BudgetLineItemWhereInput
    /**
     * Limit how many BudgetLineItems to update.
     */
    limit?: number
  }

  /**
   * BudgetLineItem updateManyAndReturn
   */
  export type BudgetLineItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetLineItem
     */
    select?: BudgetLineItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BudgetLineItem
     */
    omit?: BudgetLineItemOmit<ExtArgs> | null
    /**
     * The data used to update BudgetLineItems.
     */
    data: XOR<BudgetLineItemUpdateManyMutationInput, BudgetLineItemUncheckedUpdateManyInput>
    /**
     * Filter which BudgetLineItems to update
     */
    where?: BudgetLineItemWhereInput
    /**
     * Limit how many BudgetLineItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetLineItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BudgetLineItem upsert
   */
  export type BudgetLineItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetLineItem
     */
    select?: BudgetLineItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BudgetLineItem
     */
    omit?: BudgetLineItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetLineItemInclude<ExtArgs> | null
    /**
     * The filter to search for the BudgetLineItem to update in case it exists.
     */
    where: BudgetLineItemWhereUniqueInput
    /**
     * In case the BudgetLineItem found by the `where` argument doesn't exist, create a new BudgetLineItem with this data.
     */
    create: XOR<BudgetLineItemCreateInput, BudgetLineItemUncheckedCreateInput>
    /**
     * In case the BudgetLineItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BudgetLineItemUpdateInput, BudgetLineItemUncheckedUpdateInput>
  }

  /**
   * BudgetLineItem delete
   */
  export type BudgetLineItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetLineItem
     */
    select?: BudgetLineItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BudgetLineItem
     */
    omit?: BudgetLineItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetLineItemInclude<ExtArgs> | null
    /**
     * Filter which BudgetLineItem to delete.
     */
    where: BudgetLineItemWhereUniqueInput
  }

  /**
   * BudgetLineItem deleteMany
   */
  export type BudgetLineItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BudgetLineItems to delete
     */
    where?: BudgetLineItemWhereInput
    /**
     * Limit how many BudgetLineItems to delete.
     */
    limit?: number
  }

  /**
   * BudgetLineItem without action
   */
  export type BudgetLineItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetLineItem
     */
    select?: BudgetLineItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BudgetLineItem
     */
    omit?: BudgetLineItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetLineItemInclude<ExtArgs> | null
  }


  /**
   * Model Interaction
   */

  export type AggregateInteraction = {
    _count: InteractionCountAggregateOutputType | null
    _min: InteractionMinAggregateOutputType | null
    _max: InteractionMaxAggregateOutputType | null
  }

  export type InteractionMinAggregateOutputType = {
    id: string | null
    type: string | null
    date: Date | null
    summary: string | null
    details: string | null
    followUpDate: Date | null
    followUpNotes: string | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
    customerId: string | null
  }

  export type InteractionMaxAggregateOutputType = {
    id: string | null
    type: string | null
    date: Date | null
    summary: string | null
    details: string | null
    followUpDate: Date | null
    followUpNotes: string | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
    customerId: string | null
  }

  export type InteractionCountAggregateOutputType = {
    id: number
    type: number
    date: number
    summary: number
    details: number
    followUpDate: number
    followUpNotes: number
    createdBy: number
    createdAt: number
    updatedAt: number
    customerId: number
    _all: number
  }


  export type InteractionMinAggregateInputType = {
    id?: true
    type?: true
    date?: true
    summary?: true
    details?: true
    followUpDate?: true
    followUpNotes?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    customerId?: true
  }

  export type InteractionMaxAggregateInputType = {
    id?: true
    type?: true
    date?: true
    summary?: true
    details?: true
    followUpDate?: true
    followUpNotes?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    customerId?: true
  }

  export type InteractionCountAggregateInputType = {
    id?: true
    type?: true
    date?: true
    summary?: true
    details?: true
    followUpDate?: true
    followUpNotes?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    customerId?: true
    _all?: true
  }

  export type InteractionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Interaction to aggregate.
     */
    where?: InteractionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Interactions to fetch.
     */
    orderBy?: InteractionOrderByWithRelationInput | InteractionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InteractionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Interactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Interactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Interactions
    **/
    _count?: true | InteractionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InteractionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InteractionMaxAggregateInputType
  }

  export type GetInteractionAggregateType<T extends InteractionAggregateArgs> = {
        [P in keyof T & keyof AggregateInteraction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInteraction[P]>
      : GetScalarType<T[P], AggregateInteraction[P]>
  }




  export type InteractionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InteractionWhereInput
    orderBy?: InteractionOrderByWithAggregationInput | InteractionOrderByWithAggregationInput[]
    by: InteractionScalarFieldEnum[] | InteractionScalarFieldEnum
    having?: InteractionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InteractionCountAggregateInputType | true
    _min?: InteractionMinAggregateInputType
    _max?: InteractionMaxAggregateInputType
  }

  export type InteractionGroupByOutputType = {
    id: string
    type: string
    date: Date
    summary: string
    details: string
    followUpDate: Date | null
    followUpNotes: string | null
    createdBy: string
    createdAt: Date
    updatedAt: Date
    customerId: string
    _count: InteractionCountAggregateOutputType | null
    _min: InteractionMinAggregateOutputType | null
    _max: InteractionMaxAggregateOutputType | null
  }

  type GetInteractionGroupByPayload<T extends InteractionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InteractionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InteractionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InteractionGroupByOutputType[P]>
            : GetScalarType<T[P], InteractionGroupByOutputType[P]>
        }
      >
    >


  export type InteractionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    date?: boolean
    summary?: boolean
    details?: boolean
    followUpDate?: boolean
    followUpNotes?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customerId?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["interaction"]>

  export type InteractionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    date?: boolean
    summary?: boolean
    details?: boolean
    followUpDate?: boolean
    followUpNotes?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customerId?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["interaction"]>

  export type InteractionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    date?: boolean
    summary?: boolean
    details?: boolean
    followUpDate?: boolean
    followUpNotes?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customerId?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["interaction"]>

  export type InteractionSelectScalar = {
    id?: boolean
    type?: boolean
    date?: boolean
    summary?: boolean
    details?: boolean
    followUpDate?: boolean
    followUpNotes?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customerId?: boolean
  }

  export type InteractionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type" | "date" | "summary" | "details" | "followUpDate" | "followUpNotes" | "createdBy" | "createdAt" | "updatedAt" | "customerId", ExtArgs["result"]["interaction"]>
  export type InteractionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }
  export type InteractionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }
  export type InteractionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }

  export type $InteractionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Interaction"
    objects: {
      customer: Prisma.$CustomerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: string
      date: Date
      summary: string
      details: string
      followUpDate: Date | null
      followUpNotes: string | null
      createdBy: string
      createdAt: Date
      updatedAt: Date
      customerId: string
    }, ExtArgs["result"]["interaction"]>
    composites: {}
  }

  type InteractionGetPayload<S extends boolean | null | undefined | InteractionDefaultArgs> = $Result.GetResult<Prisma.$InteractionPayload, S>

  type InteractionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InteractionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InteractionCountAggregateInputType | true
    }

  export interface InteractionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Interaction'], meta: { name: 'Interaction' } }
    /**
     * Find zero or one Interaction that matches the filter.
     * @param {InteractionFindUniqueArgs} args - Arguments to find a Interaction
     * @example
     * // Get one Interaction
     * const interaction = await prisma.interaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InteractionFindUniqueArgs>(args: SelectSubset<T, InteractionFindUniqueArgs<ExtArgs>>): Prisma__InteractionClient<$Result.GetResult<Prisma.$InteractionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Interaction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InteractionFindUniqueOrThrowArgs} args - Arguments to find a Interaction
     * @example
     * // Get one Interaction
     * const interaction = await prisma.interaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InteractionFindUniqueOrThrowArgs>(args: SelectSubset<T, InteractionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InteractionClient<$Result.GetResult<Prisma.$InteractionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Interaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InteractionFindFirstArgs} args - Arguments to find a Interaction
     * @example
     * // Get one Interaction
     * const interaction = await prisma.interaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InteractionFindFirstArgs>(args?: SelectSubset<T, InteractionFindFirstArgs<ExtArgs>>): Prisma__InteractionClient<$Result.GetResult<Prisma.$InteractionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Interaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InteractionFindFirstOrThrowArgs} args - Arguments to find a Interaction
     * @example
     * // Get one Interaction
     * const interaction = await prisma.interaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InteractionFindFirstOrThrowArgs>(args?: SelectSubset<T, InteractionFindFirstOrThrowArgs<ExtArgs>>): Prisma__InteractionClient<$Result.GetResult<Prisma.$InteractionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Interactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InteractionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Interactions
     * const interactions = await prisma.interaction.findMany()
     * 
     * // Get first 10 Interactions
     * const interactions = await prisma.interaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const interactionWithIdOnly = await prisma.interaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InteractionFindManyArgs>(args?: SelectSubset<T, InteractionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InteractionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Interaction.
     * @param {InteractionCreateArgs} args - Arguments to create a Interaction.
     * @example
     * // Create one Interaction
     * const Interaction = await prisma.interaction.create({
     *   data: {
     *     // ... data to create a Interaction
     *   }
     * })
     * 
     */
    create<T extends InteractionCreateArgs>(args: SelectSubset<T, InteractionCreateArgs<ExtArgs>>): Prisma__InteractionClient<$Result.GetResult<Prisma.$InteractionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Interactions.
     * @param {InteractionCreateManyArgs} args - Arguments to create many Interactions.
     * @example
     * // Create many Interactions
     * const interaction = await prisma.interaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InteractionCreateManyArgs>(args?: SelectSubset<T, InteractionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Interactions and returns the data saved in the database.
     * @param {InteractionCreateManyAndReturnArgs} args - Arguments to create many Interactions.
     * @example
     * // Create many Interactions
     * const interaction = await prisma.interaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Interactions and only return the `id`
     * const interactionWithIdOnly = await prisma.interaction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InteractionCreateManyAndReturnArgs>(args?: SelectSubset<T, InteractionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InteractionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Interaction.
     * @param {InteractionDeleteArgs} args - Arguments to delete one Interaction.
     * @example
     * // Delete one Interaction
     * const Interaction = await prisma.interaction.delete({
     *   where: {
     *     // ... filter to delete one Interaction
     *   }
     * })
     * 
     */
    delete<T extends InteractionDeleteArgs>(args: SelectSubset<T, InteractionDeleteArgs<ExtArgs>>): Prisma__InteractionClient<$Result.GetResult<Prisma.$InteractionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Interaction.
     * @param {InteractionUpdateArgs} args - Arguments to update one Interaction.
     * @example
     * // Update one Interaction
     * const interaction = await prisma.interaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InteractionUpdateArgs>(args: SelectSubset<T, InteractionUpdateArgs<ExtArgs>>): Prisma__InteractionClient<$Result.GetResult<Prisma.$InteractionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Interactions.
     * @param {InteractionDeleteManyArgs} args - Arguments to filter Interactions to delete.
     * @example
     * // Delete a few Interactions
     * const { count } = await prisma.interaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InteractionDeleteManyArgs>(args?: SelectSubset<T, InteractionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Interactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InteractionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Interactions
     * const interaction = await prisma.interaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InteractionUpdateManyArgs>(args: SelectSubset<T, InteractionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Interactions and returns the data updated in the database.
     * @param {InteractionUpdateManyAndReturnArgs} args - Arguments to update many Interactions.
     * @example
     * // Update many Interactions
     * const interaction = await prisma.interaction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Interactions and only return the `id`
     * const interactionWithIdOnly = await prisma.interaction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InteractionUpdateManyAndReturnArgs>(args: SelectSubset<T, InteractionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InteractionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Interaction.
     * @param {InteractionUpsertArgs} args - Arguments to update or create a Interaction.
     * @example
     * // Update or create a Interaction
     * const interaction = await prisma.interaction.upsert({
     *   create: {
     *     // ... data to create a Interaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Interaction we want to update
     *   }
     * })
     */
    upsert<T extends InteractionUpsertArgs>(args: SelectSubset<T, InteractionUpsertArgs<ExtArgs>>): Prisma__InteractionClient<$Result.GetResult<Prisma.$InteractionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Interactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InteractionCountArgs} args - Arguments to filter Interactions to count.
     * @example
     * // Count the number of Interactions
     * const count = await prisma.interaction.count({
     *   where: {
     *     // ... the filter for the Interactions we want to count
     *   }
     * })
    **/
    count<T extends InteractionCountArgs>(
      args?: Subset<T, InteractionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InteractionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Interaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InteractionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InteractionAggregateArgs>(args: Subset<T, InteractionAggregateArgs>): Prisma.PrismaPromise<GetInteractionAggregateType<T>>

    /**
     * Group by Interaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InteractionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InteractionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InteractionGroupByArgs['orderBy'] }
        : { orderBy?: InteractionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InteractionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInteractionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Interaction model
   */
  readonly fields: InteractionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Interaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InteractionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customer<T extends CustomerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerDefaultArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Interaction model
   */
  interface InteractionFieldRefs {
    readonly id: FieldRef<"Interaction", 'String'>
    readonly type: FieldRef<"Interaction", 'String'>
    readonly date: FieldRef<"Interaction", 'DateTime'>
    readonly summary: FieldRef<"Interaction", 'String'>
    readonly details: FieldRef<"Interaction", 'String'>
    readonly followUpDate: FieldRef<"Interaction", 'DateTime'>
    readonly followUpNotes: FieldRef<"Interaction", 'String'>
    readonly createdBy: FieldRef<"Interaction", 'String'>
    readonly createdAt: FieldRef<"Interaction", 'DateTime'>
    readonly updatedAt: FieldRef<"Interaction", 'DateTime'>
    readonly customerId: FieldRef<"Interaction", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Interaction findUnique
   */
  export type InteractionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interaction
     */
    select?: InteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Interaction
     */
    omit?: InteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InteractionInclude<ExtArgs> | null
    /**
     * Filter, which Interaction to fetch.
     */
    where: InteractionWhereUniqueInput
  }

  /**
   * Interaction findUniqueOrThrow
   */
  export type InteractionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interaction
     */
    select?: InteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Interaction
     */
    omit?: InteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InteractionInclude<ExtArgs> | null
    /**
     * Filter, which Interaction to fetch.
     */
    where: InteractionWhereUniqueInput
  }

  /**
   * Interaction findFirst
   */
  export type InteractionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interaction
     */
    select?: InteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Interaction
     */
    omit?: InteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InteractionInclude<ExtArgs> | null
    /**
     * Filter, which Interaction to fetch.
     */
    where?: InteractionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Interactions to fetch.
     */
    orderBy?: InteractionOrderByWithRelationInput | InteractionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Interactions.
     */
    cursor?: InteractionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Interactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Interactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Interactions.
     */
    distinct?: InteractionScalarFieldEnum | InteractionScalarFieldEnum[]
  }

  /**
   * Interaction findFirstOrThrow
   */
  export type InteractionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interaction
     */
    select?: InteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Interaction
     */
    omit?: InteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InteractionInclude<ExtArgs> | null
    /**
     * Filter, which Interaction to fetch.
     */
    where?: InteractionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Interactions to fetch.
     */
    orderBy?: InteractionOrderByWithRelationInput | InteractionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Interactions.
     */
    cursor?: InteractionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Interactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Interactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Interactions.
     */
    distinct?: InteractionScalarFieldEnum | InteractionScalarFieldEnum[]
  }

  /**
   * Interaction findMany
   */
  export type InteractionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interaction
     */
    select?: InteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Interaction
     */
    omit?: InteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InteractionInclude<ExtArgs> | null
    /**
     * Filter, which Interactions to fetch.
     */
    where?: InteractionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Interactions to fetch.
     */
    orderBy?: InteractionOrderByWithRelationInput | InteractionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Interactions.
     */
    cursor?: InteractionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Interactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Interactions.
     */
    skip?: number
    distinct?: InteractionScalarFieldEnum | InteractionScalarFieldEnum[]
  }

  /**
   * Interaction create
   */
  export type InteractionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interaction
     */
    select?: InteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Interaction
     */
    omit?: InteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InteractionInclude<ExtArgs> | null
    /**
     * The data needed to create a Interaction.
     */
    data: XOR<InteractionCreateInput, InteractionUncheckedCreateInput>
  }

  /**
   * Interaction createMany
   */
  export type InteractionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Interactions.
     */
    data: InteractionCreateManyInput | InteractionCreateManyInput[]
  }

  /**
   * Interaction createManyAndReturn
   */
  export type InteractionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interaction
     */
    select?: InteractionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Interaction
     */
    omit?: InteractionOmit<ExtArgs> | null
    /**
     * The data used to create many Interactions.
     */
    data: InteractionCreateManyInput | InteractionCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InteractionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Interaction update
   */
  export type InteractionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interaction
     */
    select?: InteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Interaction
     */
    omit?: InteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InteractionInclude<ExtArgs> | null
    /**
     * The data needed to update a Interaction.
     */
    data: XOR<InteractionUpdateInput, InteractionUncheckedUpdateInput>
    /**
     * Choose, which Interaction to update.
     */
    where: InteractionWhereUniqueInput
  }

  /**
   * Interaction updateMany
   */
  export type InteractionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Interactions.
     */
    data: XOR<InteractionUpdateManyMutationInput, InteractionUncheckedUpdateManyInput>
    /**
     * Filter which Interactions to update
     */
    where?: InteractionWhereInput
    /**
     * Limit how many Interactions to update.
     */
    limit?: number
  }

  /**
   * Interaction updateManyAndReturn
   */
  export type InteractionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interaction
     */
    select?: InteractionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Interaction
     */
    omit?: InteractionOmit<ExtArgs> | null
    /**
     * The data used to update Interactions.
     */
    data: XOR<InteractionUpdateManyMutationInput, InteractionUncheckedUpdateManyInput>
    /**
     * Filter which Interactions to update
     */
    where?: InteractionWhereInput
    /**
     * Limit how many Interactions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InteractionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Interaction upsert
   */
  export type InteractionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interaction
     */
    select?: InteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Interaction
     */
    omit?: InteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InteractionInclude<ExtArgs> | null
    /**
     * The filter to search for the Interaction to update in case it exists.
     */
    where: InteractionWhereUniqueInput
    /**
     * In case the Interaction found by the `where` argument doesn't exist, create a new Interaction with this data.
     */
    create: XOR<InteractionCreateInput, InteractionUncheckedCreateInput>
    /**
     * In case the Interaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InteractionUpdateInput, InteractionUncheckedUpdateInput>
  }

  /**
   * Interaction delete
   */
  export type InteractionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interaction
     */
    select?: InteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Interaction
     */
    omit?: InteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InteractionInclude<ExtArgs> | null
    /**
     * Filter which Interaction to delete.
     */
    where: InteractionWhereUniqueInput
  }

  /**
   * Interaction deleteMany
   */
  export type InteractionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Interactions to delete
     */
    where?: InteractionWhereInput
    /**
     * Limit how many Interactions to delete.
     */
    limit?: number
  }

  /**
   * Interaction without action
   */
  export type InteractionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interaction
     */
    select?: InteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Interaction
     */
    omit?: InteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InteractionInclude<ExtArgs> | null
  }


  /**
   * Model CustomerMetrics
   */

  export type AggregateCustomerMetrics = {
    _count: CustomerMetricsCountAggregateOutputType | null
    _avg: CustomerMetricsAvgAggregateOutputType | null
    _sum: CustomerMetricsSumAggregateOutputType | null
    _min: CustomerMetricsMinAggregateOutputType | null
    _max: CustomerMetricsMaxAggregateOutputType | null
  }

  export type CustomerMetricsAvgAggregateOutputType = {
    totalRevenue: number | null
    projectsCompleted: number | null
    avgResponseTime: number | null
  }

  export type CustomerMetricsSumAggregateOutputType = {
    totalRevenue: number | null
    projectsCompleted: number | null
    avgResponseTime: number | null
  }

  export type CustomerMetricsMinAggregateOutputType = {
    id: string | null
    totalRevenue: number | null
    projectsCompleted: number | null
    avgResponseTime: number | null
    lastInteraction: Date | null
    nextScheduledInteraction: Date | null
    customerId: string | null
  }

  export type CustomerMetricsMaxAggregateOutputType = {
    id: string | null
    totalRevenue: number | null
    projectsCompleted: number | null
    avgResponseTime: number | null
    lastInteraction: Date | null
    nextScheduledInteraction: Date | null
    customerId: string | null
  }

  export type CustomerMetricsCountAggregateOutputType = {
    id: number
    totalRevenue: number
    projectsCompleted: number
    avgResponseTime: number
    lastInteraction: number
    nextScheduledInteraction: number
    customerId: number
    _all: number
  }


  export type CustomerMetricsAvgAggregateInputType = {
    totalRevenue?: true
    projectsCompleted?: true
    avgResponseTime?: true
  }

  export type CustomerMetricsSumAggregateInputType = {
    totalRevenue?: true
    projectsCompleted?: true
    avgResponseTime?: true
  }

  export type CustomerMetricsMinAggregateInputType = {
    id?: true
    totalRevenue?: true
    projectsCompleted?: true
    avgResponseTime?: true
    lastInteraction?: true
    nextScheduledInteraction?: true
    customerId?: true
  }

  export type CustomerMetricsMaxAggregateInputType = {
    id?: true
    totalRevenue?: true
    projectsCompleted?: true
    avgResponseTime?: true
    lastInteraction?: true
    nextScheduledInteraction?: true
    customerId?: true
  }

  export type CustomerMetricsCountAggregateInputType = {
    id?: true
    totalRevenue?: true
    projectsCompleted?: true
    avgResponseTime?: true
    lastInteraction?: true
    nextScheduledInteraction?: true
    customerId?: true
    _all?: true
  }

  export type CustomerMetricsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomerMetrics to aggregate.
     */
    where?: CustomerMetricsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerMetrics to fetch.
     */
    orderBy?: CustomerMetricsOrderByWithRelationInput | CustomerMetricsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomerMetricsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CustomerMetrics
    **/
    _count?: true | CustomerMetricsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CustomerMetricsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CustomerMetricsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerMetricsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerMetricsMaxAggregateInputType
  }

  export type GetCustomerMetricsAggregateType<T extends CustomerMetricsAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomerMetrics]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomerMetrics[P]>
      : GetScalarType<T[P], AggregateCustomerMetrics[P]>
  }




  export type CustomerMetricsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerMetricsWhereInput
    orderBy?: CustomerMetricsOrderByWithAggregationInput | CustomerMetricsOrderByWithAggregationInput[]
    by: CustomerMetricsScalarFieldEnum[] | CustomerMetricsScalarFieldEnum
    having?: CustomerMetricsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerMetricsCountAggregateInputType | true
    _avg?: CustomerMetricsAvgAggregateInputType
    _sum?: CustomerMetricsSumAggregateInputType
    _min?: CustomerMetricsMinAggregateInputType
    _max?: CustomerMetricsMaxAggregateInputType
  }

  export type CustomerMetricsGroupByOutputType = {
    id: string
    totalRevenue: number
    projectsCompleted: number
    avgResponseTime: number
    lastInteraction: Date | null
    nextScheduledInteraction: Date | null
    customerId: string
    _count: CustomerMetricsCountAggregateOutputType | null
    _avg: CustomerMetricsAvgAggregateOutputType | null
    _sum: CustomerMetricsSumAggregateOutputType | null
    _min: CustomerMetricsMinAggregateOutputType | null
    _max: CustomerMetricsMaxAggregateOutputType | null
  }

  type GetCustomerMetricsGroupByPayload<T extends CustomerMetricsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomerMetricsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerMetricsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerMetricsGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerMetricsGroupByOutputType[P]>
        }
      >
    >


  export type CustomerMetricsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    totalRevenue?: boolean
    projectsCompleted?: boolean
    avgResponseTime?: boolean
    lastInteraction?: boolean
    nextScheduledInteraction?: boolean
    customerId?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customerMetrics"]>

  export type CustomerMetricsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    totalRevenue?: boolean
    projectsCompleted?: boolean
    avgResponseTime?: boolean
    lastInteraction?: boolean
    nextScheduledInteraction?: boolean
    customerId?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customerMetrics"]>

  export type CustomerMetricsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    totalRevenue?: boolean
    projectsCompleted?: boolean
    avgResponseTime?: boolean
    lastInteraction?: boolean
    nextScheduledInteraction?: boolean
    customerId?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customerMetrics"]>

  export type CustomerMetricsSelectScalar = {
    id?: boolean
    totalRevenue?: boolean
    projectsCompleted?: boolean
    avgResponseTime?: boolean
    lastInteraction?: boolean
    nextScheduledInteraction?: boolean
    customerId?: boolean
  }

  export type CustomerMetricsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "totalRevenue" | "projectsCompleted" | "avgResponseTime" | "lastInteraction" | "nextScheduledInteraction" | "customerId", ExtArgs["result"]["customerMetrics"]>
  export type CustomerMetricsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }
  export type CustomerMetricsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }
  export type CustomerMetricsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }

  export type $CustomerMetricsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CustomerMetrics"
    objects: {
      customer: Prisma.$CustomerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      totalRevenue: number
      projectsCompleted: number
      avgResponseTime: number
      lastInteraction: Date | null
      nextScheduledInteraction: Date | null
      customerId: string
    }, ExtArgs["result"]["customerMetrics"]>
    composites: {}
  }

  type CustomerMetricsGetPayload<S extends boolean | null | undefined | CustomerMetricsDefaultArgs> = $Result.GetResult<Prisma.$CustomerMetricsPayload, S>

  type CustomerMetricsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CustomerMetricsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CustomerMetricsCountAggregateInputType | true
    }

  export interface CustomerMetricsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CustomerMetrics'], meta: { name: 'CustomerMetrics' } }
    /**
     * Find zero or one CustomerMetrics that matches the filter.
     * @param {CustomerMetricsFindUniqueArgs} args - Arguments to find a CustomerMetrics
     * @example
     * // Get one CustomerMetrics
     * const customerMetrics = await prisma.customerMetrics.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomerMetricsFindUniqueArgs>(args: SelectSubset<T, CustomerMetricsFindUniqueArgs<ExtArgs>>): Prisma__CustomerMetricsClient<$Result.GetResult<Prisma.$CustomerMetricsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CustomerMetrics that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CustomerMetricsFindUniqueOrThrowArgs} args - Arguments to find a CustomerMetrics
     * @example
     * // Get one CustomerMetrics
     * const customerMetrics = await prisma.customerMetrics.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomerMetricsFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomerMetricsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomerMetricsClient<$Result.GetResult<Prisma.$CustomerMetricsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CustomerMetrics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerMetricsFindFirstArgs} args - Arguments to find a CustomerMetrics
     * @example
     * // Get one CustomerMetrics
     * const customerMetrics = await prisma.customerMetrics.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomerMetricsFindFirstArgs>(args?: SelectSubset<T, CustomerMetricsFindFirstArgs<ExtArgs>>): Prisma__CustomerMetricsClient<$Result.GetResult<Prisma.$CustomerMetricsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CustomerMetrics that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerMetricsFindFirstOrThrowArgs} args - Arguments to find a CustomerMetrics
     * @example
     * // Get one CustomerMetrics
     * const customerMetrics = await prisma.customerMetrics.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomerMetricsFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomerMetricsFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomerMetricsClient<$Result.GetResult<Prisma.$CustomerMetricsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CustomerMetrics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerMetricsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CustomerMetrics
     * const customerMetrics = await prisma.customerMetrics.findMany()
     * 
     * // Get first 10 CustomerMetrics
     * const customerMetrics = await prisma.customerMetrics.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customerMetricsWithIdOnly = await prisma.customerMetrics.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomerMetricsFindManyArgs>(args?: SelectSubset<T, CustomerMetricsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerMetricsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CustomerMetrics.
     * @param {CustomerMetricsCreateArgs} args - Arguments to create a CustomerMetrics.
     * @example
     * // Create one CustomerMetrics
     * const CustomerMetrics = await prisma.customerMetrics.create({
     *   data: {
     *     // ... data to create a CustomerMetrics
     *   }
     * })
     * 
     */
    create<T extends CustomerMetricsCreateArgs>(args: SelectSubset<T, CustomerMetricsCreateArgs<ExtArgs>>): Prisma__CustomerMetricsClient<$Result.GetResult<Prisma.$CustomerMetricsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CustomerMetrics.
     * @param {CustomerMetricsCreateManyArgs} args - Arguments to create many CustomerMetrics.
     * @example
     * // Create many CustomerMetrics
     * const customerMetrics = await prisma.customerMetrics.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomerMetricsCreateManyArgs>(args?: SelectSubset<T, CustomerMetricsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CustomerMetrics and returns the data saved in the database.
     * @param {CustomerMetricsCreateManyAndReturnArgs} args - Arguments to create many CustomerMetrics.
     * @example
     * // Create many CustomerMetrics
     * const customerMetrics = await prisma.customerMetrics.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CustomerMetrics and only return the `id`
     * const customerMetricsWithIdOnly = await prisma.customerMetrics.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CustomerMetricsCreateManyAndReturnArgs>(args?: SelectSubset<T, CustomerMetricsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerMetricsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CustomerMetrics.
     * @param {CustomerMetricsDeleteArgs} args - Arguments to delete one CustomerMetrics.
     * @example
     * // Delete one CustomerMetrics
     * const CustomerMetrics = await prisma.customerMetrics.delete({
     *   where: {
     *     // ... filter to delete one CustomerMetrics
     *   }
     * })
     * 
     */
    delete<T extends CustomerMetricsDeleteArgs>(args: SelectSubset<T, CustomerMetricsDeleteArgs<ExtArgs>>): Prisma__CustomerMetricsClient<$Result.GetResult<Prisma.$CustomerMetricsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CustomerMetrics.
     * @param {CustomerMetricsUpdateArgs} args - Arguments to update one CustomerMetrics.
     * @example
     * // Update one CustomerMetrics
     * const customerMetrics = await prisma.customerMetrics.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomerMetricsUpdateArgs>(args: SelectSubset<T, CustomerMetricsUpdateArgs<ExtArgs>>): Prisma__CustomerMetricsClient<$Result.GetResult<Prisma.$CustomerMetricsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CustomerMetrics.
     * @param {CustomerMetricsDeleteManyArgs} args - Arguments to filter CustomerMetrics to delete.
     * @example
     * // Delete a few CustomerMetrics
     * const { count } = await prisma.customerMetrics.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomerMetricsDeleteManyArgs>(args?: SelectSubset<T, CustomerMetricsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomerMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerMetricsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CustomerMetrics
     * const customerMetrics = await prisma.customerMetrics.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomerMetricsUpdateManyArgs>(args: SelectSubset<T, CustomerMetricsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomerMetrics and returns the data updated in the database.
     * @param {CustomerMetricsUpdateManyAndReturnArgs} args - Arguments to update many CustomerMetrics.
     * @example
     * // Update many CustomerMetrics
     * const customerMetrics = await prisma.customerMetrics.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CustomerMetrics and only return the `id`
     * const customerMetricsWithIdOnly = await prisma.customerMetrics.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CustomerMetricsUpdateManyAndReturnArgs>(args: SelectSubset<T, CustomerMetricsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerMetricsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CustomerMetrics.
     * @param {CustomerMetricsUpsertArgs} args - Arguments to update or create a CustomerMetrics.
     * @example
     * // Update or create a CustomerMetrics
     * const customerMetrics = await prisma.customerMetrics.upsert({
     *   create: {
     *     // ... data to create a CustomerMetrics
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CustomerMetrics we want to update
     *   }
     * })
     */
    upsert<T extends CustomerMetricsUpsertArgs>(args: SelectSubset<T, CustomerMetricsUpsertArgs<ExtArgs>>): Prisma__CustomerMetricsClient<$Result.GetResult<Prisma.$CustomerMetricsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CustomerMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerMetricsCountArgs} args - Arguments to filter CustomerMetrics to count.
     * @example
     * // Count the number of CustomerMetrics
     * const count = await prisma.customerMetrics.count({
     *   where: {
     *     // ... the filter for the CustomerMetrics we want to count
     *   }
     * })
    **/
    count<T extends CustomerMetricsCountArgs>(
      args?: Subset<T, CustomerMetricsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerMetricsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CustomerMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerMetricsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerMetricsAggregateArgs>(args: Subset<T, CustomerMetricsAggregateArgs>): Prisma.PrismaPromise<GetCustomerMetricsAggregateType<T>>

    /**
     * Group by CustomerMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerMetricsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerMetricsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerMetricsGroupByArgs['orderBy'] }
        : { orderBy?: CustomerMetricsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerMetricsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerMetricsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CustomerMetrics model
   */
  readonly fields: CustomerMetricsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CustomerMetrics.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomerMetricsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customer<T extends CustomerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerDefaultArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CustomerMetrics model
   */
  interface CustomerMetricsFieldRefs {
    readonly id: FieldRef<"CustomerMetrics", 'String'>
    readonly totalRevenue: FieldRef<"CustomerMetrics", 'Float'>
    readonly projectsCompleted: FieldRef<"CustomerMetrics", 'Int'>
    readonly avgResponseTime: FieldRef<"CustomerMetrics", 'Float'>
    readonly lastInteraction: FieldRef<"CustomerMetrics", 'DateTime'>
    readonly nextScheduledInteraction: FieldRef<"CustomerMetrics", 'DateTime'>
    readonly customerId: FieldRef<"CustomerMetrics", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CustomerMetrics findUnique
   */
  export type CustomerMetricsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerMetrics
     */
    select?: CustomerMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerMetrics
     */
    omit?: CustomerMetricsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerMetricsInclude<ExtArgs> | null
    /**
     * Filter, which CustomerMetrics to fetch.
     */
    where: CustomerMetricsWhereUniqueInput
  }

  /**
   * CustomerMetrics findUniqueOrThrow
   */
  export type CustomerMetricsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerMetrics
     */
    select?: CustomerMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerMetrics
     */
    omit?: CustomerMetricsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerMetricsInclude<ExtArgs> | null
    /**
     * Filter, which CustomerMetrics to fetch.
     */
    where: CustomerMetricsWhereUniqueInput
  }

  /**
   * CustomerMetrics findFirst
   */
  export type CustomerMetricsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerMetrics
     */
    select?: CustomerMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerMetrics
     */
    omit?: CustomerMetricsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerMetricsInclude<ExtArgs> | null
    /**
     * Filter, which CustomerMetrics to fetch.
     */
    where?: CustomerMetricsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerMetrics to fetch.
     */
    orderBy?: CustomerMetricsOrderByWithRelationInput | CustomerMetricsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerMetrics.
     */
    cursor?: CustomerMetricsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerMetrics.
     */
    distinct?: CustomerMetricsScalarFieldEnum | CustomerMetricsScalarFieldEnum[]
  }

  /**
   * CustomerMetrics findFirstOrThrow
   */
  export type CustomerMetricsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerMetrics
     */
    select?: CustomerMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerMetrics
     */
    omit?: CustomerMetricsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerMetricsInclude<ExtArgs> | null
    /**
     * Filter, which CustomerMetrics to fetch.
     */
    where?: CustomerMetricsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerMetrics to fetch.
     */
    orderBy?: CustomerMetricsOrderByWithRelationInput | CustomerMetricsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerMetrics.
     */
    cursor?: CustomerMetricsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerMetrics.
     */
    distinct?: CustomerMetricsScalarFieldEnum | CustomerMetricsScalarFieldEnum[]
  }

  /**
   * CustomerMetrics findMany
   */
  export type CustomerMetricsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerMetrics
     */
    select?: CustomerMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerMetrics
     */
    omit?: CustomerMetricsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerMetricsInclude<ExtArgs> | null
    /**
     * Filter, which CustomerMetrics to fetch.
     */
    where?: CustomerMetricsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerMetrics to fetch.
     */
    orderBy?: CustomerMetricsOrderByWithRelationInput | CustomerMetricsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CustomerMetrics.
     */
    cursor?: CustomerMetricsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerMetrics.
     */
    skip?: number
    distinct?: CustomerMetricsScalarFieldEnum | CustomerMetricsScalarFieldEnum[]
  }

  /**
   * CustomerMetrics create
   */
  export type CustomerMetricsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerMetrics
     */
    select?: CustomerMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerMetrics
     */
    omit?: CustomerMetricsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerMetricsInclude<ExtArgs> | null
    /**
     * The data needed to create a CustomerMetrics.
     */
    data: XOR<CustomerMetricsCreateInput, CustomerMetricsUncheckedCreateInput>
  }

  /**
   * CustomerMetrics createMany
   */
  export type CustomerMetricsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CustomerMetrics.
     */
    data: CustomerMetricsCreateManyInput | CustomerMetricsCreateManyInput[]
  }

  /**
   * CustomerMetrics createManyAndReturn
   */
  export type CustomerMetricsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerMetrics
     */
    select?: CustomerMetricsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerMetrics
     */
    omit?: CustomerMetricsOmit<ExtArgs> | null
    /**
     * The data used to create many CustomerMetrics.
     */
    data: CustomerMetricsCreateManyInput | CustomerMetricsCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerMetricsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CustomerMetrics update
   */
  export type CustomerMetricsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerMetrics
     */
    select?: CustomerMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerMetrics
     */
    omit?: CustomerMetricsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerMetricsInclude<ExtArgs> | null
    /**
     * The data needed to update a CustomerMetrics.
     */
    data: XOR<CustomerMetricsUpdateInput, CustomerMetricsUncheckedUpdateInput>
    /**
     * Choose, which CustomerMetrics to update.
     */
    where: CustomerMetricsWhereUniqueInput
  }

  /**
   * CustomerMetrics updateMany
   */
  export type CustomerMetricsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CustomerMetrics.
     */
    data: XOR<CustomerMetricsUpdateManyMutationInput, CustomerMetricsUncheckedUpdateManyInput>
    /**
     * Filter which CustomerMetrics to update
     */
    where?: CustomerMetricsWhereInput
    /**
     * Limit how many CustomerMetrics to update.
     */
    limit?: number
  }

  /**
   * CustomerMetrics updateManyAndReturn
   */
  export type CustomerMetricsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerMetrics
     */
    select?: CustomerMetricsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerMetrics
     */
    omit?: CustomerMetricsOmit<ExtArgs> | null
    /**
     * The data used to update CustomerMetrics.
     */
    data: XOR<CustomerMetricsUpdateManyMutationInput, CustomerMetricsUncheckedUpdateManyInput>
    /**
     * Filter which CustomerMetrics to update
     */
    where?: CustomerMetricsWhereInput
    /**
     * Limit how many CustomerMetrics to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerMetricsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CustomerMetrics upsert
   */
  export type CustomerMetricsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerMetrics
     */
    select?: CustomerMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerMetrics
     */
    omit?: CustomerMetricsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerMetricsInclude<ExtArgs> | null
    /**
     * The filter to search for the CustomerMetrics to update in case it exists.
     */
    where: CustomerMetricsWhereUniqueInput
    /**
     * In case the CustomerMetrics found by the `where` argument doesn't exist, create a new CustomerMetrics with this data.
     */
    create: XOR<CustomerMetricsCreateInput, CustomerMetricsUncheckedCreateInput>
    /**
     * In case the CustomerMetrics was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomerMetricsUpdateInput, CustomerMetricsUncheckedUpdateInput>
  }

  /**
   * CustomerMetrics delete
   */
  export type CustomerMetricsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerMetrics
     */
    select?: CustomerMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerMetrics
     */
    omit?: CustomerMetricsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerMetricsInclude<ExtArgs> | null
    /**
     * Filter which CustomerMetrics to delete.
     */
    where: CustomerMetricsWhereUniqueInput
  }

  /**
   * CustomerMetrics deleteMany
   */
  export type CustomerMetricsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomerMetrics to delete
     */
    where?: CustomerMetricsWhereInput
    /**
     * Limit how many CustomerMetrics to delete.
     */
    limit?: number
  }

  /**
   * CustomerMetrics without action
   */
  export type CustomerMetricsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerMetrics
     */
    select?: CustomerMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerMetrics
     */
    omit?: CustomerMetricsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerMetricsInclude<ExtArgs> | null
  }


  /**
   * Model Proposal
   */

  export type AggregateProposal = {
    _count: ProposalCountAggregateOutputType | null
    _avg: ProposalAvgAggregateOutputType | null
    _sum: ProposalSumAggregateOutputType | null
    _min: ProposalMinAggregateOutputType | null
    _max: ProposalMaxAggregateOutputType | null
  }

  export type ProposalAvgAggregateOutputType = {
    totalAmount: number | null
  }

  export type ProposalSumAggregateOutputType = {
    totalAmount: number | null
  }

  export type ProposalMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    status: string | null
    customerPersona: string | null
    voiceTranscript: string | null
    aiSummary: string | null
    totalAmount: number | null
    validUntil: Date | null
    isExistingCustomer: boolean | null
    customerId: string | null
    prospectName: string | null
    prospectCompany: string | null
    prospectEmail: string | null
    prospectPhone: string | null
    prospectStatus: string | null
    propertyId: string | null
    projectId: string | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProposalMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    status: string | null
    customerPersona: string | null
    voiceTranscript: string | null
    aiSummary: string | null
    totalAmount: number | null
    validUntil: Date | null
    isExistingCustomer: boolean | null
    customerId: string | null
    prospectName: string | null
    prospectCompany: string | null
    prospectEmail: string | null
    prospectPhone: string | null
    prospectStatus: string | null
    propertyId: string | null
    projectId: string | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProposalCountAggregateOutputType = {
    id: number
    name: number
    description: number
    status: number
    customerPersona: number
    voiceTranscript: number
    aiSummary: number
    totalAmount: number
    validUntil: number
    isExistingCustomer: number
    customerId: number
    prospectName: number
    prospectCompany: number
    prospectEmail: number
    prospectPhone: number
    prospectStatus: number
    propertyId: number
    projectId: number
    createdBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProposalAvgAggregateInputType = {
    totalAmount?: true
  }

  export type ProposalSumAggregateInputType = {
    totalAmount?: true
  }

  export type ProposalMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    status?: true
    customerPersona?: true
    voiceTranscript?: true
    aiSummary?: true
    totalAmount?: true
    validUntil?: true
    isExistingCustomer?: true
    customerId?: true
    prospectName?: true
    prospectCompany?: true
    prospectEmail?: true
    prospectPhone?: true
    prospectStatus?: true
    propertyId?: true
    projectId?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProposalMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    status?: true
    customerPersona?: true
    voiceTranscript?: true
    aiSummary?: true
    totalAmount?: true
    validUntil?: true
    isExistingCustomer?: true
    customerId?: true
    prospectName?: true
    prospectCompany?: true
    prospectEmail?: true
    prospectPhone?: true
    prospectStatus?: true
    propertyId?: true
    projectId?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProposalCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    status?: true
    customerPersona?: true
    voiceTranscript?: true
    aiSummary?: true
    totalAmount?: true
    validUntil?: true
    isExistingCustomer?: true
    customerId?: true
    prospectName?: true
    prospectCompany?: true
    prospectEmail?: true
    prospectPhone?: true
    prospectStatus?: true
    propertyId?: true
    projectId?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProposalAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Proposal to aggregate.
     */
    where?: ProposalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Proposals to fetch.
     */
    orderBy?: ProposalOrderByWithRelationInput | ProposalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProposalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Proposals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Proposals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Proposals
    **/
    _count?: true | ProposalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProposalAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProposalSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProposalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProposalMaxAggregateInputType
  }

  export type GetProposalAggregateType<T extends ProposalAggregateArgs> = {
        [P in keyof T & keyof AggregateProposal]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProposal[P]>
      : GetScalarType<T[P], AggregateProposal[P]>
  }




  export type ProposalGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProposalWhereInput
    orderBy?: ProposalOrderByWithAggregationInput | ProposalOrderByWithAggregationInput[]
    by: ProposalScalarFieldEnum[] | ProposalScalarFieldEnum
    having?: ProposalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProposalCountAggregateInputType | true
    _avg?: ProposalAvgAggregateInputType
    _sum?: ProposalSumAggregateInputType
    _min?: ProposalMinAggregateInputType
    _max?: ProposalMaxAggregateInputType
  }

  export type ProposalGroupByOutputType = {
    id: string
    name: string
    description: string | null
    status: string
    customerPersona: string
    voiceTranscript: string | null
    aiSummary: string | null
    totalAmount: number
    validUntil: Date | null
    isExistingCustomer: boolean
    customerId: string | null
    prospectName: string | null
    prospectCompany: string | null
    prospectEmail: string | null
    prospectPhone: string | null
    prospectStatus: string | null
    propertyId: string | null
    projectId: string | null
    createdBy: string
    createdAt: Date
    updatedAt: Date
    _count: ProposalCountAggregateOutputType | null
    _avg: ProposalAvgAggregateOutputType | null
    _sum: ProposalSumAggregateOutputType | null
    _min: ProposalMinAggregateOutputType | null
    _max: ProposalMaxAggregateOutputType | null
  }

  type GetProposalGroupByPayload<T extends ProposalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProposalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProposalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProposalGroupByOutputType[P]>
            : GetScalarType<T[P], ProposalGroupByOutputType[P]>
        }
      >
    >


  export type ProposalSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    customerPersona?: boolean
    voiceTranscript?: boolean
    aiSummary?: boolean
    totalAmount?: boolean
    validUntil?: boolean
    isExistingCustomer?: boolean
    customerId?: boolean
    prospectName?: boolean
    prospectCompany?: boolean
    prospectEmail?: boolean
    prospectPhone?: boolean
    prospectStatus?: boolean
    propertyId?: boolean
    projectId?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | Proposal$customerArgs<ExtArgs>
    property?: boolean | Proposal$propertyArgs<ExtArgs>
    project?: boolean | Proposal$projectArgs<ExtArgs>
    items?: boolean | Proposal$itemsArgs<ExtArgs>
    _count?: boolean | ProposalCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["proposal"]>

  export type ProposalSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    customerPersona?: boolean
    voiceTranscript?: boolean
    aiSummary?: boolean
    totalAmount?: boolean
    validUntil?: boolean
    isExistingCustomer?: boolean
    customerId?: boolean
    prospectName?: boolean
    prospectCompany?: boolean
    prospectEmail?: boolean
    prospectPhone?: boolean
    prospectStatus?: boolean
    propertyId?: boolean
    projectId?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | Proposal$customerArgs<ExtArgs>
    property?: boolean | Proposal$propertyArgs<ExtArgs>
    project?: boolean | Proposal$projectArgs<ExtArgs>
  }, ExtArgs["result"]["proposal"]>

  export type ProposalSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    customerPersona?: boolean
    voiceTranscript?: boolean
    aiSummary?: boolean
    totalAmount?: boolean
    validUntil?: boolean
    isExistingCustomer?: boolean
    customerId?: boolean
    prospectName?: boolean
    prospectCompany?: boolean
    prospectEmail?: boolean
    prospectPhone?: boolean
    prospectStatus?: boolean
    propertyId?: boolean
    projectId?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | Proposal$customerArgs<ExtArgs>
    property?: boolean | Proposal$propertyArgs<ExtArgs>
    project?: boolean | Proposal$projectArgs<ExtArgs>
  }, ExtArgs["result"]["proposal"]>

  export type ProposalSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    customerPersona?: boolean
    voiceTranscript?: boolean
    aiSummary?: boolean
    totalAmount?: boolean
    validUntil?: boolean
    isExistingCustomer?: boolean
    customerId?: boolean
    prospectName?: boolean
    prospectCompany?: boolean
    prospectEmail?: boolean
    prospectPhone?: boolean
    prospectStatus?: boolean
    propertyId?: boolean
    projectId?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProposalOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "status" | "customerPersona" | "voiceTranscript" | "aiSummary" | "totalAmount" | "validUntil" | "isExistingCustomer" | "customerId" | "prospectName" | "prospectCompany" | "prospectEmail" | "prospectPhone" | "prospectStatus" | "propertyId" | "projectId" | "createdBy" | "createdAt" | "updatedAt", ExtArgs["result"]["proposal"]>
  export type ProposalInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | Proposal$customerArgs<ExtArgs>
    property?: boolean | Proposal$propertyArgs<ExtArgs>
    project?: boolean | Proposal$projectArgs<ExtArgs>
    items?: boolean | Proposal$itemsArgs<ExtArgs>
    _count?: boolean | ProposalCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProposalIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | Proposal$customerArgs<ExtArgs>
    property?: boolean | Proposal$propertyArgs<ExtArgs>
    project?: boolean | Proposal$projectArgs<ExtArgs>
  }
  export type ProposalIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | Proposal$customerArgs<ExtArgs>
    property?: boolean | Proposal$propertyArgs<ExtArgs>
    project?: boolean | Proposal$projectArgs<ExtArgs>
  }

  export type $ProposalPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Proposal"
    objects: {
      customer: Prisma.$CustomerPayload<ExtArgs> | null
      property: Prisma.$PropertyPayload<ExtArgs> | null
      project: Prisma.$ProjectPayload<ExtArgs> | null
      items: Prisma.$ProposalItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      status: string
      customerPersona: string
      voiceTranscript: string | null
      aiSummary: string | null
      totalAmount: number
      validUntil: Date | null
      isExistingCustomer: boolean
      customerId: string | null
      prospectName: string | null
      prospectCompany: string | null
      prospectEmail: string | null
      prospectPhone: string | null
      prospectStatus: string | null
      propertyId: string | null
      projectId: string | null
      createdBy: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["proposal"]>
    composites: {}
  }

  type ProposalGetPayload<S extends boolean | null | undefined | ProposalDefaultArgs> = $Result.GetResult<Prisma.$ProposalPayload, S>

  type ProposalCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProposalFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProposalCountAggregateInputType | true
    }

  export interface ProposalDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Proposal'], meta: { name: 'Proposal' } }
    /**
     * Find zero or one Proposal that matches the filter.
     * @param {ProposalFindUniqueArgs} args - Arguments to find a Proposal
     * @example
     * // Get one Proposal
     * const proposal = await prisma.proposal.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProposalFindUniqueArgs>(args: SelectSubset<T, ProposalFindUniqueArgs<ExtArgs>>): Prisma__ProposalClient<$Result.GetResult<Prisma.$ProposalPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Proposal that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProposalFindUniqueOrThrowArgs} args - Arguments to find a Proposal
     * @example
     * // Get one Proposal
     * const proposal = await prisma.proposal.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProposalFindUniqueOrThrowArgs>(args: SelectSubset<T, ProposalFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProposalClient<$Result.GetResult<Prisma.$ProposalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Proposal that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProposalFindFirstArgs} args - Arguments to find a Proposal
     * @example
     * // Get one Proposal
     * const proposal = await prisma.proposal.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProposalFindFirstArgs>(args?: SelectSubset<T, ProposalFindFirstArgs<ExtArgs>>): Prisma__ProposalClient<$Result.GetResult<Prisma.$ProposalPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Proposal that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProposalFindFirstOrThrowArgs} args - Arguments to find a Proposal
     * @example
     * // Get one Proposal
     * const proposal = await prisma.proposal.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProposalFindFirstOrThrowArgs>(args?: SelectSubset<T, ProposalFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProposalClient<$Result.GetResult<Prisma.$ProposalPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Proposals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProposalFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Proposals
     * const proposals = await prisma.proposal.findMany()
     * 
     * // Get first 10 Proposals
     * const proposals = await prisma.proposal.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const proposalWithIdOnly = await prisma.proposal.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProposalFindManyArgs>(args?: SelectSubset<T, ProposalFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProposalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Proposal.
     * @param {ProposalCreateArgs} args - Arguments to create a Proposal.
     * @example
     * // Create one Proposal
     * const Proposal = await prisma.proposal.create({
     *   data: {
     *     // ... data to create a Proposal
     *   }
     * })
     * 
     */
    create<T extends ProposalCreateArgs>(args: SelectSubset<T, ProposalCreateArgs<ExtArgs>>): Prisma__ProposalClient<$Result.GetResult<Prisma.$ProposalPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Proposals.
     * @param {ProposalCreateManyArgs} args - Arguments to create many Proposals.
     * @example
     * // Create many Proposals
     * const proposal = await prisma.proposal.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProposalCreateManyArgs>(args?: SelectSubset<T, ProposalCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Proposals and returns the data saved in the database.
     * @param {ProposalCreateManyAndReturnArgs} args - Arguments to create many Proposals.
     * @example
     * // Create many Proposals
     * const proposal = await prisma.proposal.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Proposals and only return the `id`
     * const proposalWithIdOnly = await prisma.proposal.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProposalCreateManyAndReturnArgs>(args?: SelectSubset<T, ProposalCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProposalPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Proposal.
     * @param {ProposalDeleteArgs} args - Arguments to delete one Proposal.
     * @example
     * // Delete one Proposal
     * const Proposal = await prisma.proposal.delete({
     *   where: {
     *     // ... filter to delete one Proposal
     *   }
     * })
     * 
     */
    delete<T extends ProposalDeleteArgs>(args: SelectSubset<T, ProposalDeleteArgs<ExtArgs>>): Prisma__ProposalClient<$Result.GetResult<Prisma.$ProposalPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Proposal.
     * @param {ProposalUpdateArgs} args - Arguments to update one Proposal.
     * @example
     * // Update one Proposal
     * const proposal = await prisma.proposal.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProposalUpdateArgs>(args: SelectSubset<T, ProposalUpdateArgs<ExtArgs>>): Prisma__ProposalClient<$Result.GetResult<Prisma.$ProposalPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Proposals.
     * @param {ProposalDeleteManyArgs} args - Arguments to filter Proposals to delete.
     * @example
     * // Delete a few Proposals
     * const { count } = await prisma.proposal.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProposalDeleteManyArgs>(args?: SelectSubset<T, ProposalDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Proposals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProposalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Proposals
     * const proposal = await prisma.proposal.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProposalUpdateManyArgs>(args: SelectSubset<T, ProposalUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Proposals and returns the data updated in the database.
     * @param {ProposalUpdateManyAndReturnArgs} args - Arguments to update many Proposals.
     * @example
     * // Update many Proposals
     * const proposal = await prisma.proposal.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Proposals and only return the `id`
     * const proposalWithIdOnly = await prisma.proposal.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProposalUpdateManyAndReturnArgs>(args: SelectSubset<T, ProposalUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProposalPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Proposal.
     * @param {ProposalUpsertArgs} args - Arguments to update or create a Proposal.
     * @example
     * // Update or create a Proposal
     * const proposal = await prisma.proposal.upsert({
     *   create: {
     *     // ... data to create a Proposal
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Proposal we want to update
     *   }
     * })
     */
    upsert<T extends ProposalUpsertArgs>(args: SelectSubset<T, ProposalUpsertArgs<ExtArgs>>): Prisma__ProposalClient<$Result.GetResult<Prisma.$ProposalPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Proposals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProposalCountArgs} args - Arguments to filter Proposals to count.
     * @example
     * // Count the number of Proposals
     * const count = await prisma.proposal.count({
     *   where: {
     *     // ... the filter for the Proposals we want to count
     *   }
     * })
    **/
    count<T extends ProposalCountArgs>(
      args?: Subset<T, ProposalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProposalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Proposal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProposalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProposalAggregateArgs>(args: Subset<T, ProposalAggregateArgs>): Prisma.PrismaPromise<GetProposalAggregateType<T>>

    /**
     * Group by Proposal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProposalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProposalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProposalGroupByArgs['orderBy'] }
        : { orderBy?: ProposalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProposalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProposalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Proposal model
   */
  readonly fields: ProposalFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Proposal.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProposalClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customer<T extends Proposal$customerArgs<ExtArgs> = {}>(args?: Subset<T, Proposal$customerArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    property<T extends Proposal$propertyArgs<ExtArgs> = {}>(args?: Subset<T, Proposal$propertyArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    project<T extends Proposal$projectArgs<ExtArgs> = {}>(args?: Subset<T, Proposal$projectArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    items<T extends Proposal$itemsArgs<ExtArgs> = {}>(args?: Subset<T, Proposal$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProposalItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Proposal model
   */
  interface ProposalFieldRefs {
    readonly id: FieldRef<"Proposal", 'String'>
    readonly name: FieldRef<"Proposal", 'String'>
    readonly description: FieldRef<"Proposal", 'String'>
    readonly status: FieldRef<"Proposal", 'String'>
    readonly customerPersona: FieldRef<"Proposal", 'String'>
    readonly voiceTranscript: FieldRef<"Proposal", 'String'>
    readonly aiSummary: FieldRef<"Proposal", 'String'>
    readonly totalAmount: FieldRef<"Proposal", 'Float'>
    readonly validUntil: FieldRef<"Proposal", 'DateTime'>
    readonly isExistingCustomer: FieldRef<"Proposal", 'Boolean'>
    readonly customerId: FieldRef<"Proposal", 'String'>
    readonly prospectName: FieldRef<"Proposal", 'String'>
    readonly prospectCompany: FieldRef<"Proposal", 'String'>
    readonly prospectEmail: FieldRef<"Proposal", 'String'>
    readonly prospectPhone: FieldRef<"Proposal", 'String'>
    readonly prospectStatus: FieldRef<"Proposal", 'String'>
    readonly propertyId: FieldRef<"Proposal", 'String'>
    readonly projectId: FieldRef<"Proposal", 'String'>
    readonly createdBy: FieldRef<"Proposal", 'String'>
    readonly createdAt: FieldRef<"Proposal", 'DateTime'>
    readonly updatedAt: FieldRef<"Proposal", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Proposal findUnique
   */
  export type ProposalFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proposal
     */
    select?: ProposalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Proposal
     */
    omit?: ProposalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalInclude<ExtArgs> | null
    /**
     * Filter, which Proposal to fetch.
     */
    where: ProposalWhereUniqueInput
  }

  /**
   * Proposal findUniqueOrThrow
   */
  export type ProposalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proposal
     */
    select?: ProposalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Proposal
     */
    omit?: ProposalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalInclude<ExtArgs> | null
    /**
     * Filter, which Proposal to fetch.
     */
    where: ProposalWhereUniqueInput
  }

  /**
   * Proposal findFirst
   */
  export type ProposalFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proposal
     */
    select?: ProposalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Proposal
     */
    omit?: ProposalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalInclude<ExtArgs> | null
    /**
     * Filter, which Proposal to fetch.
     */
    where?: ProposalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Proposals to fetch.
     */
    orderBy?: ProposalOrderByWithRelationInput | ProposalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Proposals.
     */
    cursor?: ProposalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Proposals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Proposals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Proposals.
     */
    distinct?: ProposalScalarFieldEnum | ProposalScalarFieldEnum[]
  }

  /**
   * Proposal findFirstOrThrow
   */
  export type ProposalFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proposal
     */
    select?: ProposalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Proposal
     */
    omit?: ProposalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalInclude<ExtArgs> | null
    /**
     * Filter, which Proposal to fetch.
     */
    where?: ProposalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Proposals to fetch.
     */
    orderBy?: ProposalOrderByWithRelationInput | ProposalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Proposals.
     */
    cursor?: ProposalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Proposals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Proposals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Proposals.
     */
    distinct?: ProposalScalarFieldEnum | ProposalScalarFieldEnum[]
  }

  /**
   * Proposal findMany
   */
  export type ProposalFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proposal
     */
    select?: ProposalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Proposal
     */
    omit?: ProposalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalInclude<ExtArgs> | null
    /**
     * Filter, which Proposals to fetch.
     */
    where?: ProposalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Proposals to fetch.
     */
    orderBy?: ProposalOrderByWithRelationInput | ProposalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Proposals.
     */
    cursor?: ProposalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Proposals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Proposals.
     */
    skip?: number
    distinct?: ProposalScalarFieldEnum | ProposalScalarFieldEnum[]
  }

  /**
   * Proposal create
   */
  export type ProposalCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proposal
     */
    select?: ProposalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Proposal
     */
    omit?: ProposalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalInclude<ExtArgs> | null
    /**
     * The data needed to create a Proposal.
     */
    data: XOR<ProposalCreateInput, ProposalUncheckedCreateInput>
  }

  /**
   * Proposal createMany
   */
  export type ProposalCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Proposals.
     */
    data: ProposalCreateManyInput | ProposalCreateManyInput[]
  }

  /**
   * Proposal createManyAndReturn
   */
  export type ProposalCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proposal
     */
    select?: ProposalSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Proposal
     */
    omit?: ProposalOmit<ExtArgs> | null
    /**
     * The data used to create many Proposals.
     */
    data: ProposalCreateManyInput | ProposalCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Proposal update
   */
  export type ProposalUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proposal
     */
    select?: ProposalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Proposal
     */
    omit?: ProposalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalInclude<ExtArgs> | null
    /**
     * The data needed to update a Proposal.
     */
    data: XOR<ProposalUpdateInput, ProposalUncheckedUpdateInput>
    /**
     * Choose, which Proposal to update.
     */
    where: ProposalWhereUniqueInput
  }

  /**
   * Proposal updateMany
   */
  export type ProposalUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Proposals.
     */
    data: XOR<ProposalUpdateManyMutationInput, ProposalUncheckedUpdateManyInput>
    /**
     * Filter which Proposals to update
     */
    where?: ProposalWhereInput
    /**
     * Limit how many Proposals to update.
     */
    limit?: number
  }

  /**
   * Proposal updateManyAndReturn
   */
  export type ProposalUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proposal
     */
    select?: ProposalSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Proposal
     */
    omit?: ProposalOmit<ExtArgs> | null
    /**
     * The data used to update Proposals.
     */
    data: XOR<ProposalUpdateManyMutationInput, ProposalUncheckedUpdateManyInput>
    /**
     * Filter which Proposals to update
     */
    where?: ProposalWhereInput
    /**
     * Limit how many Proposals to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Proposal upsert
   */
  export type ProposalUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proposal
     */
    select?: ProposalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Proposal
     */
    omit?: ProposalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalInclude<ExtArgs> | null
    /**
     * The filter to search for the Proposal to update in case it exists.
     */
    where: ProposalWhereUniqueInput
    /**
     * In case the Proposal found by the `where` argument doesn't exist, create a new Proposal with this data.
     */
    create: XOR<ProposalCreateInput, ProposalUncheckedCreateInput>
    /**
     * In case the Proposal was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProposalUpdateInput, ProposalUncheckedUpdateInput>
  }

  /**
   * Proposal delete
   */
  export type ProposalDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proposal
     */
    select?: ProposalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Proposal
     */
    omit?: ProposalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalInclude<ExtArgs> | null
    /**
     * Filter which Proposal to delete.
     */
    where: ProposalWhereUniqueInput
  }

  /**
   * Proposal deleteMany
   */
  export type ProposalDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Proposals to delete
     */
    where?: ProposalWhereInput
    /**
     * Limit how many Proposals to delete.
     */
    limit?: number
  }

  /**
   * Proposal.customer
   */
  export type Proposal$customerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    where?: CustomerWhereInput
  }

  /**
   * Proposal.property
   */
  export type Proposal$propertyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    where?: PropertyWhereInput
  }

  /**
   * Proposal.project
   */
  export type Proposal$projectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
  }

  /**
   * Proposal.items
   */
  export type Proposal$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProposalItem
     */
    select?: ProposalItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProposalItem
     */
    omit?: ProposalItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalItemInclude<ExtArgs> | null
    where?: ProposalItemWhereInput
    orderBy?: ProposalItemOrderByWithRelationInput | ProposalItemOrderByWithRelationInput[]
    cursor?: ProposalItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProposalItemScalarFieldEnum | ProposalItemScalarFieldEnum[]
  }

  /**
   * Proposal without action
   */
  export type ProposalDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proposal
     */
    select?: ProposalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Proposal
     */
    omit?: ProposalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalInclude<ExtArgs> | null
  }


  /**
   * Model ProposalItem
   */

  export type AggregateProposalItem = {
    _count: ProposalItemCountAggregateOutputType | null
    _avg: ProposalItemAvgAggregateOutputType | null
    _sum: ProposalItemSumAggregateOutputType | null
    _min: ProposalItemMinAggregateOutputType | null
    _max: ProposalItemMaxAggregateOutputType | null
  }

  export type ProposalItemAvgAggregateOutputType = {
    quantity: number | null
    unitPrice: number | null
    totalPrice: number | null
    sortOrder: number | null
  }

  export type ProposalItemSumAggregateOutputType = {
    quantity: number | null
    unitPrice: number | null
    totalPrice: number | null
    sortOrder: number | null
  }

  export type ProposalItemMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    category: string | null
    quantity: number | null
    unitPrice: number | null
    totalPrice: number | null
    productId: string | null
    proposalId: string | null
    sortOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProposalItemMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    category: string | null
    quantity: number | null
    unitPrice: number | null
    totalPrice: number | null
    productId: string | null
    proposalId: string | null
    sortOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProposalItemCountAggregateOutputType = {
    id: number
    name: number
    description: number
    category: number
    quantity: number
    unitPrice: number
    totalPrice: number
    productId: number
    proposalId: number
    sortOrder: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProposalItemAvgAggregateInputType = {
    quantity?: true
    unitPrice?: true
    totalPrice?: true
    sortOrder?: true
  }

  export type ProposalItemSumAggregateInputType = {
    quantity?: true
    unitPrice?: true
    totalPrice?: true
    sortOrder?: true
  }

  export type ProposalItemMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    category?: true
    quantity?: true
    unitPrice?: true
    totalPrice?: true
    productId?: true
    proposalId?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProposalItemMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    category?: true
    quantity?: true
    unitPrice?: true
    totalPrice?: true
    productId?: true
    proposalId?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProposalItemCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    category?: true
    quantity?: true
    unitPrice?: true
    totalPrice?: true
    productId?: true
    proposalId?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProposalItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProposalItem to aggregate.
     */
    where?: ProposalItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProposalItems to fetch.
     */
    orderBy?: ProposalItemOrderByWithRelationInput | ProposalItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProposalItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProposalItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProposalItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProposalItems
    **/
    _count?: true | ProposalItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProposalItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProposalItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProposalItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProposalItemMaxAggregateInputType
  }

  export type GetProposalItemAggregateType<T extends ProposalItemAggregateArgs> = {
        [P in keyof T & keyof AggregateProposalItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProposalItem[P]>
      : GetScalarType<T[P], AggregateProposalItem[P]>
  }




  export type ProposalItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProposalItemWhereInput
    orderBy?: ProposalItemOrderByWithAggregationInput | ProposalItemOrderByWithAggregationInput[]
    by: ProposalItemScalarFieldEnum[] | ProposalItemScalarFieldEnum
    having?: ProposalItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProposalItemCountAggregateInputType | true
    _avg?: ProposalItemAvgAggregateInputType
    _sum?: ProposalItemSumAggregateInputType
    _min?: ProposalItemMinAggregateInputType
    _max?: ProposalItemMaxAggregateInputType
  }

  export type ProposalItemGroupByOutputType = {
    id: string
    name: string
    description: string | null
    category: string
    quantity: number
    unitPrice: number
    totalPrice: number
    productId: string | null
    proposalId: string
    sortOrder: number
    createdAt: Date
    updatedAt: Date
    _count: ProposalItemCountAggregateOutputType | null
    _avg: ProposalItemAvgAggregateOutputType | null
    _sum: ProposalItemSumAggregateOutputType | null
    _min: ProposalItemMinAggregateOutputType | null
    _max: ProposalItemMaxAggregateOutputType | null
  }

  type GetProposalItemGroupByPayload<T extends ProposalItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProposalItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProposalItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProposalItemGroupByOutputType[P]>
            : GetScalarType<T[P], ProposalItemGroupByOutputType[P]>
        }
      >
    >


  export type ProposalItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    quantity?: boolean
    unitPrice?: boolean
    totalPrice?: boolean
    productId?: boolean
    proposalId?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | ProposalItem$productArgs<ExtArgs>
    proposal?: boolean | ProposalDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["proposalItem"]>

  export type ProposalItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    quantity?: boolean
    unitPrice?: boolean
    totalPrice?: boolean
    productId?: boolean
    proposalId?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | ProposalItem$productArgs<ExtArgs>
    proposal?: boolean | ProposalDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["proposalItem"]>

  export type ProposalItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    quantity?: boolean
    unitPrice?: boolean
    totalPrice?: boolean
    productId?: boolean
    proposalId?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | ProposalItem$productArgs<ExtArgs>
    proposal?: boolean | ProposalDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["proposalItem"]>

  export type ProposalItemSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    quantity?: boolean
    unitPrice?: boolean
    totalPrice?: boolean
    productId?: boolean
    proposalId?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProposalItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "category" | "quantity" | "unitPrice" | "totalPrice" | "productId" | "proposalId" | "sortOrder" | "createdAt" | "updatedAt", ExtArgs["result"]["proposalItem"]>
  export type ProposalItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProposalItem$productArgs<ExtArgs>
    proposal?: boolean | ProposalDefaultArgs<ExtArgs>
  }
  export type ProposalItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProposalItem$productArgs<ExtArgs>
    proposal?: boolean | ProposalDefaultArgs<ExtArgs>
  }
  export type ProposalItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProposalItem$productArgs<ExtArgs>
    proposal?: boolean | ProposalDefaultArgs<ExtArgs>
  }

  export type $ProposalItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProposalItem"
    objects: {
      product: Prisma.$ProductPayload<ExtArgs> | null
      proposal: Prisma.$ProposalPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      category: string
      quantity: number
      unitPrice: number
      totalPrice: number
      productId: string | null
      proposalId: string
      sortOrder: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["proposalItem"]>
    composites: {}
  }

  type ProposalItemGetPayload<S extends boolean | null | undefined | ProposalItemDefaultArgs> = $Result.GetResult<Prisma.$ProposalItemPayload, S>

  type ProposalItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProposalItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProposalItemCountAggregateInputType | true
    }

  export interface ProposalItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProposalItem'], meta: { name: 'ProposalItem' } }
    /**
     * Find zero or one ProposalItem that matches the filter.
     * @param {ProposalItemFindUniqueArgs} args - Arguments to find a ProposalItem
     * @example
     * // Get one ProposalItem
     * const proposalItem = await prisma.proposalItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProposalItemFindUniqueArgs>(args: SelectSubset<T, ProposalItemFindUniqueArgs<ExtArgs>>): Prisma__ProposalItemClient<$Result.GetResult<Prisma.$ProposalItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProposalItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProposalItemFindUniqueOrThrowArgs} args - Arguments to find a ProposalItem
     * @example
     * // Get one ProposalItem
     * const proposalItem = await prisma.proposalItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProposalItemFindUniqueOrThrowArgs>(args: SelectSubset<T, ProposalItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProposalItemClient<$Result.GetResult<Prisma.$ProposalItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProposalItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProposalItemFindFirstArgs} args - Arguments to find a ProposalItem
     * @example
     * // Get one ProposalItem
     * const proposalItem = await prisma.proposalItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProposalItemFindFirstArgs>(args?: SelectSubset<T, ProposalItemFindFirstArgs<ExtArgs>>): Prisma__ProposalItemClient<$Result.GetResult<Prisma.$ProposalItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProposalItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProposalItemFindFirstOrThrowArgs} args - Arguments to find a ProposalItem
     * @example
     * // Get one ProposalItem
     * const proposalItem = await prisma.proposalItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProposalItemFindFirstOrThrowArgs>(args?: SelectSubset<T, ProposalItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProposalItemClient<$Result.GetResult<Prisma.$ProposalItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProposalItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProposalItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProposalItems
     * const proposalItems = await prisma.proposalItem.findMany()
     * 
     * // Get first 10 ProposalItems
     * const proposalItems = await prisma.proposalItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const proposalItemWithIdOnly = await prisma.proposalItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProposalItemFindManyArgs>(args?: SelectSubset<T, ProposalItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProposalItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProposalItem.
     * @param {ProposalItemCreateArgs} args - Arguments to create a ProposalItem.
     * @example
     * // Create one ProposalItem
     * const ProposalItem = await prisma.proposalItem.create({
     *   data: {
     *     // ... data to create a ProposalItem
     *   }
     * })
     * 
     */
    create<T extends ProposalItemCreateArgs>(args: SelectSubset<T, ProposalItemCreateArgs<ExtArgs>>): Prisma__ProposalItemClient<$Result.GetResult<Prisma.$ProposalItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProposalItems.
     * @param {ProposalItemCreateManyArgs} args - Arguments to create many ProposalItems.
     * @example
     * // Create many ProposalItems
     * const proposalItem = await prisma.proposalItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProposalItemCreateManyArgs>(args?: SelectSubset<T, ProposalItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProposalItems and returns the data saved in the database.
     * @param {ProposalItemCreateManyAndReturnArgs} args - Arguments to create many ProposalItems.
     * @example
     * // Create many ProposalItems
     * const proposalItem = await prisma.proposalItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProposalItems and only return the `id`
     * const proposalItemWithIdOnly = await prisma.proposalItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProposalItemCreateManyAndReturnArgs>(args?: SelectSubset<T, ProposalItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProposalItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProposalItem.
     * @param {ProposalItemDeleteArgs} args - Arguments to delete one ProposalItem.
     * @example
     * // Delete one ProposalItem
     * const ProposalItem = await prisma.proposalItem.delete({
     *   where: {
     *     // ... filter to delete one ProposalItem
     *   }
     * })
     * 
     */
    delete<T extends ProposalItemDeleteArgs>(args: SelectSubset<T, ProposalItemDeleteArgs<ExtArgs>>): Prisma__ProposalItemClient<$Result.GetResult<Prisma.$ProposalItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProposalItem.
     * @param {ProposalItemUpdateArgs} args - Arguments to update one ProposalItem.
     * @example
     * // Update one ProposalItem
     * const proposalItem = await prisma.proposalItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProposalItemUpdateArgs>(args: SelectSubset<T, ProposalItemUpdateArgs<ExtArgs>>): Prisma__ProposalItemClient<$Result.GetResult<Prisma.$ProposalItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProposalItems.
     * @param {ProposalItemDeleteManyArgs} args - Arguments to filter ProposalItems to delete.
     * @example
     * // Delete a few ProposalItems
     * const { count } = await prisma.proposalItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProposalItemDeleteManyArgs>(args?: SelectSubset<T, ProposalItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProposalItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProposalItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProposalItems
     * const proposalItem = await prisma.proposalItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProposalItemUpdateManyArgs>(args: SelectSubset<T, ProposalItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProposalItems and returns the data updated in the database.
     * @param {ProposalItemUpdateManyAndReturnArgs} args - Arguments to update many ProposalItems.
     * @example
     * // Update many ProposalItems
     * const proposalItem = await prisma.proposalItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProposalItems and only return the `id`
     * const proposalItemWithIdOnly = await prisma.proposalItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProposalItemUpdateManyAndReturnArgs>(args: SelectSubset<T, ProposalItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProposalItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProposalItem.
     * @param {ProposalItemUpsertArgs} args - Arguments to update or create a ProposalItem.
     * @example
     * // Update or create a ProposalItem
     * const proposalItem = await prisma.proposalItem.upsert({
     *   create: {
     *     // ... data to create a ProposalItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProposalItem we want to update
     *   }
     * })
     */
    upsert<T extends ProposalItemUpsertArgs>(args: SelectSubset<T, ProposalItemUpsertArgs<ExtArgs>>): Prisma__ProposalItemClient<$Result.GetResult<Prisma.$ProposalItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProposalItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProposalItemCountArgs} args - Arguments to filter ProposalItems to count.
     * @example
     * // Count the number of ProposalItems
     * const count = await prisma.proposalItem.count({
     *   where: {
     *     // ... the filter for the ProposalItems we want to count
     *   }
     * })
    **/
    count<T extends ProposalItemCountArgs>(
      args?: Subset<T, ProposalItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProposalItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProposalItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProposalItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProposalItemAggregateArgs>(args: Subset<T, ProposalItemAggregateArgs>): Prisma.PrismaPromise<GetProposalItemAggregateType<T>>

    /**
     * Group by ProposalItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProposalItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProposalItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProposalItemGroupByArgs['orderBy'] }
        : { orderBy?: ProposalItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProposalItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProposalItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProposalItem model
   */
  readonly fields: ProposalItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProposalItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProposalItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends ProposalItem$productArgs<ExtArgs> = {}>(args?: Subset<T, ProposalItem$productArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    proposal<T extends ProposalDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProposalDefaultArgs<ExtArgs>>): Prisma__ProposalClient<$Result.GetResult<Prisma.$ProposalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProposalItem model
   */
  interface ProposalItemFieldRefs {
    readonly id: FieldRef<"ProposalItem", 'String'>
    readonly name: FieldRef<"ProposalItem", 'String'>
    readonly description: FieldRef<"ProposalItem", 'String'>
    readonly category: FieldRef<"ProposalItem", 'String'>
    readonly quantity: FieldRef<"ProposalItem", 'Int'>
    readonly unitPrice: FieldRef<"ProposalItem", 'Float'>
    readonly totalPrice: FieldRef<"ProposalItem", 'Float'>
    readonly productId: FieldRef<"ProposalItem", 'String'>
    readonly proposalId: FieldRef<"ProposalItem", 'String'>
    readonly sortOrder: FieldRef<"ProposalItem", 'Int'>
    readonly createdAt: FieldRef<"ProposalItem", 'DateTime'>
    readonly updatedAt: FieldRef<"ProposalItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProposalItem findUnique
   */
  export type ProposalItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProposalItem
     */
    select?: ProposalItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProposalItem
     */
    omit?: ProposalItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalItemInclude<ExtArgs> | null
    /**
     * Filter, which ProposalItem to fetch.
     */
    where: ProposalItemWhereUniqueInput
  }

  /**
   * ProposalItem findUniqueOrThrow
   */
  export type ProposalItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProposalItem
     */
    select?: ProposalItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProposalItem
     */
    omit?: ProposalItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalItemInclude<ExtArgs> | null
    /**
     * Filter, which ProposalItem to fetch.
     */
    where: ProposalItemWhereUniqueInput
  }

  /**
   * ProposalItem findFirst
   */
  export type ProposalItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProposalItem
     */
    select?: ProposalItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProposalItem
     */
    omit?: ProposalItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalItemInclude<ExtArgs> | null
    /**
     * Filter, which ProposalItem to fetch.
     */
    where?: ProposalItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProposalItems to fetch.
     */
    orderBy?: ProposalItemOrderByWithRelationInput | ProposalItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProposalItems.
     */
    cursor?: ProposalItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProposalItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProposalItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProposalItems.
     */
    distinct?: ProposalItemScalarFieldEnum | ProposalItemScalarFieldEnum[]
  }

  /**
   * ProposalItem findFirstOrThrow
   */
  export type ProposalItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProposalItem
     */
    select?: ProposalItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProposalItem
     */
    omit?: ProposalItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalItemInclude<ExtArgs> | null
    /**
     * Filter, which ProposalItem to fetch.
     */
    where?: ProposalItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProposalItems to fetch.
     */
    orderBy?: ProposalItemOrderByWithRelationInput | ProposalItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProposalItems.
     */
    cursor?: ProposalItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProposalItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProposalItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProposalItems.
     */
    distinct?: ProposalItemScalarFieldEnum | ProposalItemScalarFieldEnum[]
  }

  /**
   * ProposalItem findMany
   */
  export type ProposalItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProposalItem
     */
    select?: ProposalItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProposalItem
     */
    omit?: ProposalItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalItemInclude<ExtArgs> | null
    /**
     * Filter, which ProposalItems to fetch.
     */
    where?: ProposalItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProposalItems to fetch.
     */
    orderBy?: ProposalItemOrderByWithRelationInput | ProposalItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProposalItems.
     */
    cursor?: ProposalItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProposalItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProposalItems.
     */
    skip?: number
    distinct?: ProposalItemScalarFieldEnum | ProposalItemScalarFieldEnum[]
  }

  /**
   * ProposalItem create
   */
  export type ProposalItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProposalItem
     */
    select?: ProposalItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProposalItem
     */
    omit?: ProposalItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalItemInclude<ExtArgs> | null
    /**
     * The data needed to create a ProposalItem.
     */
    data: XOR<ProposalItemCreateInput, ProposalItemUncheckedCreateInput>
  }

  /**
   * ProposalItem createMany
   */
  export type ProposalItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProposalItems.
     */
    data: ProposalItemCreateManyInput | ProposalItemCreateManyInput[]
  }

  /**
   * ProposalItem createManyAndReturn
   */
  export type ProposalItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProposalItem
     */
    select?: ProposalItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProposalItem
     */
    omit?: ProposalItemOmit<ExtArgs> | null
    /**
     * The data used to create many ProposalItems.
     */
    data: ProposalItemCreateManyInput | ProposalItemCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProposalItem update
   */
  export type ProposalItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProposalItem
     */
    select?: ProposalItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProposalItem
     */
    omit?: ProposalItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalItemInclude<ExtArgs> | null
    /**
     * The data needed to update a ProposalItem.
     */
    data: XOR<ProposalItemUpdateInput, ProposalItemUncheckedUpdateInput>
    /**
     * Choose, which ProposalItem to update.
     */
    where: ProposalItemWhereUniqueInput
  }

  /**
   * ProposalItem updateMany
   */
  export type ProposalItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProposalItems.
     */
    data: XOR<ProposalItemUpdateManyMutationInput, ProposalItemUncheckedUpdateManyInput>
    /**
     * Filter which ProposalItems to update
     */
    where?: ProposalItemWhereInput
    /**
     * Limit how many ProposalItems to update.
     */
    limit?: number
  }

  /**
   * ProposalItem updateManyAndReturn
   */
  export type ProposalItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProposalItem
     */
    select?: ProposalItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProposalItem
     */
    omit?: ProposalItemOmit<ExtArgs> | null
    /**
     * The data used to update ProposalItems.
     */
    data: XOR<ProposalItemUpdateManyMutationInput, ProposalItemUncheckedUpdateManyInput>
    /**
     * Filter which ProposalItems to update
     */
    where?: ProposalItemWhereInput
    /**
     * Limit how many ProposalItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProposalItem upsert
   */
  export type ProposalItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProposalItem
     */
    select?: ProposalItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProposalItem
     */
    omit?: ProposalItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalItemInclude<ExtArgs> | null
    /**
     * The filter to search for the ProposalItem to update in case it exists.
     */
    where: ProposalItemWhereUniqueInput
    /**
     * In case the ProposalItem found by the `where` argument doesn't exist, create a new ProposalItem with this data.
     */
    create: XOR<ProposalItemCreateInput, ProposalItemUncheckedCreateInput>
    /**
     * In case the ProposalItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProposalItemUpdateInput, ProposalItemUncheckedUpdateInput>
  }

  /**
   * ProposalItem delete
   */
  export type ProposalItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProposalItem
     */
    select?: ProposalItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProposalItem
     */
    omit?: ProposalItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalItemInclude<ExtArgs> | null
    /**
     * Filter which ProposalItem to delete.
     */
    where: ProposalItemWhereUniqueInput
  }

  /**
   * ProposalItem deleteMany
   */
  export type ProposalItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProposalItems to delete
     */
    where?: ProposalItemWhereInput
    /**
     * Limit how many ProposalItems to delete.
     */
    limit?: number
  }

  /**
   * ProposalItem.product
   */
  export type ProposalItem$productArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
  }

  /**
   * ProposalItem without action
   */
  export type ProposalItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProposalItem
     */
    select?: ProposalItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProposalItem
     */
    omit?: ProposalItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalItemInclude<ExtArgs> | null
  }


  /**
   * Model Product
   */

  export type AggregateProduct = {
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  export type ProductAvgAggregateOutputType = {
    basePrice: number | null
    goodTierPrice: number | null
    betterTierPrice: number | null
    bestTierPrice: number | null
  }

  export type ProductSumAggregateOutputType = {
    basePrice: number | null
    goodTierPrice: number | null
    betterTierPrice: number | null
    bestTierPrice: number | null
  }

  export type ProductMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    category: string | null
    brand: string | null
    model: string | null
    sku: string | null
    basePrice: number | null
    goodTierPrice: number | null
    betterTierPrice: number | null
    bestTierPrice: number | null
    isActive: boolean | null
    specifications: string | null
    compatibility: string | null
    installation: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    category: string | null
    brand: string | null
    model: string | null
    sku: string | null
    basePrice: number | null
    goodTierPrice: number | null
    betterTierPrice: number | null
    bestTierPrice: number | null
    isActive: boolean | null
    specifications: string | null
    compatibility: string | null
    installation: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductCountAggregateOutputType = {
    id: number
    name: number
    description: number
    category: number
    brand: number
    model: number
    sku: number
    basePrice: number
    goodTierPrice: number
    betterTierPrice: number
    bestTierPrice: number
    isActive: number
    specifications: number
    compatibility: number
    installation: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProductAvgAggregateInputType = {
    basePrice?: true
    goodTierPrice?: true
    betterTierPrice?: true
    bestTierPrice?: true
  }

  export type ProductSumAggregateInputType = {
    basePrice?: true
    goodTierPrice?: true
    betterTierPrice?: true
    bestTierPrice?: true
  }

  export type ProductMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    category?: true
    brand?: true
    model?: true
    sku?: true
    basePrice?: true
    goodTierPrice?: true
    betterTierPrice?: true
    bestTierPrice?: true
    isActive?: true
    specifications?: true
    compatibility?: true
    installation?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    category?: true
    brand?: true
    model?: true
    sku?: true
    basePrice?: true
    goodTierPrice?: true
    betterTierPrice?: true
    bestTierPrice?: true
    isActive?: true
    specifications?: true
    compatibility?: true
    installation?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    category?: true
    brand?: true
    model?: true
    sku?: true
    basePrice?: true
    goodTierPrice?: true
    betterTierPrice?: true
    bestTierPrice?: true
    isActive?: true
    specifications?: true
    compatibility?: true
    installation?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Product to aggregate.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Products
    **/
    _count?: true | ProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductMaxAggregateInputType
  }

  export type GetProductAggregateType<T extends ProductAggregateArgs> = {
        [P in keyof T & keyof AggregateProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct[P]>
      : GetScalarType<T[P], AggregateProduct[P]>
  }




  export type ProductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithAggregationInput | ProductOrderByWithAggregationInput[]
    by: ProductScalarFieldEnum[] | ProductScalarFieldEnum
    having?: ProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCountAggregateInputType | true
    _avg?: ProductAvgAggregateInputType
    _sum?: ProductSumAggregateInputType
    _min?: ProductMinAggregateInputType
    _max?: ProductMaxAggregateInputType
  }

  export type ProductGroupByOutputType = {
    id: string
    name: string
    description: string | null
    category: string
    brand: string | null
    model: string | null
    sku: string | null
    basePrice: number
    goodTierPrice: number | null
    betterTierPrice: number | null
    bestTierPrice: number | null
    isActive: boolean
    specifications: string | null
    compatibility: string | null
    installation: string | null
    createdAt: Date
    updatedAt: Date
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  type GetProductGroupByPayload<T extends ProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductGroupByOutputType[P]>
            : GetScalarType<T[P], ProductGroupByOutputType[P]>
        }
      >
    >


  export type ProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    brand?: boolean
    model?: boolean
    sku?: boolean
    basePrice?: boolean
    goodTierPrice?: boolean
    betterTierPrice?: boolean
    bestTierPrice?: boolean
    isActive?: boolean
    specifications?: boolean
    compatibility?: boolean
    installation?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    proposalItems?: boolean | Product$proposalItemsArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    brand?: boolean
    model?: boolean
    sku?: boolean
    basePrice?: boolean
    goodTierPrice?: boolean
    betterTierPrice?: boolean
    bestTierPrice?: boolean
    isActive?: boolean
    specifications?: boolean
    compatibility?: boolean
    installation?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["product"]>

  export type ProductSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    brand?: boolean
    model?: boolean
    sku?: boolean
    basePrice?: boolean
    goodTierPrice?: boolean
    betterTierPrice?: boolean
    bestTierPrice?: boolean
    isActive?: boolean
    specifications?: boolean
    compatibility?: boolean
    installation?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["product"]>

  export type ProductSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    brand?: boolean
    model?: boolean
    sku?: boolean
    basePrice?: boolean
    goodTierPrice?: boolean
    betterTierPrice?: boolean
    bestTierPrice?: boolean
    isActive?: boolean
    specifications?: boolean
    compatibility?: boolean
    installation?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProductOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "category" | "brand" | "model" | "sku" | "basePrice" | "goodTierPrice" | "betterTierPrice" | "bestTierPrice" | "isActive" | "specifications" | "compatibility" | "installation" | "createdAt" | "updatedAt", ExtArgs["result"]["product"]>
  export type ProductInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    proposalItems?: boolean | Product$proposalItemsArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProductIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ProductIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Product"
    objects: {
      proposalItems: Prisma.$ProposalItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      category: string
      brand: string | null
      model: string | null
      sku: string | null
      basePrice: number
      goodTierPrice: number | null
      betterTierPrice: number | null
      bestTierPrice: number | null
      isActive: boolean
      specifications: string | null
      compatibility: string | null
      installation: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["product"]>
    composites: {}
  }

  type ProductGetPayload<S extends boolean | null | undefined | ProductDefaultArgs> = $Result.GetResult<Prisma.$ProductPayload, S>

  type ProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductCountAggregateInputType | true
    }

  export interface ProductDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Product'], meta: { name: 'Product' } }
    /**
     * Find zero or one Product that matches the filter.
     * @param {ProductFindUniqueArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductFindUniqueArgs>(args: SelectSubset<T, ProductFindUniqueArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Product that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductFindUniqueOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductFindFirstArgs>(args?: SelectSubset<T, ProductFindFirstArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.product.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.product.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productWithIdOnly = await prisma.product.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductFindManyArgs>(args?: SelectSubset<T, ProductFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Product.
     * @param {ProductCreateArgs} args - Arguments to create a Product.
     * @example
     * // Create one Product
     * const Product = await prisma.product.create({
     *   data: {
     *     // ... data to create a Product
     *   }
     * })
     * 
     */
    create<T extends ProductCreateArgs>(args: SelectSubset<T, ProductCreateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Products.
     * @param {ProductCreateManyArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductCreateManyArgs>(args?: SelectSubset<T, ProductCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Products and returns the data saved in the database.
     * @param {ProductCreateManyAndReturnArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Products and only return the `id`
     * const productWithIdOnly = await prisma.product.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Product.
     * @param {ProductDeleteArgs} args - Arguments to delete one Product.
     * @example
     * // Delete one Product
     * const Product = await prisma.product.delete({
     *   where: {
     *     // ... filter to delete one Product
     *   }
     * })
     * 
     */
    delete<T extends ProductDeleteArgs>(args: SelectSubset<T, ProductDeleteArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Product.
     * @param {ProductUpdateArgs} args - Arguments to update one Product.
     * @example
     * // Update one Product
     * const product = await prisma.product.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductUpdateArgs>(args: SelectSubset<T, ProductUpdateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Products.
     * @param {ProductDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.product.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductDeleteManyArgs>(args?: SelectSubset<T, ProductDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductUpdateManyArgs>(args: SelectSubset<T, ProductUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products and returns the data updated in the database.
     * @param {ProductUpdateManyAndReturnArgs} args - Arguments to update many Products.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Products and only return the `id`
     * const productWithIdOnly = await prisma.product.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Product.
     * @param {ProductUpsertArgs} args - Arguments to update or create a Product.
     * @example
     * // Update or create a Product
     * const product = await prisma.product.upsert({
     *   create: {
     *     // ... data to create a Product
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product we want to update
     *   }
     * })
     */
    upsert<T extends ProductUpsertArgs>(args: SelectSubset<T, ProductUpsertArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.product.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends ProductCountArgs>(
      args?: Subset<T, ProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductAggregateArgs>(args: Subset<T, ProductAggregateArgs>): Prisma.PrismaPromise<GetProductAggregateType<T>>

    /**
     * Group by Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductGroupByArgs['orderBy'] }
        : { orderBy?: ProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Product model
   */
  readonly fields: ProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Product.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    proposalItems<T extends Product$proposalItemsArgs<ExtArgs> = {}>(args?: Subset<T, Product$proposalItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProposalItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Product model
   */
  interface ProductFieldRefs {
    readonly id: FieldRef<"Product", 'String'>
    readonly name: FieldRef<"Product", 'String'>
    readonly description: FieldRef<"Product", 'String'>
    readonly category: FieldRef<"Product", 'String'>
    readonly brand: FieldRef<"Product", 'String'>
    readonly model: FieldRef<"Product", 'String'>
    readonly sku: FieldRef<"Product", 'String'>
    readonly basePrice: FieldRef<"Product", 'Float'>
    readonly goodTierPrice: FieldRef<"Product", 'Float'>
    readonly betterTierPrice: FieldRef<"Product", 'Float'>
    readonly bestTierPrice: FieldRef<"Product", 'Float'>
    readonly isActive: FieldRef<"Product", 'Boolean'>
    readonly specifications: FieldRef<"Product", 'String'>
    readonly compatibility: FieldRef<"Product", 'String'>
    readonly installation: FieldRef<"Product", 'String'>
    readonly createdAt: FieldRef<"Product", 'DateTime'>
    readonly updatedAt: FieldRef<"Product", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Product findUnique
   */
  export type ProductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findUniqueOrThrow
   */
  export type ProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findFirst
   */
  export type ProductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findFirstOrThrow
   */
  export type ProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findMany
   */
  export type ProductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Products to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product create
   */
  export type ProductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to create a Product.
     */
    data: XOR<ProductCreateInput, ProductUncheckedCreateInput>
  }

  /**
   * Product createMany
   */
  export type ProductCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
  }

  /**
   * Product createManyAndReturn
   */
  export type ProductCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
  }

  /**
   * Product update
   */
  export type ProductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to update a Product.
     */
    data: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
    /**
     * Choose, which Product to update.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product updateMany
   */
  export type ProductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to update.
     */
    limit?: number
  }

  /**
   * Product updateManyAndReturn
   */
  export type ProductUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to update.
     */
    limit?: number
  }

  /**
   * Product upsert
   */
  export type ProductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The filter to search for the Product to update in case it exists.
     */
    where: ProductWhereUniqueInput
    /**
     * In case the Product found by the `where` argument doesn't exist, create a new Product with this data.
     */
    create: XOR<ProductCreateInput, ProductUncheckedCreateInput>
    /**
     * In case the Product was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
  }

  /**
   * Product delete
   */
  export type ProductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter which Product to delete.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product deleteMany
   */
  export type ProductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Products to delete
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to delete.
     */
    limit?: number
  }

  /**
   * Product.proposalItems
   */
  export type Product$proposalItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProposalItem
     */
    select?: ProposalItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProposalItem
     */
    omit?: ProposalItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalItemInclude<ExtArgs> | null
    where?: ProposalItemWhereInput
    orderBy?: ProposalItemOrderByWithRelationInput | ProposalItemOrderByWithRelationInput[]
    cursor?: ProposalItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProposalItemScalarFieldEnum | ProposalItemScalarFieldEnum[]
  }

  /**
   * Product without action
   */
  export type ProductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
  }


  /**
   * Model ProposalPersona
   */

  export type AggregateProposalPersona = {
    _count: ProposalPersonaCountAggregateOutputType | null
    _min: ProposalPersonaMinAggregateOutputType | null
    _max: ProposalPersonaMaxAggregateOutputType | null
  }

  export type ProposalPersonaMinAggregateOutputType = {
    id: string | null
    type: string | null
    name: string | null
    displayName: string | null
    description: string | null
    keyFeatures: string | null
    recommendedTier: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProposalPersonaMaxAggregateOutputType = {
    id: string | null
    type: string | null
    name: string | null
    displayName: string | null
    description: string | null
    keyFeatures: string | null
    recommendedTier: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProposalPersonaCountAggregateOutputType = {
    id: number
    type: number
    name: number
    displayName: number
    description: number
    keyFeatures: number
    recommendedTier: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProposalPersonaMinAggregateInputType = {
    id?: true
    type?: true
    name?: true
    displayName?: true
    description?: true
    keyFeatures?: true
    recommendedTier?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProposalPersonaMaxAggregateInputType = {
    id?: true
    type?: true
    name?: true
    displayName?: true
    description?: true
    keyFeatures?: true
    recommendedTier?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProposalPersonaCountAggregateInputType = {
    id?: true
    type?: true
    name?: true
    displayName?: true
    description?: true
    keyFeatures?: true
    recommendedTier?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProposalPersonaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProposalPersona to aggregate.
     */
    where?: ProposalPersonaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProposalPersonas to fetch.
     */
    orderBy?: ProposalPersonaOrderByWithRelationInput | ProposalPersonaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProposalPersonaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProposalPersonas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProposalPersonas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProposalPersonas
    **/
    _count?: true | ProposalPersonaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProposalPersonaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProposalPersonaMaxAggregateInputType
  }

  export type GetProposalPersonaAggregateType<T extends ProposalPersonaAggregateArgs> = {
        [P in keyof T & keyof AggregateProposalPersona]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProposalPersona[P]>
      : GetScalarType<T[P], AggregateProposalPersona[P]>
  }




  export type ProposalPersonaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProposalPersonaWhereInput
    orderBy?: ProposalPersonaOrderByWithAggregationInput | ProposalPersonaOrderByWithAggregationInput[]
    by: ProposalPersonaScalarFieldEnum[] | ProposalPersonaScalarFieldEnum
    having?: ProposalPersonaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProposalPersonaCountAggregateInputType | true
    _min?: ProposalPersonaMinAggregateInputType
    _max?: ProposalPersonaMaxAggregateInputType
  }

  export type ProposalPersonaGroupByOutputType = {
    id: string
    type: string
    name: string
    displayName: string
    description: string | null
    keyFeatures: string
    recommendedTier: string
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: ProposalPersonaCountAggregateOutputType | null
    _min: ProposalPersonaMinAggregateOutputType | null
    _max: ProposalPersonaMaxAggregateOutputType | null
  }

  type GetProposalPersonaGroupByPayload<T extends ProposalPersonaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProposalPersonaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProposalPersonaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProposalPersonaGroupByOutputType[P]>
            : GetScalarType<T[P], ProposalPersonaGroupByOutputType[P]>
        }
      >
    >


  export type ProposalPersonaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    name?: boolean
    displayName?: boolean
    description?: boolean
    keyFeatures?: boolean
    recommendedTier?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["proposalPersona"]>

  export type ProposalPersonaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    name?: boolean
    displayName?: boolean
    description?: boolean
    keyFeatures?: boolean
    recommendedTier?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["proposalPersona"]>

  export type ProposalPersonaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    name?: boolean
    displayName?: boolean
    description?: boolean
    keyFeatures?: boolean
    recommendedTier?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["proposalPersona"]>

  export type ProposalPersonaSelectScalar = {
    id?: boolean
    type?: boolean
    name?: boolean
    displayName?: boolean
    description?: boolean
    keyFeatures?: boolean
    recommendedTier?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProposalPersonaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type" | "name" | "displayName" | "description" | "keyFeatures" | "recommendedTier" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["proposalPersona"]>

  export type $ProposalPersonaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProposalPersona"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: string
      name: string
      displayName: string
      description: string | null
      keyFeatures: string
      recommendedTier: string
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["proposalPersona"]>
    composites: {}
  }

  type ProposalPersonaGetPayload<S extends boolean | null | undefined | ProposalPersonaDefaultArgs> = $Result.GetResult<Prisma.$ProposalPersonaPayload, S>

  type ProposalPersonaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProposalPersonaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProposalPersonaCountAggregateInputType | true
    }

  export interface ProposalPersonaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProposalPersona'], meta: { name: 'ProposalPersona' } }
    /**
     * Find zero or one ProposalPersona that matches the filter.
     * @param {ProposalPersonaFindUniqueArgs} args - Arguments to find a ProposalPersona
     * @example
     * // Get one ProposalPersona
     * const proposalPersona = await prisma.proposalPersona.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProposalPersonaFindUniqueArgs>(args: SelectSubset<T, ProposalPersonaFindUniqueArgs<ExtArgs>>): Prisma__ProposalPersonaClient<$Result.GetResult<Prisma.$ProposalPersonaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProposalPersona that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProposalPersonaFindUniqueOrThrowArgs} args - Arguments to find a ProposalPersona
     * @example
     * // Get one ProposalPersona
     * const proposalPersona = await prisma.proposalPersona.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProposalPersonaFindUniqueOrThrowArgs>(args: SelectSubset<T, ProposalPersonaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProposalPersonaClient<$Result.GetResult<Prisma.$ProposalPersonaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProposalPersona that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProposalPersonaFindFirstArgs} args - Arguments to find a ProposalPersona
     * @example
     * // Get one ProposalPersona
     * const proposalPersona = await prisma.proposalPersona.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProposalPersonaFindFirstArgs>(args?: SelectSubset<T, ProposalPersonaFindFirstArgs<ExtArgs>>): Prisma__ProposalPersonaClient<$Result.GetResult<Prisma.$ProposalPersonaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProposalPersona that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProposalPersonaFindFirstOrThrowArgs} args - Arguments to find a ProposalPersona
     * @example
     * // Get one ProposalPersona
     * const proposalPersona = await prisma.proposalPersona.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProposalPersonaFindFirstOrThrowArgs>(args?: SelectSubset<T, ProposalPersonaFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProposalPersonaClient<$Result.GetResult<Prisma.$ProposalPersonaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProposalPersonas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProposalPersonaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProposalPersonas
     * const proposalPersonas = await prisma.proposalPersona.findMany()
     * 
     * // Get first 10 ProposalPersonas
     * const proposalPersonas = await prisma.proposalPersona.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const proposalPersonaWithIdOnly = await prisma.proposalPersona.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProposalPersonaFindManyArgs>(args?: SelectSubset<T, ProposalPersonaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProposalPersonaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProposalPersona.
     * @param {ProposalPersonaCreateArgs} args - Arguments to create a ProposalPersona.
     * @example
     * // Create one ProposalPersona
     * const ProposalPersona = await prisma.proposalPersona.create({
     *   data: {
     *     // ... data to create a ProposalPersona
     *   }
     * })
     * 
     */
    create<T extends ProposalPersonaCreateArgs>(args: SelectSubset<T, ProposalPersonaCreateArgs<ExtArgs>>): Prisma__ProposalPersonaClient<$Result.GetResult<Prisma.$ProposalPersonaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProposalPersonas.
     * @param {ProposalPersonaCreateManyArgs} args - Arguments to create many ProposalPersonas.
     * @example
     * // Create many ProposalPersonas
     * const proposalPersona = await prisma.proposalPersona.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProposalPersonaCreateManyArgs>(args?: SelectSubset<T, ProposalPersonaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProposalPersonas and returns the data saved in the database.
     * @param {ProposalPersonaCreateManyAndReturnArgs} args - Arguments to create many ProposalPersonas.
     * @example
     * // Create many ProposalPersonas
     * const proposalPersona = await prisma.proposalPersona.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProposalPersonas and only return the `id`
     * const proposalPersonaWithIdOnly = await prisma.proposalPersona.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProposalPersonaCreateManyAndReturnArgs>(args?: SelectSubset<T, ProposalPersonaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProposalPersonaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProposalPersona.
     * @param {ProposalPersonaDeleteArgs} args - Arguments to delete one ProposalPersona.
     * @example
     * // Delete one ProposalPersona
     * const ProposalPersona = await prisma.proposalPersona.delete({
     *   where: {
     *     // ... filter to delete one ProposalPersona
     *   }
     * })
     * 
     */
    delete<T extends ProposalPersonaDeleteArgs>(args: SelectSubset<T, ProposalPersonaDeleteArgs<ExtArgs>>): Prisma__ProposalPersonaClient<$Result.GetResult<Prisma.$ProposalPersonaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProposalPersona.
     * @param {ProposalPersonaUpdateArgs} args - Arguments to update one ProposalPersona.
     * @example
     * // Update one ProposalPersona
     * const proposalPersona = await prisma.proposalPersona.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProposalPersonaUpdateArgs>(args: SelectSubset<T, ProposalPersonaUpdateArgs<ExtArgs>>): Prisma__ProposalPersonaClient<$Result.GetResult<Prisma.$ProposalPersonaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProposalPersonas.
     * @param {ProposalPersonaDeleteManyArgs} args - Arguments to filter ProposalPersonas to delete.
     * @example
     * // Delete a few ProposalPersonas
     * const { count } = await prisma.proposalPersona.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProposalPersonaDeleteManyArgs>(args?: SelectSubset<T, ProposalPersonaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProposalPersonas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProposalPersonaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProposalPersonas
     * const proposalPersona = await prisma.proposalPersona.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProposalPersonaUpdateManyArgs>(args: SelectSubset<T, ProposalPersonaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProposalPersonas and returns the data updated in the database.
     * @param {ProposalPersonaUpdateManyAndReturnArgs} args - Arguments to update many ProposalPersonas.
     * @example
     * // Update many ProposalPersonas
     * const proposalPersona = await prisma.proposalPersona.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProposalPersonas and only return the `id`
     * const proposalPersonaWithIdOnly = await prisma.proposalPersona.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProposalPersonaUpdateManyAndReturnArgs>(args: SelectSubset<T, ProposalPersonaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProposalPersonaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProposalPersona.
     * @param {ProposalPersonaUpsertArgs} args - Arguments to update or create a ProposalPersona.
     * @example
     * // Update or create a ProposalPersona
     * const proposalPersona = await prisma.proposalPersona.upsert({
     *   create: {
     *     // ... data to create a ProposalPersona
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProposalPersona we want to update
     *   }
     * })
     */
    upsert<T extends ProposalPersonaUpsertArgs>(args: SelectSubset<T, ProposalPersonaUpsertArgs<ExtArgs>>): Prisma__ProposalPersonaClient<$Result.GetResult<Prisma.$ProposalPersonaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProposalPersonas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProposalPersonaCountArgs} args - Arguments to filter ProposalPersonas to count.
     * @example
     * // Count the number of ProposalPersonas
     * const count = await prisma.proposalPersona.count({
     *   where: {
     *     // ... the filter for the ProposalPersonas we want to count
     *   }
     * })
    **/
    count<T extends ProposalPersonaCountArgs>(
      args?: Subset<T, ProposalPersonaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProposalPersonaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProposalPersona.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProposalPersonaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProposalPersonaAggregateArgs>(args: Subset<T, ProposalPersonaAggregateArgs>): Prisma.PrismaPromise<GetProposalPersonaAggregateType<T>>

    /**
     * Group by ProposalPersona.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProposalPersonaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProposalPersonaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProposalPersonaGroupByArgs['orderBy'] }
        : { orderBy?: ProposalPersonaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProposalPersonaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProposalPersonaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProposalPersona model
   */
  readonly fields: ProposalPersonaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProposalPersona.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProposalPersonaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProposalPersona model
   */
  interface ProposalPersonaFieldRefs {
    readonly id: FieldRef<"ProposalPersona", 'String'>
    readonly type: FieldRef<"ProposalPersona", 'String'>
    readonly name: FieldRef<"ProposalPersona", 'String'>
    readonly displayName: FieldRef<"ProposalPersona", 'String'>
    readonly description: FieldRef<"ProposalPersona", 'String'>
    readonly keyFeatures: FieldRef<"ProposalPersona", 'String'>
    readonly recommendedTier: FieldRef<"ProposalPersona", 'String'>
    readonly isActive: FieldRef<"ProposalPersona", 'Boolean'>
    readonly createdAt: FieldRef<"ProposalPersona", 'DateTime'>
    readonly updatedAt: FieldRef<"ProposalPersona", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProposalPersona findUnique
   */
  export type ProposalPersonaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProposalPersona
     */
    select?: ProposalPersonaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProposalPersona
     */
    omit?: ProposalPersonaOmit<ExtArgs> | null
    /**
     * Filter, which ProposalPersona to fetch.
     */
    where: ProposalPersonaWhereUniqueInput
  }

  /**
   * ProposalPersona findUniqueOrThrow
   */
  export type ProposalPersonaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProposalPersona
     */
    select?: ProposalPersonaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProposalPersona
     */
    omit?: ProposalPersonaOmit<ExtArgs> | null
    /**
     * Filter, which ProposalPersona to fetch.
     */
    where: ProposalPersonaWhereUniqueInput
  }

  /**
   * ProposalPersona findFirst
   */
  export type ProposalPersonaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProposalPersona
     */
    select?: ProposalPersonaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProposalPersona
     */
    omit?: ProposalPersonaOmit<ExtArgs> | null
    /**
     * Filter, which ProposalPersona to fetch.
     */
    where?: ProposalPersonaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProposalPersonas to fetch.
     */
    orderBy?: ProposalPersonaOrderByWithRelationInput | ProposalPersonaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProposalPersonas.
     */
    cursor?: ProposalPersonaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProposalPersonas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProposalPersonas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProposalPersonas.
     */
    distinct?: ProposalPersonaScalarFieldEnum | ProposalPersonaScalarFieldEnum[]
  }

  /**
   * ProposalPersona findFirstOrThrow
   */
  export type ProposalPersonaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProposalPersona
     */
    select?: ProposalPersonaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProposalPersona
     */
    omit?: ProposalPersonaOmit<ExtArgs> | null
    /**
     * Filter, which ProposalPersona to fetch.
     */
    where?: ProposalPersonaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProposalPersonas to fetch.
     */
    orderBy?: ProposalPersonaOrderByWithRelationInput | ProposalPersonaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProposalPersonas.
     */
    cursor?: ProposalPersonaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProposalPersonas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProposalPersonas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProposalPersonas.
     */
    distinct?: ProposalPersonaScalarFieldEnum | ProposalPersonaScalarFieldEnum[]
  }

  /**
   * ProposalPersona findMany
   */
  export type ProposalPersonaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProposalPersona
     */
    select?: ProposalPersonaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProposalPersona
     */
    omit?: ProposalPersonaOmit<ExtArgs> | null
    /**
     * Filter, which ProposalPersonas to fetch.
     */
    where?: ProposalPersonaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProposalPersonas to fetch.
     */
    orderBy?: ProposalPersonaOrderByWithRelationInput | ProposalPersonaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProposalPersonas.
     */
    cursor?: ProposalPersonaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProposalPersonas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProposalPersonas.
     */
    skip?: number
    distinct?: ProposalPersonaScalarFieldEnum | ProposalPersonaScalarFieldEnum[]
  }

  /**
   * ProposalPersona create
   */
  export type ProposalPersonaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProposalPersona
     */
    select?: ProposalPersonaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProposalPersona
     */
    omit?: ProposalPersonaOmit<ExtArgs> | null
    /**
     * The data needed to create a ProposalPersona.
     */
    data: XOR<ProposalPersonaCreateInput, ProposalPersonaUncheckedCreateInput>
  }

  /**
   * ProposalPersona createMany
   */
  export type ProposalPersonaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProposalPersonas.
     */
    data: ProposalPersonaCreateManyInput | ProposalPersonaCreateManyInput[]
  }

  /**
   * ProposalPersona createManyAndReturn
   */
  export type ProposalPersonaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProposalPersona
     */
    select?: ProposalPersonaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProposalPersona
     */
    omit?: ProposalPersonaOmit<ExtArgs> | null
    /**
     * The data used to create many ProposalPersonas.
     */
    data: ProposalPersonaCreateManyInput | ProposalPersonaCreateManyInput[]
  }

  /**
   * ProposalPersona update
   */
  export type ProposalPersonaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProposalPersona
     */
    select?: ProposalPersonaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProposalPersona
     */
    omit?: ProposalPersonaOmit<ExtArgs> | null
    /**
     * The data needed to update a ProposalPersona.
     */
    data: XOR<ProposalPersonaUpdateInput, ProposalPersonaUncheckedUpdateInput>
    /**
     * Choose, which ProposalPersona to update.
     */
    where: ProposalPersonaWhereUniqueInput
  }

  /**
   * ProposalPersona updateMany
   */
  export type ProposalPersonaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProposalPersonas.
     */
    data: XOR<ProposalPersonaUpdateManyMutationInput, ProposalPersonaUncheckedUpdateManyInput>
    /**
     * Filter which ProposalPersonas to update
     */
    where?: ProposalPersonaWhereInput
    /**
     * Limit how many ProposalPersonas to update.
     */
    limit?: number
  }

  /**
   * ProposalPersona updateManyAndReturn
   */
  export type ProposalPersonaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProposalPersona
     */
    select?: ProposalPersonaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProposalPersona
     */
    omit?: ProposalPersonaOmit<ExtArgs> | null
    /**
     * The data used to update ProposalPersonas.
     */
    data: XOR<ProposalPersonaUpdateManyMutationInput, ProposalPersonaUncheckedUpdateManyInput>
    /**
     * Filter which ProposalPersonas to update
     */
    where?: ProposalPersonaWhereInput
    /**
     * Limit how many ProposalPersonas to update.
     */
    limit?: number
  }

  /**
   * ProposalPersona upsert
   */
  export type ProposalPersonaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProposalPersona
     */
    select?: ProposalPersonaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProposalPersona
     */
    omit?: ProposalPersonaOmit<ExtArgs> | null
    /**
     * The filter to search for the ProposalPersona to update in case it exists.
     */
    where: ProposalPersonaWhereUniqueInput
    /**
     * In case the ProposalPersona found by the `where` argument doesn't exist, create a new ProposalPersona with this data.
     */
    create: XOR<ProposalPersonaCreateInput, ProposalPersonaUncheckedCreateInput>
    /**
     * In case the ProposalPersona was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProposalPersonaUpdateInput, ProposalPersonaUncheckedUpdateInput>
  }

  /**
   * ProposalPersona delete
   */
  export type ProposalPersonaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProposalPersona
     */
    select?: ProposalPersonaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProposalPersona
     */
    omit?: ProposalPersonaOmit<ExtArgs> | null
    /**
     * Filter which ProposalPersona to delete.
     */
    where: ProposalPersonaWhereUniqueInput
  }

  /**
   * ProposalPersona deleteMany
   */
  export type ProposalPersonaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProposalPersonas to delete
     */
    where?: ProposalPersonaWhereInput
    /**
     * Limit how many ProposalPersonas to delete.
     */
    limit?: number
  }

  /**
   * ProposalPersona without action
   */
  export type ProposalPersonaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProposalPersona
     */
    select?: ProposalPersonaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProposalPersona
     */
    omit?: ProposalPersonaOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const CustomerScalarFieldEnum: {
    id: 'id',
    type: 'type',
    status: 'status',
    firstName: 'firstName',
    lastName: 'lastName',
    company: 'company',
    email: 'email',
    phone: 'phone',
    preferredCommunication: 'preferredCommunication',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CustomerScalarFieldEnum = (typeof CustomerScalarFieldEnum)[keyof typeof CustomerScalarFieldEnum]


  export const TagScalarFieldEnum: {
    id: 'id',
    name: 'name',
    customerId: 'customerId'
  };

  export type TagScalarFieldEnum = (typeof TagScalarFieldEnum)[keyof typeof TagScalarFieldEnum]


  export const AddressScalarFieldEnum: {
    id: 'id',
    street: 'street',
    city: 'city',
    state: 'state',
    zipCode: 'zipCode',
    country: 'country',
    customerId: 'customerId'
  };

  export type AddressScalarFieldEnum = (typeof AddressScalarFieldEnum)[keyof typeof AddressScalarFieldEnum]


  export const PropertyScalarFieldEnum: {
    id: 'id',
    name: 'name',
    type: 'type',
    addressId: 'addressId',
    squareFootage: 'squareFootage',
    bedrooms: 'bedrooms',
    bathrooms: 'bathrooms',
    yearBuilt: 'yearBuilt',
    customerId: 'customerId'
  };

  export type PropertyScalarFieldEnum = (typeof PropertyScalarFieldEnum)[keyof typeof PropertyScalarFieldEnum]


  export const PhotoScalarFieldEnum: {
    id: 'id',
    url: 'url',
    propertyId: 'propertyId',
    uploadedAt: 'uploadedAt',
    uploadedBy: 'uploadedBy'
  };

  export type PhotoScalarFieldEnum = (typeof PhotoScalarFieldEnum)[keyof typeof PhotoScalarFieldEnum]


  export const DocumentScalarFieldEnum: {
    id: 'id',
    name: 'name',
    url: 'url',
    type: 'type',
    propertyId: 'propertyId',
    projectId: 'projectId',
    uploadedAt: 'uploadedAt',
    uploadedBy: 'uploadedBy'
  };

  export type DocumentScalarFieldEnum = (typeof DocumentScalarFieldEnum)[keyof typeof DocumentScalarFieldEnum]


  export const SystemInstallationScalarFieldEnum: {
    id: 'id',
    type: 'type',
    details: 'details',
    installDate: 'installDate',
    lastService: 'lastService',
    propertyId: 'propertyId'
  };

  export type SystemInstallationScalarFieldEnum = (typeof SystemInstallationScalarFieldEnum)[keyof typeof SystemInstallationScalarFieldEnum]


  export const ServiceRecordScalarFieldEnum: {
    id: 'id',
    date: 'date',
    type: 'type',
    description: 'description',
    technician: 'technician',
    cost: 'cost',
    propertyId: 'propertyId'
  };

  export type ServiceRecordScalarFieldEnum = (typeof ServiceRecordScalarFieldEnum)[keyof typeof ServiceRecordScalarFieldEnum]


  export const ProjectScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    status: 'status',
    startDate: 'startDate',
    endDate: 'endDate',
    propertyId: 'propertyId',
    customerId: 'customerId'
  };

  export type ProjectScalarFieldEnum = (typeof ProjectScalarFieldEnum)[keyof typeof ProjectScalarFieldEnum]


  export const ProjectTeamMemberScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    teamMemberId: 'teamMemberId'
  };

  export type ProjectTeamMemberScalarFieldEnum = (typeof ProjectTeamMemberScalarFieldEnum)[keyof typeof ProjectTeamMemberScalarFieldEnum]


  export const TeamMemberScalarFieldEnum: {
    id: 'id',
    name: 'name',
    role: 'role',
    email: 'email',
    phone: 'phone'
  };

  export type TeamMemberScalarFieldEnum = (typeof TeamMemberScalarFieldEnum)[keyof typeof TeamMemberScalarFieldEnum]


  export const MilestoneScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    status: 'status',
    dueDate: 'dueDate',
    completedDate: 'completedDate',
    assignedTo: 'assignedTo',
    projectId: 'projectId'
  };

  export type MilestoneScalarFieldEnum = (typeof MilestoneScalarFieldEnum)[keyof typeof MilestoneScalarFieldEnum]


  export const BudgetScalarFieldEnum: {
    id: 'id',
    currency: 'currency',
    total: 'total',
    spent: 'spent',
    remaining: 'remaining',
    projectId: 'projectId'
  };

  export type BudgetScalarFieldEnum = (typeof BudgetScalarFieldEnum)[keyof typeof BudgetScalarFieldEnum]


  export const BudgetLineItemScalarFieldEnum: {
    id: 'id',
    description: 'description',
    amount: 'amount',
    category: 'category',
    budgetId: 'budgetId'
  };

  export type BudgetLineItemScalarFieldEnum = (typeof BudgetLineItemScalarFieldEnum)[keyof typeof BudgetLineItemScalarFieldEnum]


  export const InteractionScalarFieldEnum: {
    id: 'id',
    type: 'type',
    date: 'date',
    summary: 'summary',
    details: 'details',
    followUpDate: 'followUpDate',
    followUpNotes: 'followUpNotes',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    customerId: 'customerId'
  };

  export type InteractionScalarFieldEnum = (typeof InteractionScalarFieldEnum)[keyof typeof InteractionScalarFieldEnum]


  export const CustomerMetricsScalarFieldEnum: {
    id: 'id',
    totalRevenue: 'totalRevenue',
    projectsCompleted: 'projectsCompleted',
    avgResponseTime: 'avgResponseTime',
    lastInteraction: 'lastInteraction',
    nextScheduledInteraction: 'nextScheduledInteraction',
    customerId: 'customerId'
  };

  export type CustomerMetricsScalarFieldEnum = (typeof CustomerMetricsScalarFieldEnum)[keyof typeof CustomerMetricsScalarFieldEnum]


  export const ProposalScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    status: 'status',
    customerPersona: 'customerPersona',
    voiceTranscript: 'voiceTranscript',
    aiSummary: 'aiSummary',
    totalAmount: 'totalAmount',
    validUntil: 'validUntil',
    isExistingCustomer: 'isExistingCustomer',
    customerId: 'customerId',
    prospectName: 'prospectName',
    prospectCompany: 'prospectCompany',
    prospectEmail: 'prospectEmail',
    prospectPhone: 'prospectPhone',
    prospectStatus: 'prospectStatus',
    propertyId: 'propertyId',
    projectId: 'projectId',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProposalScalarFieldEnum = (typeof ProposalScalarFieldEnum)[keyof typeof ProposalScalarFieldEnum]


  export const ProposalItemScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    category: 'category',
    quantity: 'quantity',
    unitPrice: 'unitPrice',
    totalPrice: 'totalPrice',
    productId: 'productId',
    proposalId: 'proposalId',
    sortOrder: 'sortOrder',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProposalItemScalarFieldEnum = (typeof ProposalItemScalarFieldEnum)[keyof typeof ProposalItemScalarFieldEnum]


  export const ProductScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    category: 'category',
    brand: 'brand',
    model: 'model',
    sku: 'sku',
    basePrice: 'basePrice',
    goodTierPrice: 'goodTierPrice',
    betterTierPrice: 'betterTierPrice',
    bestTierPrice: 'bestTierPrice',
    isActive: 'isActive',
    specifications: 'specifications',
    compatibility: 'compatibility',
    installation: 'installation',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProductScalarFieldEnum = (typeof ProductScalarFieldEnum)[keyof typeof ProductScalarFieldEnum]


  export const ProposalPersonaScalarFieldEnum: {
    id: 'id',
    type: 'type',
    name: 'name',
    displayName: 'displayName',
    description: 'description',
    keyFeatures: 'keyFeatures',
    recommendedTier: 'recommendedTier',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProposalPersonaScalarFieldEnum = (typeof ProposalPersonaScalarFieldEnum)[keyof typeof ProposalPersonaScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    
  /**
   * Deep Input Types
   */


  export type CustomerWhereInput = {
    AND?: CustomerWhereInput | CustomerWhereInput[]
    OR?: CustomerWhereInput[]
    NOT?: CustomerWhereInput | CustomerWhereInput[]
    id?: StringFilter<"Customer"> | string
    type?: StringFilter<"Customer"> | string
    status?: StringFilter<"Customer"> | string
    firstName?: StringFilter<"Customer"> | string
    lastName?: StringFilter<"Customer"> | string
    company?: StringNullableFilter<"Customer"> | string | null
    email?: StringFilter<"Customer"> | string
    phone?: StringFilter<"Customer"> | string
    preferredCommunication?: StringFilter<"Customer"> | string
    notes?: StringNullableFilter<"Customer"> | string | null
    createdAt?: DateTimeFilter<"Customer"> | Date | string
    updatedAt?: DateTimeFilter<"Customer"> | Date | string
    billingAddress?: XOR<AddressNullableScalarRelationFilter, AddressWhereInput> | null
    properties?: PropertyListRelationFilter
    projects?: ProjectListRelationFilter
    interactions?: InteractionListRelationFilter
    tags?: TagListRelationFilter
    metrics?: XOR<CustomerMetricsNullableScalarRelationFilter, CustomerMetricsWhereInput> | null
    proposals?: ProposalListRelationFilter
  }

  export type CustomerOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    status?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    company?: SortOrderInput | SortOrder
    email?: SortOrder
    phone?: SortOrder
    preferredCommunication?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    billingAddress?: AddressOrderByWithRelationInput
    properties?: PropertyOrderByRelationAggregateInput
    projects?: ProjectOrderByRelationAggregateInput
    interactions?: InteractionOrderByRelationAggregateInput
    tags?: TagOrderByRelationAggregateInput
    metrics?: CustomerMetricsOrderByWithRelationInput
    proposals?: ProposalOrderByRelationAggregateInput
  }

  export type CustomerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CustomerWhereInput | CustomerWhereInput[]
    OR?: CustomerWhereInput[]
    NOT?: CustomerWhereInput | CustomerWhereInput[]
    type?: StringFilter<"Customer"> | string
    status?: StringFilter<"Customer"> | string
    firstName?: StringFilter<"Customer"> | string
    lastName?: StringFilter<"Customer"> | string
    company?: StringNullableFilter<"Customer"> | string | null
    email?: StringFilter<"Customer"> | string
    phone?: StringFilter<"Customer"> | string
    preferredCommunication?: StringFilter<"Customer"> | string
    notes?: StringNullableFilter<"Customer"> | string | null
    createdAt?: DateTimeFilter<"Customer"> | Date | string
    updatedAt?: DateTimeFilter<"Customer"> | Date | string
    billingAddress?: XOR<AddressNullableScalarRelationFilter, AddressWhereInput> | null
    properties?: PropertyListRelationFilter
    projects?: ProjectListRelationFilter
    interactions?: InteractionListRelationFilter
    tags?: TagListRelationFilter
    metrics?: XOR<CustomerMetricsNullableScalarRelationFilter, CustomerMetricsWhereInput> | null
    proposals?: ProposalListRelationFilter
  }, "id">

  export type CustomerOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    status?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    company?: SortOrderInput | SortOrder
    email?: SortOrder
    phone?: SortOrder
    preferredCommunication?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CustomerCountOrderByAggregateInput
    _max?: CustomerMaxOrderByAggregateInput
    _min?: CustomerMinOrderByAggregateInput
  }

  export type CustomerScalarWhereWithAggregatesInput = {
    AND?: CustomerScalarWhereWithAggregatesInput | CustomerScalarWhereWithAggregatesInput[]
    OR?: CustomerScalarWhereWithAggregatesInput[]
    NOT?: CustomerScalarWhereWithAggregatesInput | CustomerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Customer"> | string
    type?: StringWithAggregatesFilter<"Customer"> | string
    status?: StringWithAggregatesFilter<"Customer"> | string
    firstName?: StringWithAggregatesFilter<"Customer"> | string
    lastName?: StringWithAggregatesFilter<"Customer"> | string
    company?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    email?: StringWithAggregatesFilter<"Customer"> | string
    phone?: StringWithAggregatesFilter<"Customer"> | string
    preferredCommunication?: StringWithAggregatesFilter<"Customer"> | string
    notes?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Customer"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Customer"> | Date | string
  }

  export type TagWhereInput = {
    AND?: TagWhereInput | TagWhereInput[]
    OR?: TagWhereInput[]
    NOT?: TagWhereInput | TagWhereInput[]
    id?: StringFilter<"Tag"> | string
    name?: StringFilter<"Tag"> | string
    customerId?: StringFilter<"Tag"> | string
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
  }

  export type TagOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    customerId?: SortOrder
    customer?: CustomerOrderByWithRelationInput
  }

  export type TagWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TagWhereInput | TagWhereInput[]
    OR?: TagWhereInput[]
    NOT?: TagWhereInput | TagWhereInput[]
    name?: StringFilter<"Tag"> | string
    customerId?: StringFilter<"Tag"> | string
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
  }, "id">

  export type TagOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    customerId?: SortOrder
    _count?: TagCountOrderByAggregateInput
    _max?: TagMaxOrderByAggregateInput
    _min?: TagMinOrderByAggregateInput
  }

  export type TagScalarWhereWithAggregatesInput = {
    AND?: TagScalarWhereWithAggregatesInput | TagScalarWhereWithAggregatesInput[]
    OR?: TagScalarWhereWithAggregatesInput[]
    NOT?: TagScalarWhereWithAggregatesInput | TagScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Tag"> | string
    name?: StringWithAggregatesFilter<"Tag"> | string
    customerId?: StringWithAggregatesFilter<"Tag"> | string
  }

  export type AddressWhereInput = {
    AND?: AddressWhereInput | AddressWhereInput[]
    OR?: AddressWhereInput[]
    NOT?: AddressWhereInput | AddressWhereInput[]
    id?: StringFilter<"Address"> | string
    street?: StringFilter<"Address"> | string
    city?: StringFilter<"Address"> | string
    state?: StringFilter<"Address"> | string
    zipCode?: StringFilter<"Address"> | string
    country?: StringFilter<"Address"> | string
    customerId?: StringFilter<"Address"> | string
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
    property?: XOR<PropertyNullableScalarRelationFilter, PropertyWhereInput> | null
  }

  export type AddressOrderByWithRelationInput = {
    id?: SortOrder
    street?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zipCode?: SortOrder
    country?: SortOrder
    customerId?: SortOrder
    customer?: CustomerOrderByWithRelationInput
    property?: PropertyOrderByWithRelationInput
  }

  export type AddressWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    customerId?: string
    AND?: AddressWhereInput | AddressWhereInput[]
    OR?: AddressWhereInput[]
    NOT?: AddressWhereInput | AddressWhereInput[]
    street?: StringFilter<"Address"> | string
    city?: StringFilter<"Address"> | string
    state?: StringFilter<"Address"> | string
    zipCode?: StringFilter<"Address"> | string
    country?: StringFilter<"Address"> | string
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
    property?: XOR<PropertyNullableScalarRelationFilter, PropertyWhereInput> | null
  }, "id" | "customerId">

  export type AddressOrderByWithAggregationInput = {
    id?: SortOrder
    street?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zipCode?: SortOrder
    country?: SortOrder
    customerId?: SortOrder
    _count?: AddressCountOrderByAggregateInput
    _max?: AddressMaxOrderByAggregateInput
    _min?: AddressMinOrderByAggregateInput
  }

  export type AddressScalarWhereWithAggregatesInput = {
    AND?: AddressScalarWhereWithAggregatesInput | AddressScalarWhereWithAggregatesInput[]
    OR?: AddressScalarWhereWithAggregatesInput[]
    NOT?: AddressScalarWhereWithAggregatesInput | AddressScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Address"> | string
    street?: StringWithAggregatesFilter<"Address"> | string
    city?: StringWithAggregatesFilter<"Address"> | string
    state?: StringWithAggregatesFilter<"Address"> | string
    zipCode?: StringWithAggregatesFilter<"Address"> | string
    country?: StringWithAggregatesFilter<"Address"> | string
    customerId?: StringWithAggregatesFilter<"Address"> | string
  }

  export type PropertyWhereInput = {
    AND?: PropertyWhereInput | PropertyWhereInput[]
    OR?: PropertyWhereInput[]
    NOT?: PropertyWhereInput | PropertyWhereInput[]
    id?: StringFilter<"Property"> | string
    name?: StringFilter<"Property"> | string
    type?: StringFilter<"Property"> | string
    addressId?: StringNullableFilter<"Property"> | string | null
    squareFootage?: FloatFilter<"Property"> | number
    bedrooms?: IntNullableFilter<"Property"> | number | null
    bathrooms?: IntNullableFilter<"Property"> | number | null
    yearBuilt?: IntNullableFilter<"Property"> | number | null
    customerId?: StringFilter<"Property"> | string
    address?: XOR<AddressNullableScalarRelationFilter, AddressWhereInput> | null
    photos?: PhotoListRelationFilter
    documents?: DocumentListRelationFilter
    systems?: SystemInstallationListRelationFilter
    serviceHistory?: ServiceRecordListRelationFilter
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
    projects?: ProjectListRelationFilter
    proposals?: ProposalListRelationFilter
  }

  export type PropertyOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    addressId?: SortOrderInput | SortOrder
    squareFootage?: SortOrder
    bedrooms?: SortOrderInput | SortOrder
    bathrooms?: SortOrderInput | SortOrder
    yearBuilt?: SortOrderInput | SortOrder
    customerId?: SortOrder
    address?: AddressOrderByWithRelationInput
    photos?: PhotoOrderByRelationAggregateInput
    documents?: DocumentOrderByRelationAggregateInput
    systems?: SystemInstallationOrderByRelationAggregateInput
    serviceHistory?: ServiceRecordOrderByRelationAggregateInput
    customer?: CustomerOrderByWithRelationInput
    projects?: ProjectOrderByRelationAggregateInput
    proposals?: ProposalOrderByRelationAggregateInput
  }

  export type PropertyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    addressId?: string
    AND?: PropertyWhereInput | PropertyWhereInput[]
    OR?: PropertyWhereInput[]
    NOT?: PropertyWhereInput | PropertyWhereInput[]
    name?: StringFilter<"Property"> | string
    type?: StringFilter<"Property"> | string
    squareFootage?: FloatFilter<"Property"> | number
    bedrooms?: IntNullableFilter<"Property"> | number | null
    bathrooms?: IntNullableFilter<"Property"> | number | null
    yearBuilt?: IntNullableFilter<"Property"> | number | null
    customerId?: StringFilter<"Property"> | string
    address?: XOR<AddressNullableScalarRelationFilter, AddressWhereInput> | null
    photos?: PhotoListRelationFilter
    documents?: DocumentListRelationFilter
    systems?: SystemInstallationListRelationFilter
    serviceHistory?: ServiceRecordListRelationFilter
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
    projects?: ProjectListRelationFilter
    proposals?: ProposalListRelationFilter
  }, "id" | "addressId">

  export type PropertyOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    addressId?: SortOrderInput | SortOrder
    squareFootage?: SortOrder
    bedrooms?: SortOrderInput | SortOrder
    bathrooms?: SortOrderInput | SortOrder
    yearBuilt?: SortOrderInput | SortOrder
    customerId?: SortOrder
    _count?: PropertyCountOrderByAggregateInput
    _avg?: PropertyAvgOrderByAggregateInput
    _max?: PropertyMaxOrderByAggregateInput
    _min?: PropertyMinOrderByAggregateInput
    _sum?: PropertySumOrderByAggregateInput
  }

  export type PropertyScalarWhereWithAggregatesInput = {
    AND?: PropertyScalarWhereWithAggregatesInput | PropertyScalarWhereWithAggregatesInput[]
    OR?: PropertyScalarWhereWithAggregatesInput[]
    NOT?: PropertyScalarWhereWithAggregatesInput | PropertyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Property"> | string
    name?: StringWithAggregatesFilter<"Property"> | string
    type?: StringWithAggregatesFilter<"Property"> | string
    addressId?: StringNullableWithAggregatesFilter<"Property"> | string | null
    squareFootage?: FloatWithAggregatesFilter<"Property"> | number
    bedrooms?: IntNullableWithAggregatesFilter<"Property"> | number | null
    bathrooms?: IntNullableWithAggregatesFilter<"Property"> | number | null
    yearBuilt?: IntNullableWithAggregatesFilter<"Property"> | number | null
    customerId?: StringWithAggregatesFilter<"Property"> | string
  }

  export type PhotoWhereInput = {
    AND?: PhotoWhereInput | PhotoWhereInput[]
    OR?: PhotoWhereInput[]
    NOT?: PhotoWhereInput | PhotoWhereInput[]
    id?: StringFilter<"Photo"> | string
    url?: StringFilter<"Photo"> | string
    propertyId?: StringFilter<"Photo"> | string
    uploadedAt?: DateTimeFilter<"Photo"> | Date | string
    uploadedBy?: StringFilter<"Photo"> | string
    property?: XOR<PropertyScalarRelationFilter, PropertyWhereInput>
  }

  export type PhotoOrderByWithRelationInput = {
    id?: SortOrder
    url?: SortOrder
    propertyId?: SortOrder
    uploadedAt?: SortOrder
    uploadedBy?: SortOrder
    property?: PropertyOrderByWithRelationInput
  }

  export type PhotoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PhotoWhereInput | PhotoWhereInput[]
    OR?: PhotoWhereInput[]
    NOT?: PhotoWhereInput | PhotoWhereInput[]
    url?: StringFilter<"Photo"> | string
    propertyId?: StringFilter<"Photo"> | string
    uploadedAt?: DateTimeFilter<"Photo"> | Date | string
    uploadedBy?: StringFilter<"Photo"> | string
    property?: XOR<PropertyScalarRelationFilter, PropertyWhereInput>
  }, "id">

  export type PhotoOrderByWithAggregationInput = {
    id?: SortOrder
    url?: SortOrder
    propertyId?: SortOrder
    uploadedAt?: SortOrder
    uploadedBy?: SortOrder
    _count?: PhotoCountOrderByAggregateInput
    _max?: PhotoMaxOrderByAggregateInput
    _min?: PhotoMinOrderByAggregateInput
  }

  export type PhotoScalarWhereWithAggregatesInput = {
    AND?: PhotoScalarWhereWithAggregatesInput | PhotoScalarWhereWithAggregatesInput[]
    OR?: PhotoScalarWhereWithAggregatesInput[]
    NOT?: PhotoScalarWhereWithAggregatesInput | PhotoScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Photo"> | string
    url?: StringWithAggregatesFilter<"Photo"> | string
    propertyId?: StringWithAggregatesFilter<"Photo"> | string
    uploadedAt?: DateTimeWithAggregatesFilter<"Photo"> | Date | string
    uploadedBy?: StringWithAggregatesFilter<"Photo"> | string
  }

  export type DocumentWhereInput = {
    AND?: DocumentWhereInput | DocumentWhereInput[]
    OR?: DocumentWhereInput[]
    NOT?: DocumentWhereInput | DocumentWhereInput[]
    id?: StringFilter<"Document"> | string
    name?: StringFilter<"Document"> | string
    url?: StringFilter<"Document"> | string
    type?: StringFilter<"Document"> | string
    propertyId?: StringNullableFilter<"Document"> | string | null
    projectId?: StringNullableFilter<"Document"> | string | null
    uploadedAt?: DateTimeFilter<"Document"> | Date | string
    uploadedBy?: StringFilter<"Document"> | string
    property?: XOR<PropertyNullableScalarRelationFilter, PropertyWhereInput> | null
    project?: XOR<ProjectNullableScalarRelationFilter, ProjectWhereInput> | null
  }

  export type DocumentOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    url?: SortOrder
    type?: SortOrder
    propertyId?: SortOrderInput | SortOrder
    projectId?: SortOrderInput | SortOrder
    uploadedAt?: SortOrder
    uploadedBy?: SortOrder
    property?: PropertyOrderByWithRelationInput
    project?: ProjectOrderByWithRelationInput
  }

  export type DocumentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DocumentWhereInput | DocumentWhereInput[]
    OR?: DocumentWhereInput[]
    NOT?: DocumentWhereInput | DocumentWhereInput[]
    name?: StringFilter<"Document"> | string
    url?: StringFilter<"Document"> | string
    type?: StringFilter<"Document"> | string
    propertyId?: StringNullableFilter<"Document"> | string | null
    projectId?: StringNullableFilter<"Document"> | string | null
    uploadedAt?: DateTimeFilter<"Document"> | Date | string
    uploadedBy?: StringFilter<"Document"> | string
    property?: XOR<PropertyNullableScalarRelationFilter, PropertyWhereInput> | null
    project?: XOR<ProjectNullableScalarRelationFilter, ProjectWhereInput> | null
  }, "id">

  export type DocumentOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    url?: SortOrder
    type?: SortOrder
    propertyId?: SortOrderInput | SortOrder
    projectId?: SortOrderInput | SortOrder
    uploadedAt?: SortOrder
    uploadedBy?: SortOrder
    _count?: DocumentCountOrderByAggregateInput
    _max?: DocumentMaxOrderByAggregateInput
    _min?: DocumentMinOrderByAggregateInput
  }

  export type DocumentScalarWhereWithAggregatesInput = {
    AND?: DocumentScalarWhereWithAggregatesInput | DocumentScalarWhereWithAggregatesInput[]
    OR?: DocumentScalarWhereWithAggregatesInput[]
    NOT?: DocumentScalarWhereWithAggregatesInput | DocumentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Document"> | string
    name?: StringWithAggregatesFilter<"Document"> | string
    url?: StringWithAggregatesFilter<"Document"> | string
    type?: StringWithAggregatesFilter<"Document"> | string
    propertyId?: StringNullableWithAggregatesFilter<"Document"> | string | null
    projectId?: StringNullableWithAggregatesFilter<"Document"> | string | null
    uploadedAt?: DateTimeWithAggregatesFilter<"Document"> | Date | string
    uploadedBy?: StringWithAggregatesFilter<"Document"> | string
  }

  export type SystemInstallationWhereInput = {
    AND?: SystemInstallationWhereInput | SystemInstallationWhereInput[]
    OR?: SystemInstallationWhereInput[]
    NOT?: SystemInstallationWhereInput | SystemInstallationWhereInput[]
    id?: StringFilter<"SystemInstallation"> | string
    type?: StringFilter<"SystemInstallation"> | string
    details?: StringFilter<"SystemInstallation"> | string
    installDate?: DateTimeNullableFilter<"SystemInstallation"> | Date | string | null
    lastService?: DateTimeNullableFilter<"SystemInstallation"> | Date | string | null
    propertyId?: StringFilter<"SystemInstallation"> | string
    property?: XOR<PropertyScalarRelationFilter, PropertyWhereInput>
  }

  export type SystemInstallationOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    details?: SortOrder
    installDate?: SortOrderInput | SortOrder
    lastService?: SortOrderInput | SortOrder
    propertyId?: SortOrder
    property?: PropertyOrderByWithRelationInput
  }

  export type SystemInstallationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SystemInstallationWhereInput | SystemInstallationWhereInput[]
    OR?: SystemInstallationWhereInput[]
    NOT?: SystemInstallationWhereInput | SystemInstallationWhereInput[]
    type?: StringFilter<"SystemInstallation"> | string
    details?: StringFilter<"SystemInstallation"> | string
    installDate?: DateTimeNullableFilter<"SystemInstallation"> | Date | string | null
    lastService?: DateTimeNullableFilter<"SystemInstallation"> | Date | string | null
    propertyId?: StringFilter<"SystemInstallation"> | string
    property?: XOR<PropertyScalarRelationFilter, PropertyWhereInput>
  }, "id">

  export type SystemInstallationOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    details?: SortOrder
    installDate?: SortOrderInput | SortOrder
    lastService?: SortOrderInput | SortOrder
    propertyId?: SortOrder
    _count?: SystemInstallationCountOrderByAggregateInput
    _max?: SystemInstallationMaxOrderByAggregateInput
    _min?: SystemInstallationMinOrderByAggregateInput
  }

  export type SystemInstallationScalarWhereWithAggregatesInput = {
    AND?: SystemInstallationScalarWhereWithAggregatesInput | SystemInstallationScalarWhereWithAggregatesInput[]
    OR?: SystemInstallationScalarWhereWithAggregatesInput[]
    NOT?: SystemInstallationScalarWhereWithAggregatesInput | SystemInstallationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SystemInstallation"> | string
    type?: StringWithAggregatesFilter<"SystemInstallation"> | string
    details?: StringWithAggregatesFilter<"SystemInstallation"> | string
    installDate?: DateTimeNullableWithAggregatesFilter<"SystemInstallation"> | Date | string | null
    lastService?: DateTimeNullableWithAggregatesFilter<"SystemInstallation"> | Date | string | null
    propertyId?: StringWithAggregatesFilter<"SystemInstallation"> | string
  }

  export type ServiceRecordWhereInput = {
    AND?: ServiceRecordWhereInput | ServiceRecordWhereInput[]
    OR?: ServiceRecordWhereInput[]
    NOT?: ServiceRecordWhereInput | ServiceRecordWhereInput[]
    id?: StringFilter<"ServiceRecord"> | string
    date?: DateTimeFilter<"ServiceRecord"> | Date | string
    type?: StringFilter<"ServiceRecord"> | string
    description?: StringFilter<"ServiceRecord"> | string
    technician?: StringFilter<"ServiceRecord"> | string
    cost?: FloatFilter<"ServiceRecord"> | number
    propertyId?: StringFilter<"ServiceRecord"> | string
    property?: XOR<PropertyScalarRelationFilter, PropertyWhereInput>
  }

  export type ServiceRecordOrderByWithRelationInput = {
    id?: SortOrder
    date?: SortOrder
    type?: SortOrder
    description?: SortOrder
    technician?: SortOrder
    cost?: SortOrder
    propertyId?: SortOrder
    property?: PropertyOrderByWithRelationInput
  }

  export type ServiceRecordWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ServiceRecordWhereInput | ServiceRecordWhereInput[]
    OR?: ServiceRecordWhereInput[]
    NOT?: ServiceRecordWhereInput | ServiceRecordWhereInput[]
    date?: DateTimeFilter<"ServiceRecord"> | Date | string
    type?: StringFilter<"ServiceRecord"> | string
    description?: StringFilter<"ServiceRecord"> | string
    technician?: StringFilter<"ServiceRecord"> | string
    cost?: FloatFilter<"ServiceRecord"> | number
    propertyId?: StringFilter<"ServiceRecord"> | string
    property?: XOR<PropertyScalarRelationFilter, PropertyWhereInput>
  }, "id">

  export type ServiceRecordOrderByWithAggregationInput = {
    id?: SortOrder
    date?: SortOrder
    type?: SortOrder
    description?: SortOrder
    technician?: SortOrder
    cost?: SortOrder
    propertyId?: SortOrder
    _count?: ServiceRecordCountOrderByAggregateInput
    _avg?: ServiceRecordAvgOrderByAggregateInput
    _max?: ServiceRecordMaxOrderByAggregateInput
    _min?: ServiceRecordMinOrderByAggregateInput
    _sum?: ServiceRecordSumOrderByAggregateInput
  }

  export type ServiceRecordScalarWhereWithAggregatesInput = {
    AND?: ServiceRecordScalarWhereWithAggregatesInput | ServiceRecordScalarWhereWithAggregatesInput[]
    OR?: ServiceRecordScalarWhereWithAggregatesInput[]
    NOT?: ServiceRecordScalarWhereWithAggregatesInput | ServiceRecordScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ServiceRecord"> | string
    date?: DateTimeWithAggregatesFilter<"ServiceRecord"> | Date | string
    type?: StringWithAggregatesFilter<"ServiceRecord"> | string
    description?: StringWithAggregatesFilter<"ServiceRecord"> | string
    technician?: StringWithAggregatesFilter<"ServiceRecord"> | string
    cost?: FloatWithAggregatesFilter<"ServiceRecord"> | number
    propertyId?: StringWithAggregatesFilter<"ServiceRecord"> | string
  }

  export type ProjectWhereInput = {
    AND?: ProjectWhereInput | ProjectWhereInput[]
    OR?: ProjectWhereInput[]
    NOT?: ProjectWhereInput | ProjectWhereInput[]
    id?: StringFilter<"Project"> | string
    name?: StringFilter<"Project"> | string
    description?: StringFilter<"Project"> | string
    status?: StringFilter<"Project"> | string
    startDate?: DateTimeFilter<"Project"> | Date | string
    endDate?: DateTimeNullableFilter<"Project"> | Date | string | null
    propertyId?: StringFilter<"Project"> | string
    customerId?: StringFilter<"Project"> | string
    property?: XOR<PropertyScalarRelationFilter, PropertyWhereInput>
    teamMembers?: ProjectTeamMemberListRelationFilter
    milestones?: MilestoneListRelationFilter
    budget?: XOR<BudgetNullableScalarRelationFilter, BudgetWhereInput> | null
    documents?: DocumentListRelationFilter
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
    proposals?: ProposalListRelationFilter
  }

  export type ProjectOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    propertyId?: SortOrder
    customerId?: SortOrder
    property?: PropertyOrderByWithRelationInput
    teamMembers?: ProjectTeamMemberOrderByRelationAggregateInput
    milestones?: MilestoneOrderByRelationAggregateInput
    budget?: BudgetOrderByWithRelationInput
    documents?: DocumentOrderByRelationAggregateInput
    customer?: CustomerOrderByWithRelationInput
    proposals?: ProposalOrderByRelationAggregateInput
  }

  export type ProjectWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProjectWhereInput | ProjectWhereInput[]
    OR?: ProjectWhereInput[]
    NOT?: ProjectWhereInput | ProjectWhereInput[]
    name?: StringFilter<"Project"> | string
    description?: StringFilter<"Project"> | string
    status?: StringFilter<"Project"> | string
    startDate?: DateTimeFilter<"Project"> | Date | string
    endDate?: DateTimeNullableFilter<"Project"> | Date | string | null
    propertyId?: StringFilter<"Project"> | string
    customerId?: StringFilter<"Project"> | string
    property?: XOR<PropertyScalarRelationFilter, PropertyWhereInput>
    teamMembers?: ProjectTeamMemberListRelationFilter
    milestones?: MilestoneListRelationFilter
    budget?: XOR<BudgetNullableScalarRelationFilter, BudgetWhereInput> | null
    documents?: DocumentListRelationFilter
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
    proposals?: ProposalListRelationFilter
  }, "id">

  export type ProjectOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    propertyId?: SortOrder
    customerId?: SortOrder
    _count?: ProjectCountOrderByAggregateInput
    _max?: ProjectMaxOrderByAggregateInput
    _min?: ProjectMinOrderByAggregateInput
  }

  export type ProjectScalarWhereWithAggregatesInput = {
    AND?: ProjectScalarWhereWithAggregatesInput | ProjectScalarWhereWithAggregatesInput[]
    OR?: ProjectScalarWhereWithAggregatesInput[]
    NOT?: ProjectScalarWhereWithAggregatesInput | ProjectScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Project"> | string
    name?: StringWithAggregatesFilter<"Project"> | string
    description?: StringWithAggregatesFilter<"Project"> | string
    status?: StringWithAggregatesFilter<"Project"> | string
    startDate?: DateTimeWithAggregatesFilter<"Project"> | Date | string
    endDate?: DateTimeNullableWithAggregatesFilter<"Project"> | Date | string | null
    propertyId?: StringWithAggregatesFilter<"Project"> | string
    customerId?: StringWithAggregatesFilter<"Project"> | string
  }

  export type ProjectTeamMemberWhereInput = {
    AND?: ProjectTeamMemberWhereInput | ProjectTeamMemberWhereInput[]
    OR?: ProjectTeamMemberWhereInput[]
    NOT?: ProjectTeamMemberWhereInput | ProjectTeamMemberWhereInput[]
    id?: StringFilter<"ProjectTeamMember"> | string
    projectId?: StringFilter<"ProjectTeamMember"> | string
    teamMemberId?: StringFilter<"ProjectTeamMember"> | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    teamMember?: XOR<TeamMemberScalarRelationFilter, TeamMemberWhereInput>
  }

  export type ProjectTeamMemberOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    teamMemberId?: SortOrder
    project?: ProjectOrderByWithRelationInput
    teamMember?: TeamMemberOrderByWithRelationInput
  }

  export type ProjectTeamMemberWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProjectTeamMemberWhereInput | ProjectTeamMemberWhereInput[]
    OR?: ProjectTeamMemberWhereInput[]
    NOT?: ProjectTeamMemberWhereInput | ProjectTeamMemberWhereInput[]
    projectId?: StringFilter<"ProjectTeamMember"> | string
    teamMemberId?: StringFilter<"ProjectTeamMember"> | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    teamMember?: XOR<TeamMemberScalarRelationFilter, TeamMemberWhereInput>
  }, "id">

  export type ProjectTeamMemberOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    teamMemberId?: SortOrder
    _count?: ProjectTeamMemberCountOrderByAggregateInput
    _max?: ProjectTeamMemberMaxOrderByAggregateInput
    _min?: ProjectTeamMemberMinOrderByAggregateInput
  }

  export type ProjectTeamMemberScalarWhereWithAggregatesInput = {
    AND?: ProjectTeamMemberScalarWhereWithAggregatesInput | ProjectTeamMemberScalarWhereWithAggregatesInput[]
    OR?: ProjectTeamMemberScalarWhereWithAggregatesInput[]
    NOT?: ProjectTeamMemberScalarWhereWithAggregatesInput | ProjectTeamMemberScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProjectTeamMember"> | string
    projectId?: StringWithAggregatesFilter<"ProjectTeamMember"> | string
    teamMemberId?: StringWithAggregatesFilter<"ProjectTeamMember"> | string
  }

  export type TeamMemberWhereInput = {
    AND?: TeamMemberWhereInput | TeamMemberWhereInput[]
    OR?: TeamMemberWhereInput[]
    NOT?: TeamMemberWhereInput | TeamMemberWhereInput[]
    id?: StringFilter<"TeamMember"> | string
    name?: StringFilter<"TeamMember"> | string
    role?: StringFilter<"TeamMember"> | string
    email?: StringFilter<"TeamMember"> | string
    phone?: StringFilter<"TeamMember"> | string
    projects?: ProjectTeamMemberListRelationFilter
  }

  export type TeamMemberOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    role?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    projects?: ProjectTeamMemberOrderByRelationAggregateInput
  }

  export type TeamMemberWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TeamMemberWhereInput | TeamMemberWhereInput[]
    OR?: TeamMemberWhereInput[]
    NOT?: TeamMemberWhereInput | TeamMemberWhereInput[]
    name?: StringFilter<"TeamMember"> | string
    role?: StringFilter<"TeamMember"> | string
    email?: StringFilter<"TeamMember"> | string
    phone?: StringFilter<"TeamMember"> | string
    projects?: ProjectTeamMemberListRelationFilter
  }, "id">

  export type TeamMemberOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    role?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    _count?: TeamMemberCountOrderByAggregateInput
    _max?: TeamMemberMaxOrderByAggregateInput
    _min?: TeamMemberMinOrderByAggregateInput
  }

  export type TeamMemberScalarWhereWithAggregatesInput = {
    AND?: TeamMemberScalarWhereWithAggregatesInput | TeamMemberScalarWhereWithAggregatesInput[]
    OR?: TeamMemberScalarWhereWithAggregatesInput[]
    NOT?: TeamMemberScalarWhereWithAggregatesInput | TeamMemberScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TeamMember"> | string
    name?: StringWithAggregatesFilter<"TeamMember"> | string
    role?: StringWithAggregatesFilter<"TeamMember"> | string
    email?: StringWithAggregatesFilter<"TeamMember"> | string
    phone?: StringWithAggregatesFilter<"TeamMember"> | string
  }

  export type MilestoneWhereInput = {
    AND?: MilestoneWhereInput | MilestoneWhereInput[]
    OR?: MilestoneWhereInput[]
    NOT?: MilestoneWhereInput | MilestoneWhereInput[]
    id?: StringFilter<"Milestone"> | string
    name?: StringFilter<"Milestone"> | string
    description?: StringFilter<"Milestone"> | string
    status?: StringFilter<"Milestone"> | string
    dueDate?: DateTimeFilter<"Milestone"> | Date | string
    completedDate?: DateTimeNullableFilter<"Milestone"> | Date | string | null
    assignedTo?: StringNullableFilter<"Milestone"> | string | null
    projectId?: StringFilter<"Milestone"> | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
  }

  export type MilestoneOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    dueDate?: SortOrder
    completedDate?: SortOrderInput | SortOrder
    assignedTo?: SortOrderInput | SortOrder
    projectId?: SortOrder
    project?: ProjectOrderByWithRelationInput
  }

  export type MilestoneWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MilestoneWhereInput | MilestoneWhereInput[]
    OR?: MilestoneWhereInput[]
    NOT?: MilestoneWhereInput | MilestoneWhereInput[]
    name?: StringFilter<"Milestone"> | string
    description?: StringFilter<"Milestone"> | string
    status?: StringFilter<"Milestone"> | string
    dueDate?: DateTimeFilter<"Milestone"> | Date | string
    completedDate?: DateTimeNullableFilter<"Milestone"> | Date | string | null
    assignedTo?: StringNullableFilter<"Milestone"> | string | null
    projectId?: StringFilter<"Milestone"> | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
  }, "id">

  export type MilestoneOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    dueDate?: SortOrder
    completedDate?: SortOrderInput | SortOrder
    assignedTo?: SortOrderInput | SortOrder
    projectId?: SortOrder
    _count?: MilestoneCountOrderByAggregateInput
    _max?: MilestoneMaxOrderByAggregateInput
    _min?: MilestoneMinOrderByAggregateInput
  }

  export type MilestoneScalarWhereWithAggregatesInput = {
    AND?: MilestoneScalarWhereWithAggregatesInput | MilestoneScalarWhereWithAggregatesInput[]
    OR?: MilestoneScalarWhereWithAggregatesInput[]
    NOT?: MilestoneScalarWhereWithAggregatesInput | MilestoneScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Milestone"> | string
    name?: StringWithAggregatesFilter<"Milestone"> | string
    description?: StringWithAggregatesFilter<"Milestone"> | string
    status?: StringWithAggregatesFilter<"Milestone"> | string
    dueDate?: DateTimeWithAggregatesFilter<"Milestone"> | Date | string
    completedDate?: DateTimeNullableWithAggregatesFilter<"Milestone"> | Date | string | null
    assignedTo?: StringNullableWithAggregatesFilter<"Milestone"> | string | null
    projectId?: StringWithAggregatesFilter<"Milestone"> | string
  }

  export type BudgetWhereInput = {
    AND?: BudgetWhereInput | BudgetWhereInput[]
    OR?: BudgetWhereInput[]
    NOT?: BudgetWhereInput | BudgetWhereInput[]
    id?: StringFilter<"Budget"> | string
    currency?: StringFilter<"Budget"> | string
    total?: FloatFilter<"Budget"> | number
    spent?: FloatFilter<"Budget"> | number
    remaining?: FloatFilter<"Budget"> | number
    projectId?: StringFilter<"Budget"> | string
    lineItems?: BudgetLineItemListRelationFilter
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
  }

  export type BudgetOrderByWithRelationInput = {
    id?: SortOrder
    currency?: SortOrder
    total?: SortOrder
    spent?: SortOrder
    remaining?: SortOrder
    projectId?: SortOrder
    lineItems?: BudgetLineItemOrderByRelationAggregateInput
    project?: ProjectOrderByWithRelationInput
  }

  export type BudgetWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    projectId?: string
    AND?: BudgetWhereInput | BudgetWhereInput[]
    OR?: BudgetWhereInput[]
    NOT?: BudgetWhereInput | BudgetWhereInput[]
    currency?: StringFilter<"Budget"> | string
    total?: FloatFilter<"Budget"> | number
    spent?: FloatFilter<"Budget"> | number
    remaining?: FloatFilter<"Budget"> | number
    lineItems?: BudgetLineItemListRelationFilter
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
  }, "id" | "projectId">

  export type BudgetOrderByWithAggregationInput = {
    id?: SortOrder
    currency?: SortOrder
    total?: SortOrder
    spent?: SortOrder
    remaining?: SortOrder
    projectId?: SortOrder
    _count?: BudgetCountOrderByAggregateInput
    _avg?: BudgetAvgOrderByAggregateInput
    _max?: BudgetMaxOrderByAggregateInput
    _min?: BudgetMinOrderByAggregateInput
    _sum?: BudgetSumOrderByAggregateInput
  }

  export type BudgetScalarWhereWithAggregatesInput = {
    AND?: BudgetScalarWhereWithAggregatesInput | BudgetScalarWhereWithAggregatesInput[]
    OR?: BudgetScalarWhereWithAggregatesInput[]
    NOT?: BudgetScalarWhereWithAggregatesInput | BudgetScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Budget"> | string
    currency?: StringWithAggregatesFilter<"Budget"> | string
    total?: FloatWithAggregatesFilter<"Budget"> | number
    spent?: FloatWithAggregatesFilter<"Budget"> | number
    remaining?: FloatWithAggregatesFilter<"Budget"> | number
    projectId?: StringWithAggregatesFilter<"Budget"> | string
  }

  export type BudgetLineItemWhereInput = {
    AND?: BudgetLineItemWhereInput | BudgetLineItemWhereInput[]
    OR?: BudgetLineItemWhereInput[]
    NOT?: BudgetLineItemWhereInput | BudgetLineItemWhereInput[]
    id?: StringFilter<"BudgetLineItem"> | string
    description?: StringFilter<"BudgetLineItem"> | string
    amount?: FloatFilter<"BudgetLineItem"> | number
    category?: StringFilter<"BudgetLineItem"> | string
    budgetId?: StringFilter<"BudgetLineItem"> | string
    budget?: XOR<BudgetScalarRelationFilter, BudgetWhereInput>
  }

  export type BudgetLineItemOrderByWithRelationInput = {
    id?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    category?: SortOrder
    budgetId?: SortOrder
    budget?: BudgetOrderByWithRelationInput
  }

  export type BudgetLineItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BudgetLineItemWhereInput | BudgetLineItemWhereInput[]
    OR?: BudgetLineItemWhereInput[]
    NOT?: BudgetLineItemWhereInput | BudgetLineItemWhereInput[]
    description?: StringFilter<"BudgetLineItem"> | string
    amount?: FloatFilter<"BudgetLineItem"> | number
    category?: StringFilter<"BudgetLineItem"> | string
    budgetId?: StringFilter<"BudgetLineItem"> | string
    budget?: XOR<BudgetScalarRelationFilter, BudgetWhereInput>
  }, "id">

  export type BudgetLineItemOrderByWithAggregationInput = {
    id?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    category?: SortOrder
    budgetId?: SortOrder
    _count?: BudgetLineItemCountOrderByAggregateInput
    _avg?: BudgetLineItemAvgOrderByAggregateInput
    _max?: BudgetLineItemMaxOrderByAggregateInput
    _min?: BudgetLineItemMinOrderByAggregateInput
    _sum?: BudgetLineItemSumOrderByAggregateInput
  }

  export type BudgetLineItemScalarWhereWithAggregatesInput = {
    AND?: BudgetLineItemScalarWhereWithAggregatesInput | BudgetLineItemScalarWhereWithAggregatesInput[]
    OR?: BudgetLineItemScalarWhereWithAggregatesInput[]
    NOT?: BudgetLineItemScalarWhereWithAggregatesInput | BudgetLineItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BudgetLineItem"> | string
    description?: StringWithAggregatesFilter<"BudgetLineItem"> | string
    amount?: FloatWithAggregatesFilter<"BudgetLineItem"> | number
    category?: StringWithAggregatesFilter<"BudgetLineItem"> | string
    budgetId?: StringWithAggregatesFilter<"BudgetLineItem"> | string
  }

  export type InteractionWhereInput = {
    AND?: InteractionWhereInput | InteractionWhereInput[]
    OR?: InteractionWhereInput[]
    NOT?: InteractionWhereInput | InteractionWhereInput[]
    id?: StringFilter<"Interaction"> | string
    type?: StringFilter<"Interaction"> | string
    date?: DateTimeFilter<"Interaction"> | Date | string
    summary?: StringFilter<"Interaction"> | string
    details?: StringFilter<"Interaction"> | string
    followUpDate?: DateTimeNullableFilter<"Interaction"> | Date | string | null
    followUpNotes?: StringNullableFilter<"Interaction"> | string | null
    createdBy?: StringFilter<"Interaction"> | string
    createdAt?: DateTimeFilter<"Interaction"> | Date | string
    updatedAt?: DateTimeFilter<"Interaction"> | Date | string
    customerId?: StringFilter<"Interaction"> | string
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
  }

  export type InteractionOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    date?: SortOrder
    summary?: SortOrder
    details?: SortOrder
    followUpDate?: SortOrderInput | SortOrder
    followUpNotes?: SortOrderInput | SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    customerId?: SortOrder
    customer?: CustomerOrderByWithRelationInput
  }

  export type InteractionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InteractionWhereInput | InteractionWhereInput[]
    OR?: InteractionWhereInput[]
    NOT?: InteractionWhereInput | InteractionWhereInput[]
    type?: StringFilter<"Interaction"> | string
    date?: DateTimeFilter<"Interaction"> | Date | string
    summary?: StringFilter<"Interaction"> | string
    details?: StringFilter<"Interaction"> | string
    followUpDate?: DateTimeNullableFilter<"Interaction"> | Date | string | null
    followUpNotes?: StringNullableFilter<"Interaction"> | string | null
    createdBy?: StringFilter<"Interaction"> | string
    createdAt?: DateTimeFilter<"Interaction"> | Date | string
    updatedAt?: DateTimeFilter<"Interaction"> | Date | string
    customerId?: StringFilter<"Interaction"> | string
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
  }, "id">

  export type InteractionOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    date?: SortOrder
    summary?: SortOrder
    details?: SortOrder
    followUpDate?: SortOrderInput | SortOrder
    followUpNotes?: SortOrderInput | SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    customerId?: SortOrder
    _count?: InteractionCountOrderByAggregateInput
    _max?: InteractionMaxOrderByAggregateInput
    _min?: InteractionMinOrderByAggregateInput
  }

  export type InteractionScalarWhereWithAggregatesInput = {
    AND?: InteractionScalarWhereWithAggregatesInput | InteractionScalarWhereWithAggregatesInput[]
    OR?: InteractionScalarWhereWithAggregatesInput[]
    NOT?: InteractionScalarWhereWithAggregatesInput | InteractionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Interaction"> | string
    type?: StringWithAggregatesFilter<"Interaction"> | string
    date?: DateTimeWithAggregatesFilter<"Interaction"> | Date | string
    summary?: StringWithAggregatesFilter<"Interaction"> | string
    details?: StringWithAggregatesFilter<"Interaction"> | string
    followUpDate?: DateTimeNullableWithAggregatesFilter<"Interaction"> | Date | string | null
    followUpNotes?: StringNullableWithAggregatesFilter<"Interaction"> | string | null
    createdBy?: StringWithAggregatesFilter<"Interaction"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Interaction"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Interaction"> | Date | string
    customerId?: StringWithAggregatesFilter<"Interaction"> | string
  }

  export type CustomerMetricsWhereInput = {
    AND?: CustomerMetricsWhereInput | CustomerMetricsWhereInput[]
    OR?: CustomerMetricsWhereInput[]
    NOT?: CustomerMetricsWhereInput | CustomerMetricsWhereInput[]
    id?: StringFilter<"CustomerMetrics"> | string
    totalRevenue?: FloatFilter<"CustomerMetrics"> | number
    projectsCompleted?: IntFilter<"CustomerMetrics"> | number
    avgResponseTime?: FloatFilter<"CustomerMetrics"> | number
    lastInteraction?: DateTimeNullableFilter<"CustomerMetrics"> | Date | string | null
    nextScheduledInteraction?: DateTimeNullableFilter<"CustomerMetrics"> | Date | string | null
    customerId?: StringFilter<"CustomerMetrics"> | string
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
  }

  export type CustomerMetricsOrderByWithRelationInput = {
    id?: SortOrder
    totalRevenue?: SortOrder
    projectsCompleted?: SortOrder
    avgResponseTime?: SortOrder
    lastInteraction?: SortOrderInput | SortOrder
    nextScheduledInteraction?: SortOrderInput | SortOrder
    customerId?: SortOrder
    customer?: CustomerOrderByWithRelationInput
  }

  export type CustomerMetricsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    customerId?: string
    AND?: CustomerMetricsWhereInput | CustomerMetricsWhereInput[]
    OR?: CustomerMetricsWhereInput[]
    NOT?: CustomerMetricsWhereInput | CustomerMetricsWhereInput[]
    totalRevenue?: FloatFilter<"CustomerMetrics"> | number
    projectsCompleted?: IntFilter<"CustomerMetrics"> | number
    avgResponseTime?: FloatFilter<"CustomerMetrics"> | number
    lastInteraction?: DateTimeNullableFilter<"CustomerMetrics"> | Date | string | null
    nextScheduledInteraction?: DateTimeNullableFilter<"CustomerMetrics"> | Date | string | null
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
  }, "id" | "customerId">

  export type CustomerMetricsOrderByWithAggregationInput = {
    id?: SortOrder
    totalRevenue?: SortOrder
    projectsCompleted?: SortOrder
    avgResponseTime?: SortOrder
    lastInteraction?: SortOrderInput | SortOrder
    nextScheduledInteraction?: SortOrderInput | SortOrder
    customerId?: SortOrder
    _count?: CustomerMetricsCountOrderByAggregateInput
    _avg?: CustomerMetricsAvgOrderByAggregateInput
    _max?: CustomerMetricsMaxOrderByAggregateInput
    _min?: CustomerMetricsMinOrderByAggregateInput
    _sum?: CustomerMetricsSumOrderByAggregateInput
  }

  export type CustomerMetricsScalarWhereWithAggregatesInput = {
    AND?: CustomerMetricsScalarWhereWithAggregatesInput | CustomerMetricsScalarWhereWithAggregatesInput[]
    OR?: CustomerMetricsScalarWhereWithAggregatesInput[]
    NOT?: CustomerMetricsScalarWhereWithAggregatesInput | CustomerMetricsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CustomerMetrics"> | string
    totalRevenue?: FloatWithAggregatesFilter<"CustomerMetrics"> | number
    projectsCompleted?: IntWithAggregatesFilter<"CustomerMetrics"> | number
    avgResponseTime?: FloatWithAggregatesFilter<"CustomerMetrics"> | number
    lastInteraction?: DateTimeNullableWithAggregatesFilter<"CustomerMetrics"> | Date | string | null
    nextScheduledInteraction?: DateTimeNullableWithAggregatesFilter<"CustomerMetrics"> | Date | string | null
    customerId?: StringWithAggregatesFilter<"CustomerMetrics"> | string
  }

  export type ProposalWhereInput = {
    AND?: ProposalWhereInput | ProposalWhereInput[]
    OR?: ProposalWhereInput[]
    NOT?: ProposalWhereInput | ProposalWhereInput[]
    id?: StringFilter<"Proposal"> | string
    name?: StringFilter<"Proposal"> | string
    description?: StringNullableFilter<"Proposal"> | string | null
    status?: StringFilter<"Proposal"> | string
    customerPersona?: StringFilter<"Proposal"> | string
    voiceTranscript?: StringNullableFilter<"Proposal"> | string | null
    aiSummary?: StringNullableFilter<"Proposal"> | string | null
    totalAmount?: FloatFilter<"Proposal"> | number
    validUntil?: DateTimeNullableFilter<"Proposal"> | Date | string | null
    isExistingCustomer?: BoolFilter<"Proposal"> | boolean
    customerId?: StringNullableFilter<"Proposal"> | string | null
    prospectName?: StringNullableFilter<"Proposal"> | string | null
    prospectCompany?: StringNullableFilter<"Proposal"> | string | null
    prospectEmail?: StringNullableFilter<"Proposal"> | string | null
    prospectPhone?: StringNullableFilter<"Proposal"> | string | null
    prospectStatus?: StringNullableFilter<"Proposal"> | string | null
    propertyId?: StringNullableFilter<"Proposal"> | string | null
    projectId?: StringNullableFilter<"Proposal"> | string | null
    createdBy?: StringFilter<"Proposal"> | string
    createdAt?: DateTimeFilter<"Proposal"> | Date | string
    updatedAt?: DateTimeFilter<"Proposal"> | Date | string
    customer?: XOR<CustomerNullableScalarRelationFilter, CustomerWhereInput> | null
    property?: XOR<PropertyNullableScalarRelationFilter, PropertyWhereInput> | null
    project?: XOR<ProjectNullableScalarRelationFilter, ProjectWhereInput> | null
    items?: ProposalItemListRelationFilter
  }

  export type ProposalOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    customerPersona?: SortOrder
    voiceTranscript?: SortOrderInput | SortOrder
    aiSummary?: SortOrderInput | SortOrder
    totalAmount?: SortOrder
    validUntil?: SortOrderInput | SortOrder
    isExistingCustomer?: SortOrder
    customerId?: SortOrderInput | SortOrder
    prospectName?: SortOrderInput | SortOrder
    prospectCompany?: SortOrderInput | SortOrder
    prospectEmail?: SortOrderInput | SortOrder
    prospectPhone?: SortOrderInput | SortOrder
    prospectStatus?: SortOrderInput | SortOrder
    propertyId?: SortOrderInput | SortOrder
    projectId?: SortOrderInput | SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    customer?: CustomerOrderByWithRelationInput
    property?: PropertyOrderByWithRelationInput
    project?: ProjectOrderByWithRelationInput
    items?: ProposalItemOrderByRelationAggregateInput
  }

  export type ProposalWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProposalWhereInput | ProposalWhereInput[]
    OR?: ProposalWhereInput[]
    NOT?: ProposalWhereInput | ProposalWhereInput[]
    name?: StringFilter<"Proposal"> | string
    description?: StringNullableFilter<"Proposal"> | string | null
    status?: StringFilter<"Proposal"> | string
    customerPersona?: StringFilter<"Proposal"> | string
    voiceTranscript?: StringNullableFilter<"Proposal"> | string | null
    aiSummary?: StringNullableFilter<"Proposal"> | string | null
    totalAmount?: FloatFilter<"Proposal"> | number
    validUntil?: DateTimeNullableFilter<"Proposal"> | Date | string | null
    isExistingCustomer?: BoolFilter<"Proposal"> | boolean
    customerId?: StringNullableFilter<"Proposal"> | string | null
    prospectName?: StringNullableFilter<"Proposal"> | string | null
    prospectCompany?: StringNullableFilter<"Proposal"> | string | null
    prospectEmail?: StringNullableFilter<"Proposal"> | string | null
    prospectPhone?: StringNullableFilter<"Proposal"> | string | null
    prospectStatus?: StringNullableFilter<"Proposal"> | string | null
    propertyId?: StringNullableFilter<"Proposal"> | string | null
    projectId?: StringNullableFilter<"Proposal"> | string | null
    createdBy?: StringFilter<"Proposal"> | string
    createdAt?: DateTimeFilter<"Proposal"> | Date | string
    updatedAt?: DateTimeFilter<"Proposal"> | Date | string
    customer?: XOR<CustomerNullableScalarRelationFilter, CustomerWhereInput> | null
    property?: XOR<PropertyNullableScalarRelationFilter, PropertyWhereInput> | null
    project?: XOR<ProjectNullableScalarRelationFilter, ProjectWhereInput> | null
    items?: ProposalItemListRelationFilter
  }, "id">

  export type ProposalOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    customerPersona?: SortOrder
    voiceTranscript?: SortOrderInput | SortOrder
    aiSummary?: SortOrderInput | SortOrder
    totalAmount?: SortOrder
    validUntil?: SortOrderInput | SortOrder
    isExistingCustomer?: SortOrder
    customerId?: SortOrderInput | SortOrder
    prospectName?: SortOrderInput | SortOrder
    prospectCompany?: SortOrderInput | SortOrder
    prospectEmail?: SortOrderInput | SortOrder
    prospectPhone?: SortOrderInput | SortOrder
    prospectStatus?: SortOrderInput | SortOrder
    propertyId?: SortOrderInput | SortOrder
    projectId?: SortOrderInput | SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProposalCountOrderByAggregateInput
    _avg?: ProposalAvgOrderByAggregateInput
    _max?: ProposalMaxOrderByAggregateInput
    _min?: ProposalMinOrderByAggregateInput
    _sum?: ProposalSumOrderByAggregateInput
  }

  export type ProposalScalarWhereWithAggregatesInput = {
    AND?: ProposalScalarWhereWithAggregatesInput | ProposalScalarWhereWithAggregatesInput[]
    OR?: ProposalScalarWhereWithAggregatesInput[]
    NOT?: ProposalScalarWhereWithAggregatesInput | ProposalScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Proposal"> | string
    name?: StringWithAggregatesFilter<"Proposal"> | string
    description?: StringNullableWithAggregatesFilter<"Proposal"> | string | null
    status?: StringWithAggregatesFilter<"Proposal"> | string
    customerPersona?: StringWithAggregatesFilter<"Proposal"> | string
    voiceTranscript?: StringNullableWithAggregatesFilter<"Proposal"> | string | null
    aiSummary?: StringNullableWithAggregatesFilter<"Proposal"> | string | null
    totalAmount?: FloatWithAggregatesFilter<"Proposal"> | number
    validUntil?: DateTimeNullableWithAggregatesFilter<"Proposal"> | Date | string | null
    isExistingCustomer?: BoolWithAggregatesFilter<"Proposal"> | boolean
    customerId?: StringNullableWithAggregatesFilter<"Proposal"> | string | null
    prospectName?: StringNullableWithAggregatesFilter<"Proposal"> | string | null
    prospectCompany?: StringNullableWithAggregatesFilter<"Proposal"> | string | null
    prospectEmail?: StringNullableWithAggregatesFilter<"Proposal"> | string | null
    prospectPhone?: StringNullableWithAggregatesFilter<"Proposal"> | string | null
    prospectStatus?: StringNullableWithAggregatesFilter<"Proposal"> | string | null
    propertyId?: StringNullableWithAggregatesFilter<"Proposal"> | string | null
    projectId?: StringNullableWithAggregatesFilter<"Proposal"> | string | null
    createdBy?: StringWithAggregatesFilter<"Proposal"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Proposal"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Proposal"> | Date | string
  }

  export type ProposalItemWhereInput = {
    AND?: ProposalItemWhereInput | ProposalItemWhereInput[]
    OR?: ProposalItemWhereInput[]
    NOT?: ProposalItemWhereInput | ProposalItemWhereInput[]
    id?: StringFilter<"ProposalItem"> | string
    name?: StringFilter<"ProposalItem"> | string
    description?: StringNullableFilter<"ProposalItem"> | string | null
    category?: StringFilter<"ProposalItem"> | string
    quantity?: IntFilter<"ProposalItem"> | number
    unitPrice?: FloatFilter<"ProposalItem"> | number
    totalPrice?: FloatFilter<"ProposalItem"> | number
    productId?: StringNullableFilter<"ProposalItem"> | string | null
    proposalId?: StringFilter<"ProposalItem"> | string
    sortOrder?: IntFilter<"ProposalItem"> | number
    createdAt?: DateTimeFilter<"ProposalItem"> | Date | string
    updatedAt?: DateTimeFilter<"ProposalItem"> | Date | string
    product?: XOR<ProductNullableScalarRelationFilter, ProductWhereInput> | null
    proposal?: XOR<ProposalScalarRelationFilter, ProposalWhereInput>
  }

  export type ProposalItemOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
    productId?: SortOrderInput | SortOrder
    proposalId?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    product?: ProductOrderByWithRelationInput
    proposal?: ProposalOrderByWithRelationInput
  }

  export type ProposalItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProposalItemWhereInput | ProposalItemWhereInput[]
    OR?: ProposalItemWhereInput[]
    NOT?: ProposalItemWhereInput | ProposalItemWhereInput[]
    name?: StringFilter<"ProposalItem"> | string
    description?: StringNullableFilter<"ProposalItem"> | string | null
    category?: StringFilter<"ProposalItem"> | string
    quantity?: IntFilter<"ProposalItem"> | number
    unitPrice?: FloatFilter<"ProposalItem"> | number
    totalPrice?: FloatFilter<"ProposalItem"> | number
    productId?: StringNullableFilter<"ProposalItem"> | string | null
    proposalId?: StringFilter<"ProposalItem"> | string
    sortOrder?: IntFilter<"ProposalItem"> | number
    createdAt?: DateTimeFilter<"ProposalItem"> | Date | string
    updatedAt?: DateTimeFilter<"ProposalItem"> | Date | string
    product?: XOR<ProductNullableScalarRelationFilter, ProductWhereInput> | null
    proposal?: XOR<ProposalScalarRelationFilter, ProposalWhereInput>
  }, "id">

  export type ProposalItemOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
    productId?: SortOrderInput | SortOrder
    proposalId?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProposalItemCountOrderByAggregateInput
    _avg?: ProposalItemAvgOrderByAggregateInput
    _max?: ProposalItemMaxOrderByAggregateInput
    _min?: ProposalItemMinOrderByAggregateInput
    _sum?: ProposalItemSumOrderByAggregateInput
  }

  export type ProposalItemScalarWhereWithAggregatesInput = {
    AND?: ProposalItemScalarWhereWithAggregatesInput | ProposalItemScalarWhereWithAggregatesInput[]
    OR?: ProposalItemScalarWhereWithAggregatesInput[]
    NOT?: ProposalItemScalarWhereWithAggregatesInput | ProposalItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProposalItem"> | string
    name?: StringWithAggregatesFilter<"ProposalItem"> | string
    description?: StringNullableWithAggregatesFilter<"ProposalItem"> | string | null
    category?: StringWithAggregatesFilter<"ProposalItem"> | string
    quantity?: IntWithAggregatesFilter<"ProposalItem"> | number
    unitPrice?: FloatWithAggregatesFilter<"ProposalItem"> | number
    totalPrice?: FloatWithAggregatesFilter<"ProposalItem"> | number
    productId?: StringNullableWithAggregatesFilter<"ProposalItem"> | string | null
    proposalId?: StringWithAggregatesFilter<"ProposalItem"> | string
    sortOrder?: IntWithAggregatesFilter<"ProposalItem"> | number
    createdAt?: DateTimeWithAggregatesFilter<"ProposalItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ProposalItem"> | Date | string
  }

  export type ProductWhereInput = {
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    id?: StringFilter<"Product"> | string
    name?: StringFilter<"Product"> | string
    description?: StringNullableFilter<"Product"> | string | null
    category?: StringFilter<"Product"> | string
    brand?: StringNullableFilter<"Product"> | string | null
    model?: StringNullableFilter<"Product"> | string | null
    sku?: StringNullableFilter<"Product"> | string | null
    basePrice?: FloatFilter<"Product"> | number
    goodTierPrice?: FloatNullableFilter<"Product"> | number | null
    betterTierPrice?: FloatNullableFilter<"Product"> | number | null
    bestTierPrice?: FloatNullableFilter<"Product"> | number | null
    isActive?: BoolFilter<"Product"> | boolean
    specifications?: StringNullableFilter<"Product"> | string | null
    compatibility?: StringNullableFilter<"Product"> | string | null
    installation?: StringNullableFilter<"Product"> | string | null
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    proposalItems?: ProposalItemListRelationFilter
  }

  export type ProductOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    brand?: SortOrderInput | SortOrder
    model?: SortOrderInput | SortOrder
    sku?: SortOrderInput | SortOrder
    basePrice?: SortOrder
    goodTierPrice?: SortOrderInput | SortOrder
    betterTierPrice?: SortOrderInput | SortOrder
    bestTierPrice?: SortOrderInput | SortOrder
    isActive?: SortOrder
    specifications?: SortOrderInput | SortOrder
    compatibility?: SortOrderInput | SortOrder
    installation?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    proposalItems?: ProposalItemOrderByRelationAggregateInput
  }

  export type ProductWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sku?: string
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    name?: StringFilter<"Product"> | string
    description?: StringNullableFilter<"Product"> | string | null
    category?: StringFilter<"Product"> | string
    brand?: StringNullableFilter<"Product"> | string | null
    model?: StringNullableFilter<"Product"> | string | null
    basePrice?: FloatFilter<"Product"> | number
    goodTierPrice?: FloatNullableFilter<"Product"> | number | null
    betterTierPrice?: FloatNullableFilter<"Product"> | number | null
    bestTierPrice?: FloatNullableFilter<"Product"> | number | null
    isActive?: BoolFilter<"Product"> | boolean
    specifications?: StringNullableFilter<"Product"> | string | null
    compatibility?: StringNullableFilter<"Product"> | string | null
    installation?: StringNullableFilter<"Product"> | string | null
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    proposalItems?: ProposalItemListRelationFilter
  }, "id" | "sku">

  export type ProductOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    brand?: SortOrderInput | SortOrder
    model?: SortOrderInput | SortOrder
    sku?: SortOrderInput | SortOrder
    basePrice?: SortOrder
    goodTierPrice?: SortOrderInput | SortOrder
    betterTierPrice?: SortOrderInput | SortOrder
    bestTierPrice?: SortOrderInput | SortOrder
    isActive?: SortOrder
    specifications?: SortOrderInput | SortOrder
    compatibility?: SortOrderInput | SortOrder
    installation?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProductCountOrderByAggregateInput
    _avg?: ProductAvgOrderByAggregateInput
    _max?: ProductMaxOrderByAggregateInput
    _min?: ProductMinOrderByAggregateInput
    _sum?: ProductSumOrderByAggregateInput
  }

  export type ProductScalarWhereWithAggregatesInput = {
    AND?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    OR?: ProductScalarWhereWithAggregatesInput[]
    NOT?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Product"> | string
    name?: StringWithAggregatesFilter<"Product"> | string
    description?: StringNullableWithAggregatesFilter<"Product"> | string | null
    category?: StringWithAggregatesFilter<"Product"> | string
    brand?: StringNullableWithAggregatesFilter<"Product"> | string | null
    model?: StringNullableWithAggregatesFilter<"Product"> | string | null
    sku?: StringNullableWithAggregatesFilter<"Product"> | string | null
    basePrice?: FloatWithAggregatesFilter<"Product"> | number
    goodTierPrice?: FloatNullableWithAggregatesFilter<"Product"> | number | null
    betterTierPrice?: FloatNullableWithAggregatesFilter<"Product"> | number | null
    bestTierPrice?: FloatNullableWithAggregatesFilter<"Product"> | number | null
    isActive?: BoolWithAggregatesFilter<"Product"> | boolean
    specifications?: StringNullableWithAggregatesFilter<"Product"> | string | null
    compatibility?: StringNullableWithAggregatesFilter<"Product"> | string | null
    installation?: StringNullableWithAggregatesFilter<"Product"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
  }

  export type ProposalPersonaWhereInput = {
    AND?: ProposalPersonaWhereInput | ProposalPersonaWhereInput[]
    OR?: ProposalPersonaWhereInput[]
    NOT?: ProposalPersonaWhereInput | ProposalPersonaWhereInput[]
    id?: StringFilter<"ProposalPersona"> | string
    type?: StringFilter<"ProposalPersona"> | string
    name?: StringFilter<"ProposalPersona"> | string
    displayName?: StringFilter<"ProposalPersona"> | string
    description?: StringNullableFilter<"ProposalPersona"> | string | null
    keyFeatures?: StringFilter<"ProposalPersona"> | string
    recommendedTier?: StringFilter<"ProposalPersona"> | string
    isActive?: BoolFilter<"ProposalPersona"> | boolean
    createdAt?: DateTimeFilter<"ProposalPersona"> | Date | string
    updatedAt?: DateTimeFilter<"ProposalPersona"> | Date | string
  }

  export type ProposalPersonaOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    description?: SortOrderInput | SortOrder
    keyFeatures?: SortOrder
    recommendedTier?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProposalPersonaWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: ProposalPersonaWhereInput | ProposalPersonaWhereInput[]
    OR?: ProposalPersonaWhereInput[]
    NOT?: ProposalPersonaWhereInput | ProposalPersonaWhereInput[]
    type?: StringFilter<"ProposalPersona"> | string
    displayName?: StringFilter<"ProposalPersona"> | string
    description?: StringNullableFilter<"ProposalPersona"> | string | null
    keyFeatures?: StringFilter<"ProposalPersona"> | string
    recommendedTier?: StringFilter<"ProposalPersona"> | string
    isActive?: BoolFilter<"ProposalPersona"> | boolean
    createdAt?: DateTimeFilter<"ProposalPersona"> | Date | string
    updatedAt?: DateTimeFilter<"ProposalPersona"> | Date | string
  }, "id" | "name">

  export type ProposalPersonaOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    description?: SortOrderInput | SortOrder
    keyFeatures?: SortOrder
    recommendedTier?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProposalPersonaCountOrderByAggregateInput
    _max?: ProposalPersonaMaxOrderByAggregateInput
    _min?: ProposalPersonaMinOrderByAggregateInput
  }

  export type ProposalPersonaScalarWhereWithAggregatesInput = {
    AND?: ProposalPersonaScalarWhereWithAggregatesInput | ProposalPersonaScalarWhereWithAggregatesInput[]
    OR?: ProposalPersonaScalarWhereWithAggregatesInput[]
    NOT?: ProposalPersonaScalarWhereWithAggregatesInput | ProposalPersonaScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProposalPersona"> | string
    type?: StringWithAggregatesFilter<"ProposalPersona"> | string
    name?: StringWithAggregatesFilter<"ProposalPersona"> | string
    displayName?: StringWithAggregatesFilter<"ProposalPersona"> | string
    description?: StringNullableWithAggregatesFilter<"ProposalPersona"> | string | null
    keyFeatures?: StringWithAggregatesFilter<"ProposalPersona"> | string
    recommendedTier?: StringWithAggregatesFilter<"ProposalPersona"> | string
    isActive?: BoolWithAggregatesFilter<"ProposalPersona"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ProposalPersona"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ProposalPersona"> | Date | string
  }

  export type CustomerCreateInput = {
    id?: string
    type: string
    status: string
    firstName: string
    lastName: string
    company?: string | null
    email: string
    phone: string
    preferredCommunication: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    billingAddress?: AddressCreateNestedOneWithoutCustomerInput
    properties?: PropertyCreateNestedManyWithoutCustomerInput
    projects?: ProjectCreateNestedManyWithoutCustomerInput
    interactions?: InteractionCreateNestedManyWithoutCustomerInput
    tags?: TagCreateNestedManyWithoutCustomerInput
    metrics?: CustomerMetricsCreateNestedOneWithoutCustomerInput
    proposals?: ProposalCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateInput = {
    id?: string
    type: string
    status: string
    firstName: string
    lastName: string
    company?: string | null
    email: string
    phone: string
    preferredCommunication: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    billingAddress?: AddressUncheckedCreateNestedOneWithoutCustomerInput
    properties?: PropertyUncheckedCreateNestedManyWithoutCustomerInput
    projects?: ProjectUncheckedCreateNestedManyWithoutCustomerInput
    interactions?: InteractionUncheckedCreateNestedManyWithoutCustomerInput
    tags?: TagUncheckedCreateNestedManyWithoutCustomerInput
    metrics?: CustomerMetricsUncheckedCreateNestedOneWithoutCustomerInput
    proposals?: ProposalUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    company?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    preferredCommunication?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    billingAddress?: AddressUpdateOneWithoutCustomerNestedInput
    properties?: PropertyUpdateManyWithoutCustomerNestedInput
    projects?: ProjectUpdateManyWithoutCustomerNestedInput
    interactions?: InteractionUpdateManyWithoutCustomerNestedInput
    tags?: TagUpdateManyWithoutCustomerNestedInput
    metrics?: CustomerMetricsUpdateOneWithoutCustomerNestedInput
    proposals?: ProposalUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    company?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    preferredCommunication?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    billingAddress?: AddressUncheckedUpdateOneWithoutCustomerNestedInput
    properties?: PropertyUncheckedUpdateManyWithoutCustomerNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutCustomerNestedInput
    interactions?: InteractionUncheckedUpdateManyWithoutCustomerNestedInput
    tags?: TagUncheckedUpdateManyWithoutCustomerNestedInput
    metrics?: CustomerMetricsUncheckedUpdateOneWithoutCustomerNestedInput
    proposals?: ProposalUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerCreateManyInput = {
    id?: string
    type: string
    status: string
    firstName: string
    lastName: string
    company?: string | null
    email: string
    phone: string
    preferredCommunication: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    company?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    preferredCommunication?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    company?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    preferredCommunication?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagCreateInput = {
    id?: string
    name: string
    customer: CustomerCreateNestedOneWithoutTagsInput
  }

  export type TagUncheckedCreateInput = {
    id?: string
    name: string
    customerId: string
  }

  export type TagUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    customer?: CustomerUpdateOneRequiredWithoutTagsNestedInput
  }

  export type TagUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
  }

  export type TagCreateManyInput = {
    id?: string
    name: string
    customerId: string
  }

  export type TagUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type TagUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
  }

  export type AddressCreateInput = {
    id?: string
    street: string
    city: string
    state: string
    zipCode: string
    country: string
    customer: CustomerCreateNestedOneWithoutBillingAddressInput
    property?: PropertyCreateNestedOneWithoutAddressInput
  }

  export type AddressUncheckedCreateInput = {
    id?: string
    street: string
    city: string
    state: string
    zipCode: string
    country: string
    customerId: string
    property?: PropertyUncheckedCreateNestedOneWithoutAddressInput
  }

  export type AddressUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    customer?: CustomerUpdateOneRequiredWithoutBillingAddressNestedInput
    property?: PropertyUpdateOneWithoutAddressNestedInput
  }

  export type AddressUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    property?: PropertyUncheckedUpdateOneWithoutAddressNestedInput
  }

  export type AddressCreateManyInput = {
    id?: string
    street: string
    city: string
    state: string
    zipCode: string
    country: string
    customerId: string
  }

  export type AddressUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
  }

  export type AddressUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
  }

  export type PropertyCreateInput = {
    id?: string
    name: string
    type: string
    squareFootage: number
    bedrooms?: number | null
    bathrooms?: number | null
    yearBuilt?: number | null
    address?: AddressCreateNestedOneWithoutPropertyInput
    photos?: PhotoCreateNestedManyWithoutPropertyInput
    documents?: DocumentCreateNestedManyWithoutPropertyInput
    systems?: SystemInstallationCreateNestedManyWithoutPropertyInput
    serviceHistory?: ServiceRecordCreateNestedManyWithoutPropertyInput
    customer: CustomerCreateNestedOneWithoutPropertiesInput
    projects?: ProjectCreateNestedManyWithoutPropertyInput
    proposals?: ProposalCreateNestedManyWithoutPropertyInput
  }

  export type PropertyUncheckedCreateInput = {
    id?: string
    name: string
    type: string
    addressId?: string | null
    squareFootage: number
    bedrooms?: number | null
    bathrooms?: number | null
    yearBuilt?: number | null
    customerId: string
    photos?: PhotoUncheckedCreateNestedManyWithoutPropertyInput
    documents?: DocumentUncheckedCreateNestedManyWithoutPropertyInput
    systems?: SystemInstallationUncheckedCreateNestedManyWithoutPropertyInput
    serviceHistory?: ServiceRecordUncheckedCreateNestedManyWithoutPropertyInput
    projects?: ProjectUncheckedCreateNestedManyWithoutPropertyInput
    proposals?: ProposalUncheckedCreateNestedManyWithoutPropertyInput
  }

  export type PropertyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    squareFootage?: FloatFieldUpdateOperationsInput | number
    bedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    bathrooms?: NullableIntFieldUpdateOperationsInput | number | null
    yearBuilt?: NullableIntFieldUpdateOperationsInput | number | null
    address?: AddressUpdateOneWithoutPropertyNestedInput
    photos?: PhotoUpdateManyWithoutPropertyNestedInput
    documents?: DocumentUpdateManyWithoutPropertyNestedInput
    systems?: SystemInstallationUpdateManyWithoutPropertyNestedInput
    serviceHistory?: ServiceRecordUpdateManyWithoutPropertyNestedInput
    customer?: CustomerUpdateOneRequiredWithoutPropertiesNestedInput
    projects?: ProjectUpdateManyWithoutPropertyNestedInput
    proposals?: ProposalUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    addressId?: NullableStringFieldUpdateOperationsInput | string | null
    squareFootage?: FloatFieldUpdateOperationsInput | number
    bedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    bathrooms?: NullableIntFieldUpdateOperationsInput | number | null
    yearBuilt?: NullableIntFieldUpdateOperationsInput | number | null
    customerId?: StringFieldUpdateOperationsInput | string
    photos?: PhotoUncheckedUpdateManyWithoutPropertyNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutPropertyNestedInput
    systems?: SystemInstallationUncheckedUpdateManyWithoutPropertyNestedInput
    serviceHistory?: ServiceRecordUncheckedUpdateManyWithoutPropertyNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutPropertyNestedInput
    proposals?: ProposalUncheckedUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyCreateManyInput = {
    id?: string
    name: string
    type: string
    addressId?: string | null
    squareFootage: number
    bedrooms?: number | null
    bathrooms?: number | null
    yearBuilt?: number | null
    customerId: string
  }

  export type PropertyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    squareFootage?: FloatFieldUpdateOperationsInput | number
    bedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    bathrooms?: NullableIntFieldUpdateOperationsInput | number | null
    yearBuilt?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PropertyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    addressId?: NullableStringFieldUpdateOperationsInput | string | null
    squareFootage?: FloatFieldUpdateOperationsInput | number
    bedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    bathrooms?: NullableIntFieldUpdateOperationsInput | number | null
    yearBuilt?: NullableIntFieldUpdateOperationsInput | number | null
    customerId?: StringFieldUpdateOperationsInput | string
  }

  export type PhotoCreateInput = {
    id?: string
    url: string
    uploadedAt?: Date | string
    uploadedBy: string
    property: PropertyCreateNestedOneWithoutPhotosInput
  }

  export type PhotoUncheckedCreateInput = {
    id?: string
    url: string
    propertyId: string
    uploadedAt?: Date | string
    uploadedBy: string
  }

  export type PhotoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedBy?: StringFieldUpdateOperationsInput | string
    property?: PropertyUpdateOneRequiredWithoutPhotosNestedInput
  }

  export type PhotoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedBy?: StringFieldUpdateOperationsInput | string
  }

  export type PhotoCreateManyInput = {
    id?: string
    url: string
    propertyId: string
    uploadedAt?: Date | string
    uploadedBy: string
  }

  export type PhotoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedBy?: StringFieldUpdateOperationsInput | string
  }

  export type PhotoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedBy?: StringFieldUpdateOperationsInput | string
  }

  export type DocumentCreateInput = {
    id?: string
    name: string
    url: string
    type: string
    uploadedAt?: Date | string
    uploadedBy: string
    property?: PropertyCreateNestedOneWithoutDocumentsInput
    project?: ProjectCreateNestedOneWithoutDocumentsInput
  }

  export type DocumentUncheckedCreateInput = {
    id?: string
    name: string
    url: string
    type: string
    propertyId?: string | null
    projectId?: string | null
    uploadedAt?: Date | string
    uploadedBy: string
  }

  export type DocumentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedBy?: StringFieldUpdateOperationsInput | string
    property?: PropertyUpdateOneWithoutDocumentsNestedInput
    project?: ProjectUpdateOneWithoutDocumentsNestedInput
  }

  export type DocumentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    propertyId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedBy?: StringFieldUpdateOperationsInput | string
  }

  export type DocumentCreateManyInput = {
    id?: string
    name: string
    url: string
    type: string
    propertyId?: string | null
    projectId?: string | null
    uploadedAt?: Date | string
    uploadedBy: string
  }

  export type DocumentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedBy?: StringFieldUpdateOperationsInput | string
  }

  export type DocumentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    propertyId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedBy?: StringFieldUpdateOperationsInput | string
  }

  export type SystemInstallationCreateInput = {
    id?: string
    type: string
    details: string
    installDate?: Date | string | null
    lastService?: Date | string | null
    property: PropertyCreateNestedOneWithoutSystemsInput
  }

  export type SystemInstallationUncheckedCreateInput = {
    id?: string
    type: string
    details: string
    installDate?: Date | string | null
    lastService?: Date | string | null
    propertyId: string
  }

  export type SystemInstallationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    details?: StringFieldUpdateOperationsInput | string
    installDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastService?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    property?: PropertyUpdateOneRequiredWithoutSystemsNestedInput
  }

  export type SystemInstallationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    details?: StringFieldUpdateOperationsInput | string
    installDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastService?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    propertyId?: StringFieldUpdateOperationsInput | string
  }

  export type SystemInstallationCreateManyInput = {
    id?: string
    type: string
    details: string
    installDate?: Date | string | null
    lastService?: Date | string | null
    propertyId: string
  }

  export type SystemInstallationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    details?: StringFieldUpdateOperationsInput | string
    installDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastService?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SystemInstallationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    details?: StringFieldUpdateOperationsInput | string
    installDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastService?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    propertyId?: StringFieldUpdateOperationsInput | string
  }

  export type ServiceRecordCreateInput = {
    id?: string
    date: Date | string
    type: string
    description: string
    technician: string
    cost: number
    property: PropertyCreateNestedOneWithoutServiceHistoryInput
  }

  export type ServiceRecordUncheckedCreateInput = {
    id?: string
    date: Date | string
    type: string
    description: string
    technician: string
    cost: number
    propertyId: string
  }

  export type ServiceRecordUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    technician?: StringFieldUpdateOperationsInput | string
    cost?: FloatFieldUpdateOperationsInput | number
    property?: PropertyUpdateOneRequiredWithoutServiceHistoryNestedInput
  }

  export type ServiceRecordUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    technician?: StringFieldUpdateOperationsInput | string
    cost?: FloatFieldUpdateOperationsInput | number
    propertyId?: StringFieldUpdateOperationsInput | string
  }

  export type ServiceRecordCreateManyInput = {
    id?: string
    date: Date | string
    type: string
    description: string
    technician: string
    cost: number
    propertyId: string
  }

  export type ServiceRecordUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    technician?: StringFieldUpdateOperationsInput | string
    cost?: FloatFieldUpdateOperationsInput | number
  }

  export type ServiceRecordUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    technician?: StringFieldUpdateOperationsInput | string
    cost?: FloatFieldUpdateOperationsInput | number
    propertyId?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectCreateInput = {
    id?: string
    name: string
    description: string
    status: string
    startDate: Date | string
    endDate?: Date | string | null
    property: PropertyCreateNestedOneWithoutProjectsInput
    teamMembers?: ProjectTeamMemberCreateNestedManyWithoutProjectInput
    milestones?: MilestoneCreateNestedManyWithoutProjectInput
    budget?: BudgetCreateNestedOneWithoutProjectInput
    documents?: DocumentCreateNestedManyWithoutProjectInput
    customer: CustomerCreateNestedOneWithoutProjectsInput
    proposals?: ProposalCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateInput = {
    id?: string
    name: string
    description: string
    status: string
    startDate: Date | string
    endDate?: Date | string | null
    propertyId: string
    customerId: string
    teamMembers?: ProjectTeamMemberUncheckedCreateNestedManyWithoutProjectInput
    milestones?: MilestoneUncheckedCreateNestedManyWithoutProjectInput
    budget?: BudgetUncheckedCreateNestedOneWithoutProjectInput
    documents?: DocumentUncheckedCreateNestedManyWithoutProjectInput
    proposals?: ProposalUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    property?: PropertyUpdateOneRequiredWithoutProjectsNestedInput
    teamMembers?: ProjectTeamMemberUpdateManyWithoutProjectNestedInput
    milestones?: MilestoneUpdateManyWithoutProjectNestedInput
    budget?: BudgetUpdateOneWithoutProjectNestedInput
    documents?: DocumentUpdateManyWithoutProjectNestedInput
    customer?: CustomerUpdateOneRequiredWithoutProjectsNestedInput
    proposals?: ProposalUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    propertyId?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    teamMembers?: ProjectTeamMemberUncheckedUpdateManyWithoutProjectNestedInput
    milestones?: MilestoneUncheckedUpdateManyWithoutProjectNestedInput
    budget?: BudgetUncheckedUpdateOneWithoutProjectNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutProjectNestedInput
    proposals?: ProposalUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectCreateManyInput = {
    id?: string
    name: string
    description: string
    status: string
    startDate: Date | string
    endDate?: Date | string | null
    propertyId: string
    customerId: string
  }

  export type ProjectUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProjectUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    propertyId?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectTeamMemberCreateInput = {
    id?: string
    project: ProjectCreateNestedOneWithoutTeamMembersInput
    teamMember: TeamMemberCreateNestedOneWithoutProjectsInput
  }

  export type ProjectTeamMemberUncheckedCreateInput = {
    id?: string
    projectId: string
    teamMemberId: string
  }

  export type ProjectTeamMemberUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    project?: ProjectUpdateOneRequiredWithoutTeamMembersNestedInput
    teamMember?: TeamMemberUpdateOneRequiredWithoutProjectsNestedInput
  }

  export type ProjectTeamMemberUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    teamMemberId?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectTeamMemberCreateManyInput = {
    id?: string
    projectId: string
    teamMemberId: string
  }

  export type ProjectTeamMemberUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectTeamMemberUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    teamMemberId?: StringFieldUpdateOperationsInput | string
  }

  export type TeamMemberCreateInput = {
    id?: string
    name: string
    role: string
    email: string
    phone: string
    projects?: ProjectTeamMemberCreateNestedManyWithoutTeamMemberInput
  }

  export type TeamMemberUncheckedCreateInput = {
    id?: string
    name: string
    role: string
    email: string
    phone: string
    projects?: ProjectTeamMemberUncheckedCreateNestedManyWithoutTeamMemberInput
  }

  export type TeamMemberUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    projects?: ProjectTeamMemberUpdateManyWithoutTeamMemberNestedInput
  }

  export type TeamMemberUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    projects?: ProjectTeamMemberUncheckedUpdateManyWithoutTeamMemberNestedInput
  }

  export type TeamMemberCreateManyInput = {
    id?: string
    name: string
    role: string
    email: string
    phone: string
  }

  export type TeamMemberUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
  }

  export type TeamMemberUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
  }

  export type MilestoneCreateInput = {
    id?: string
    name: string
    description: string
    status: string
    dueDate: Date | string
    completedDate?: Date | string | null
    assignedTo?: string | null
    project: ProjectCreateNestedOneWithoutMilestonesInput
  }

  export type MilestoneUncheckedCreateInput = {
    id?: string
    name: string
    description: string
    status: string
    dueDate: Date | string
    completedDate?: Date | string | null
    assignedTo?: string | null
    projectId: string
  }

  export type MilestoneUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    project?: ProjectUpdateOneRequiredWithoutMilestonesNestedInput
  }

  export type MilestoneUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: StringFieldUpdateOperationsInput | string
  }

  export type MilestoneCreateManyInput = {
    id?: string
    name: string
    description: string
    status: string
    dueDate: Date | string
    completedDate?: Date | string | null
    assignedTo?: string | null
    projectId: string
  }

  export type MilestoneUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MilestoneUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: StringFieldUpdateOperationsInput | string
  }

  export type BudgetCreateInput = {
    id?: string
    currency: string
    total: number
    spent: number
    remaining: number
    lineItems?: BudgetLineItemCreateNestedManyWithoutBudgetInput
    project: ProjectCreateNestedOneWithoutBudgetInput
  }

  export type BudgetUncheckedCreateInput = {
    id?: string
    currency: string
    total: number
    spent: number
    remaining: number
    projectId: string
    lineItems?: BudgetLineItemUncheckedCreateNestedManyWithoutBudgetInput
  }

  export type BudgetUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    total?: FloatFieldUpdateOperationsInput | number
    spent?: FloatFieldUpdateOperationsInput | number
    remaining?: FloatFieldUpdateOperationsInput | number
    lineItems?: BudgetLineItemUpdateManyWithoutBudgetNestedInput
    project?: ProjectUpdateOneRequiredWithoutBudgetNestedInput
  }

  export type BudgetUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    total?: FloatFieldUpdateOperationsInput | number
    spent?: FloatFieldUpdateOperationsInput | number
    remaining?: FloatFieldUpdateOperationsInput | number
    projectId?: StringFieldUpdateOperationsInput | string
    lineItems?: BudgetLineItemUncheckedUpdateManyWithoutBudgetNestedInput
  }

  export type BudgetCreateManyInput = {
    id?: string
    currency: string
    total: number
    spent: number
    remaining: number
    projectId: string
  }

  export type BudgetUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    total?: FloatFieldUpdateOperationsInput | number
    spent?: FloatFieldUpdateOperationsInput | number
    remaining?: FloatFieldUpdateOperationsInput | number
  }

  export type BudgetUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    total?: FloatFieldUpdateOperationsInput | number
    spent?: FloatFieldUpdateOperationsInput | number
    remaining?: FloatFieldUpdateOperationsInput | number
    projectId?: StringFieldUpdateOperationsInput | string
  }

  export type BudgetLineItemCreateInput = {
    id?: string
    description: string
    amount: number
    category: string
    budget: BudgetCreateNestedOneWithoutLineItemsInput
  }

  export type BudgetLineItemUncheckedCreateInput = {
    id?: string
    description: string
    amount: number
    category: string
    budgetId: string
  }

  export type BudgetLineItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    budget?: BudgetUpdateOneRequiredWithoutLineItemsNestedInput
  }

  export type BudgetLineItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    budgetId?: StringFieldUpdateOperationsInput | string
  }

  export type BudgetLineItemCreateManyInput = {
    id?: string
    description: string
    amount: number
    category: string
    budgetId: string
  }

  export type BudgetLineItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
  }

  export type BudgetLineItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    budgetId?: StringFieldUpdateOperationsInput | string
  }

  export type InteractionCreateInput = {
    id?: string
    type: string
    date: Date | string
    summary: string
    details: string
    followUpDate?: Date | string | null
    followUpNotes?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomerCreateNestedOneWithoutInteractionsInput
  }

  export type InteractionUncheckedCreateInput = {
    id?: string
    type: string
    date: Date | string
    summary: string
    details: string
    followUpDate?: Date | string | null
    followUpNotes?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    customerId: string
  }

  export type InteractionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    summary?: StringFieldUpdateOperationsInput | string
    details?: StringFieldUpdateOperationsInput | string
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followUpNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutInteractionsNestedInput
  }

  export type InteractionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    summary?: StringFieldUpdateOperationsInput | string
    details?: StringFieldUpdateOperationsInput | string
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followUpNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerId?: StringFieldUpdateOperationsInput | string
  }

  export type InteractionCreateManyInput = {
    id?: string
    type: string
    date: Date | string
    summary: string
    details: string
    followUpDate?: Date | string | null
    followUpNotes?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    customerId: string
  }

  export type InteractionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    summary?: StringFieldUpdateOperationsInput | string
    details?: StringFieldUpdateOperationsInput | string
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followUpNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InteractionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    summary?: StringFieldUpdateOperationsInput | string
    details?: StringFieldUpdateOperationsInput | string
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followUpNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerId?: StringFieldUpdateOperationsInput | string
  }

  export type CustomerMetricsCreateInput = {
    id?: string
    totalRevenue: number
    projectsCompleted: number
    avgResponseTime: number
    lastInteraction?: Date | string | null
    nextScheduledInteraction?: Date | string | null
    customer: CustomerCreateNestedOneWithoutMetricsInput
  }

  export type CustomerMetricsUncheckedCreateInput = {
    id?: string
    totalRevenue: number
    projectsCompleted: number
    avgResponseTime: number
    lastInteraction?: Date | string | null
    nextScheduledInteraction?: Date | string | null
    customerId: string
  }

  export type CustomerMetricsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalRevenue?: FloatFieldUpdateOperationsInput | number
    projectsCompleted?: IntFieldUpdateOperationsInput | number
    avgResponseTime?: FloatFieldUpdateOperationsInput | number
    lastInteraction?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextScheduledInteraction?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customer?: CustomerUpdateOneRequiredWithoutMetricsNestedInput
  }

  export type CustomerMetricsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalRevenue?: FloatFieldUpdateOperationsInput | number
    projectsCompleted?: IntFieldUpdateOperationsInput | number
    avgResponseTime?: FloatFieldUpdateOperationsInput | number
    lastInteraction?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextScheduledInteraction?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customerId?: StringFieldUpdateOperationsInput | string
  }

  export type CustomerMetricsCreateManyInput = {
    id?: string
    totalRevenue: number
    projectsCompleted: number
    avgResponseTime: number
    lastInteraction?: Date | string | null
    nextScheduledInteraction?: Date | string | null
    customerId: string
  }

  export type CustomerMetricsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalRevenue?: FloatFieldUpdateOperationsInput | number
    projectsCompleted?: IntFieldUpdateOperationsInput | number
    avgResponseTime?: FloatFieldUpdateOperationsInput | number
    lastInteraction?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextScheduledInteraction?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CustomerMetricsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalRevenue?: FloatFieldUpdateOperationsInput | number
    projectsCompleted?: IntFieldUpdateOperationsInput | number
    avgResponseTime?: FloatFieldUpdateOperationsInput | number
    lastInteraction?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextScheduledInteraction?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customerId?: StringFieldUpdateOperationsInput | string
  }

  export type ProposalCreateInput = {
    id?: string
    name: string
    description?: string | null
    status: string
    customerPersona: string
    voiceTranscript?: string | null
    aiSummary?: string | null
    totalAmount?: number
    validUntil?: Date | string | null
    isExistingCustomer?: boolean
    prospectName?: string | null
    prospectCompany?: string | null
    prospectEmail?: string | null
    prospectPhone?: string | null
    prospectStatus?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    customer?: CustomerCreateNestedOneWithoutProposalsInput
    property?: PropertyCreateNestedOneWithoutProposalsInput
    project?: ProjectCreateNestedOneWithoutProposalsInput
    items?: ProposalItemCreateNestedManyWithoutProposalInput
  }

  export type ProposalUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    status: string
    customerPersona: string
    voiceTranscript?: string | null
    aiSummary?: string | null
    totalAmount?: number
    validUntil?: Date | string | null
    isExistingCustomer?: boolean
    customerId?: string | null
    prospectName?: string | null
    prospectCompany?: string | null
    prospectEmail?: string | null
    prospectPhone?: string | null
    prospectStatus?: string | null
    propertyId?: string | null
    projectId?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: ProposalItemUncheckedCreateNestedManyWithoutProposalInput
  }

  export type ProposalUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    customerPersona?: StringFieldUpdateOperationsInput | string
    voiceTranscript?: NullableStringFieldUpdateOperationsInput | string | null
    aiSummary?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: FloatFieldUpdateOperationsInput | number
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isExistingCustomer?: BoolFieldUpdateOperationsInput | boolean
    prospectName?: NullableStringFieldUpdateOperationsInput | string | null
    prospectCompany?: NullableStringFieldUpdateOperationsInput | string | null
    prospectEmail?: NullableStringFieldUpdateOperationsInput | string | null
    prospectPhone?: NullableStringFieldUpdateOperationsInput | string | null
    prospectStatus?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneWithoutProposalsNestedInput
    property?: PropertyUpdateOneWithoutProposalsNestedInput
    project?: ProjectUpdateOneWithoutProposalsNestedInput
    items?: ProposalItemUpdateManyWithoutProposalNestedInput
  }

  export type ProposalUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    customerPersona?: StringFieldUpdateOperationsInput | string
    voiceTranscript?: NullableStringFieldUpdateOperationsInput | string | null
    aiSummary?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: FloatFieldUpdateOperationsInput | number
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isExistingCustomer?: BoolFieldUpdateOperationsInput | boolean
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    prospectName?: NullableStringFieldUpdateOperationsInput | string | null
    prospectCompany?: NullableStringFieldUpdateOperationsInput | string | null
    prospectEmail?: NullableStringFieldUpdateOperationsInput | string | null
    prospectPhone?: NullableStringFieldUpdateOperationsInput | string | null
    prospectStatus?: NullableStringFieldUpdateOperationsInput | string | null
    propertyId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: ProposalItemUncheckedUpdateManyWithoutProposalNestedInput
  }

  export type ProposalCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    status: string
    customerPersona: string
    voiceTranscript?: string | null
    aiSummary?: string | null
    totalAmount?: number
    validUntil?: Date | string | null
    isExistingCustomer?: boolean
    customerId?: string | null
    prospectName?: string | null
    prospectCompany?: string | null
    prospectEmail?: string | null
    prospectPhone?: string | null
    prospectStatus?: string | null
    propertyId?: string | null
    projectId?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProposalUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    customerPersona?: StringFieldUpdateOperationsInput | string
    voiceTranscript?: NullableStringFieldUpdateOperationsInput | string | null
    aiSummary?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: FloatFieldUpdateOperationsInput | number
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isExistingCustomer?: BoolFieldUpdateOperationsInput | boolean
    prospectName?: NullableStringFieldUpdateOperationsInput | string | null
    prospectCompany?: NullableStringFieldUpdateOperationsInput | string | null
    prospectEmail?: NullableStringFieldUpdateOperationsInput | string | null
    prospectPhone?: NullableStringFieldUpdateOperationsInput | string | null
    prospectStatus?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProposalUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    customerPersona?: StringFieldUpdateOperationsInput | string
    voiceTranscript?: NullableStringFieldUpdateOperationsInput | string | null
    aiSummary?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: FloatFieldUpdateOperationsInput | number
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isExistingCustomer?: BoolFieldUpdateOperationsInput | boolean
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    prospectName?: NullableStringFieldUpdateOperationsInput | string | null
    prospectCompany?: NullableStringFieldUpdateOperationsInput | string | null
    prospectEmail?: NullableStringFieldUpdateOperationsInput | string | null
    prospectPhone?: NullableStringFieldUpdateOperationsInput | string | null
    prospectStatus?: NullableStringFieldUpdateOperationsInput | string | null
    propertyId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProposalItemCreateInput = {
    id?: string
    name: string
    description?: string | null
    category: string
    quantity?: number
    unitPrice: number
    totalPrice: number
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    product?: ProductCreateNestedOneWithoutProposalItemsInput
    proposal: ProposalCreateNestedOneWithoutItemsInput
  }

  export type ProposalItemUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    category: string
    quantity?: number
    unitPrice: number
    totalPrice: number
    productId?: string | null
    proposalId: string
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProposalItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneWithoutProposalItemsNestedInput
    proposal?: ProposalUpdateOneRequiredWithoutItemsNestedInput
  }

  export type ProposalItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    proposalId?: StringFieldUpdateOperationsInput | string
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProposalItemCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    category: string
    quantity?: number
    unitPrice: number
    totalPrice: number
    productId?: string | null
    proposalId: string
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProposalItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProposalItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    proposalId?: StringFieldUpdateOperationsInput | string
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCreateInput = {
    id?: string
    name: string
    description?: string | null
    category: string
    brand?: string | null
    model?: string | null
    sku?: string | null
    basePrice: number
    goodTierPrice?: number | null
    betterTierPrice?: number | null
    bestTierPrice?: number | null
    isActive?: boolean
    specifications?: string | null
    compatibility?: string | null
    installation?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    proposalItems?: ProposalItemCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    category: string
    brand?: string | null
    model?: string | null
    sku?: string | null
    basePrice: number
    goodTierPrice?: number | null
    betterTierPrice?: number | null
    bestTierPrice?: number | null
    isActive?: boolean
    specifications?: string | null
    compatibility?: string | null
    installation?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    proposalItems?: ProposalItemUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: FloatFieldUpdateOperationsInput | number
    goodTierPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    betterTierPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    bestTierPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    specifications?: NullableStringFieldUpdateOperationsInput | string | null
    compatibility?: NullableStringFieldUpdateOperationsInput | string | null
    installation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    proposalItems?: ProposalItemUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: FloatFieldUpdateOperationsInput | number
    goodTierPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    betterTierPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    bestTierPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    specifications?: NullableStringFieldUpdateOperationsInput | string | null
    compatibility?: NullableStringFieldUpdateOperationsInput | string | null
    installation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    proposalItems?: ProposalItemUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    category: string
    brand?: string | null
    model?: string | null
    sku?: string | null
    basePrice: number
    goodTierPrice?: number | null
    betterTierPrice?: number | null
    bestTierPrice?: number | null
    isActive?: boolean
    specifications?: string | null
    compatibility?: string | null
    installation?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: FloatFieldUpdateOperationsInput | number
    goodTierPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    betterTierPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    bestTierPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    specifications?: NullableStringFieldUpdateOperationsInput | string | null
    compatibility?: NullableStringFieldUpdateOperationsInput | string | null
    installation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: FloatFieldUpdateOperationsInput | number
    goodTierPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    betterTierPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    bestTierPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    specifications?: NullableStringFieldUpdateOperationsInput | string | null
    compatibility?: NullableStringFieldUpdateOperationsInput | string | null
    installation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProposalPersonaCreateInput = {
    id?: string
    type: string
    name: string
    displayName: string
    description?: string | null
    keyFeatures: string
    recommendedTier: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProposalPersonaUncheckedCreateInput = {
    id?: string
    type: string
    name: string
    displayName: string
    description?: string | null
    keyFeatures: string
    recommendedTier: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProposalPersonaUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    keyFeatures?: StringFieldUpdateOperationsInput | string
    recommendedTier?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProposalPersonaUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    keyFeatures?: StringFieldUpdateOperationsInput | string
    recommendedTier?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProposalPersonaCreateManyInput = {
    id?: string
    type: string
    name: string
    displayName: string
    description?: string | null
    keyFeatures: string
    recommendedTier: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProposalPersonaUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    keyFeatures?: StringFieldUpdateOperationsInput | string
    recommendedTier?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProposalPersonaUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    keyFeatures?: StringFieldUpdateOperationsInput | string
    recommendedTier?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type AddressNullableScalarRelationFilter = {
    is?: AddressWhereInput | null
    isNot?: AddressWhereInput | null
  }

  export type PropertyListRelationFilter = {
    every?: PropertyWhereInput
    some?: PropertyWhereInput
    none?: PropertyWhereInput
  }

  export type ProjectListRelationFilter = {
    every?: ProjectWhereInput
    some?: ProjectWhereInput
    none?: ProjectWhereInput
  }

  export type InteractionListRelationFilter = {
    every?: InteractionWhereInput
    some?: InteractionWhereInput
    none?: InteractionWhereInput
  }

  export type TagListRelationFilter = {
    every?: TagWhereInput
    some?: TagWhereInput
    none?: TagWhereInput
  }

  export type CustomerMetricsNullableScalarRelationFilter = {
    is?: CustomerMetricsWhereInput | null
    isNot?: CustomerMetricsWhereInput | null
  }

  export type ProposalListRelationFilter = {
    every?: ProposalWhereInput
    some?: ProposalWhereInput
    none?: ProposalWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type PropertyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InteractionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TagOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProposalOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomerCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    status?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    company?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    preferredCommunication?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    status?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    company?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    preferredCommunication?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    status?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    company?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    preferredCommunication?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type CustomerScalarRelationFilter = {
    is?: CustomerWhereInput
    isNot?: CustomerWhereInput
  }

  export type TagCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    customerId?: SortOrder
  }

  export type TagMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    customerId?: SortOrder
  }

  export type TagMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    customerId?: SortOrder
  }

  export type PropertyNullableScalarRelationFilter = {
    is?: PropertyWhereInput | null
    isNot?: PropertyWhereInput | null
  }

  export type AddressCountOrderByAggregateInput = {
    id?: SortOrder
    street?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zipCode?: SortOrder
    country?: SortOrder
    customerId?: SortOrder
  }

  export type AddressMaxOrderByAggregateInput = {
    id?: SortOrder
    street?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zipCode?: SortOrder
    country?: SortOrder
    customerId?: SortOrder
  }

  export type AddressMinOrderByAggregateInput = {
    id?: SortOrder
    street?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zipCode?: SortOrder
    country?: SortOrder
    customerId?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type PhotoListRelationFilter = {
    every?: PhotoWhereInput
    some?: PhotoWhereInput
    none?: PhotoWhereInput
  }

  export type DocumentListRelationFilter = {
    every?: DocumentWhereInput
    some?: DocumentWhereInput
    none?: DocumentWhereInput
  }

  export type SystemInstallationListRelationFilter = {
    every?: SystemInstallationWhereInput
    some?: SystemInstallationWhereInput
    none?: SystemInstallationWhereInput
  }

  export type ServiceRecordListRelationFilter = {
    every?: ServiceRecordWhereInput
    some?: ServiceRecordWhereInput
    none?: ServiceRecordWhereInput
  }

  export type PhotoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DocumentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SystemInstallationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ServiceRecordOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PropertyCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    addressId?: SortOrder
    squareFootage?: SortOrder
    bedrooms?: SortOrder
    bathrooms?: SortOrder
    yearBuilt?: SortOrder
    customerId?: SortOrder
  }

  export type PropertyAvgOrderByAggregateInput = {
    squareFootage?: SortOrder
    bedrooms?: SortOrder
    bathrooms?: SortOrder
    yearBuilt?: SortOrder
  }

  export type PropertyMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    addressId?: SortOrder
    squareFootage?: SortOrder
    bedrooms?: SortOrder
    bathrooms?: SortOrder
    yearBuilt?: SortOrder
    customerId?: SortOrder
  }

  export type PropertyMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    addressId?: SortOrder
    squareFootage?: SortOrder
    bedrooms?: SortOrder
    bathrooms?: SortOrder
    yearBuilt?: SortOrder
    customerId?: SortOrder
  }

  export type PropertySumOrderByAggregateInput = {
    squareFootage?: SortOrder
    bedrooms?: SortOrder
    bathrooms?: SortOrder
    yearBuilt?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type PropertyScalarRelationFilter = {
    is?: PropertyWhereInput
    isNot?: PropertyWhereInput
  }

  export type PhotoCountOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    propertyId?: SortOrder
    uploadedAt?: SortOrder
    uploadedBy?: SortOrder
  }

  export type PhotoMaxOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    propertyId?: SortOrder
    uploadedAt?: SortOrder
    uploadedBy?: SortOrder
  }

  export type PhotoMinOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    propertyId?: SortOrder
    uploadedAt?: SortOrder
    uploadedBy?: SortOrder
  }

  export type ProjectNullableScalarRelationFilter = {
    is?: ProjectWhereInput | null
    isNot?: ProjectWhereInput | null
  }

  export type DocumentCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    url?: SortOrder
    type?: SortOrder
    propertyId?: SortOrder
    projectId?: SortOrder
    uploadedAt?: SortOrder
    uploadedBy?: SortOrder
  }

  export type DocumentMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    url?: SortOrder
    type?: SortOrder
    propertyId?: SortOrder
    projectId?: SortOrder
    uploadedAt?: SortOrder
    uploadedBy?: SortOrder
  }

  export type DocumentMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    url?: SortOrder
    type?: SortOrder
    propertyId?: SortOrder
    projectId?: SortOrder
    uploadedAt?: SortOrder
    uploadedBy?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type SystemInstallationCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    details?: SortOrder
    installDate?: SortOrder
    lastService?: SortOrder
    propertyId?: SortOrder
  }

  export type SystemInstallationMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    details?: SortOrder
    installDate?: SortOrder
    lastService?: SortOrder
    propertyId?: SortOrder
  }

  export type SystemInstallationMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    details?: SortOrder
    installDate?: SortOrder
    lastService?: SortOrder
    propertyId?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type ServiceRecordCountOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    type?: SortOrder
    description?: SortOrder
    technician?: SortOrder
    cost?: SortOrder
    propertyId?: SortOrder
  }

  export type ServiceRecordAvgOrderByAggregateInput = {
    cost?: SortOrder
  }

  export type ServiceRecordMaxOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    type?: SortOrder
    description?: SortOrder
    technician?: SortOrder
    cost?: SortOrder
    propertyId?: SortOrder
  }

  export type ServiceRecordMinOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    type?: SortOrder
    description?: SortOrder
    technician?: SortOrder
    cost?: SortOrder
    propertyId?: SortOrder
  }

  export type ServiceRecordSumOrderByAggregateInput = {
    cost?: SortOrder
  }

  export type ProjectTeamMemberListRelationFilter = {
    every?: ProjectTeamMemberWhereInput
    some?: ProjectTeamMemberWhereInput
    none?: ProjectTeamMemberWhereInput
  }

  export type MilestoneListRelationFilter = {
    every?: MilestoneWhereInput
    some?: MilestoneWhereInput
    none?: MilestoneWhereInput
  }

  export type BudgetNullableScalarRelationFilter = {
    is?: BudgetWhereInput | null
    isNot?: BudgetWhereInput | null
  }

  export type ProjectTeamMemberOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MilestoneOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    propertyId?: SortOrder
    customerId?: SortOrder
  }

  export type ProjectMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    propertyId?: SortOrder
    customerId?: SortOrder
  }

  export type ProjectMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    propertyId?: SortOrder
    customerId?: SortOrder
  }

  export type ProjectScalarRelationFilter = {
    is?: ProjectWhereInput
    isNot?: ProjectWhereInput
  }

  export type TeamMemberScalarRelationFilter = {
    is?: TeamMemberWhereInput
    isNot?: TeamMemberWhereInput
  }

  export type ProjectTeamMemberCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    teamMemberId?: SortOrder
  }

  export type ProjectTeamMemberMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    teamMemberId?: SortOrder
  }

  export type ProjectTeamMemberMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    teamMemberId?: SortOrder
  }

  export type TeamMemberCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    role?: SortOrder
    email?: SortOrder
    phone?: SortOrder
  }

  export type TeamMemberMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    role?: SortOrder
    email?: SortOrder
    phone?: SortOrder
  }

  export type TeamMemberMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    role?: SortOrder
    email?: SortOrder
    phone?: SortOrder
  }

  export type MilestoneCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    dueDate?: SortOrder
    completedDate?: SortOrder
    assignedTo?: SortOrder
    projectId?: SortOrder
  }

  export type MilestoneMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    dueDate?: SortOrder
    completedDate?: SortOrder
    assignedTo?: SortOrder
    projectId?: SortOrder
  }

  export type MilestoneMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    dueDate?: SortOrder
    completedDate?: SortOrder
    assignedTo?: SortOrder
    projectId?: SortOrder
  }

  export type BudgetLineItemListRelationFilter = {
    every?: BudgetLineItemWhereInput
    some?: BudgetLineItemWhereInput
    none?: BudgetLineItemWhereInput
  }

  export type BudgetLineItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BudgetCountOrderByAggregateInput = {
    id?: SortOrder
    currency?: SortOrder
    total?: SortOrder
    spent?: SortOrder
    remaining?: SortOrder
    projectId?: SortOrder
  }

  export type BudgetAvgOrderByAggregateInput = {
    total?: SortOrder
    spent?: SortOrder
    remaining?: SortOrder
  }

  export type BudgetMaxOrderByAggregateInput = {
    id?: SortOrder
    currency?: SortOrder
    total?: SortOrder
    spent?: SortOrder
    remaining?: SortOrder
    projectId?: SortOrder
  }

  export type BudgetMinOrderByAggregateInput = {
    id?: SortOrder
    currency?: SortOrder
    total?: SortOrder
    spent?: SortOrder
    remaining?: SortOrder
    projectId?: SortOrder
  }

  export type BudgetSumOrderByAggregateInput = {
    total?: SortOrder
    spent?: SortOrder
    remaining?: SortOrder
  }

  export type BudgetScalarRelationFilter = {
    is?: BudgetWhereInput
    isNot?: BudgetWhereInput
  }

  export type BudgetLineItemCountOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    category?: SortOrder
    budgetId?: SortOrder
  }

  export type BudgetLineItemAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type BudgetLineItemMaxOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    category?: SortOrder
    budgetId?: SortOrder
  }

  export type BudgetLineItemMinOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    category?: SortOrder
    budgetId?: SortOrder
  }

  export type BudgetLineItemSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type InteractionCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    date?: SortOrder
    summary?: SortOrder
    details?: SortOrder
    followUpDate?: SortOrder
    followUpNotes?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    customerId?: SortOrder
  }

  export type InteractionMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    date?: SortOrder
    summary?: SortOrder
    details?: SortOrder
    followUpDate?: SortOrder
    followUpNotes?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    customerId?: SortOrder
  }

  export type InteractionMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    date?: SortOrder
    summary?: SortOrder
    details?: SortOrder
    followUpDate?: SortOrder
    followUpNotes?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    customerId?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type CustomerMetricsCountOrderByAggregateInput = {
    id?: SortOrder
    totalRevenue?: SortOrder
    projectsCompleted?: SortOrder
    avgResponseTime?: SortOrder
    lastInteraction?: SortOrder
    nextScheduledInteraction?: SortOrder
    customerId?: SortOrder
  }

  export type CustomerMetricsAvgOrderByAggregateInput = {
    totalRevenue?: SortOrder
    projectsCompleted?: SortOrder
    avgResponseTime?: SortOrder
  }

  export type CustomerMetricsMaxOrderByAggregateInput = {
    id?: SortOrder
    totalRevenue?: SortOrder
    projectsCompleted?: SortOrder
    avgResponseTime?: SortOrder
    lastInteraction?: SortOrder
    nextScheduledInteraction?: SortOrder
    customerId?: SortOrder
  }

  export type CustomerMetricsMinOrderByAggregateInput = {
    id?: SortOrder
    totalRevenue?: SortOrder
    projectsCompleted?: SortOrder
    avgResponseTime?: SortOrder
    lastInteraction?: SortOrder
    nextScheduledInteraction?: SortOrder
    customerId?: SortOrder
  }

  export type CustomerMetricsSumOrderByAggregateInput = {
    totalRevenue?: SortOrder
    projectsCompleted?: SortOrder
    avgResponseTime?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type CustomerNullableScalarRelationFilter = {
    is?: CustomerWhereInput | null
    isNot?: CustomerWhereInput | null
  }

  export type ProposalItemListRelationFilter = {
    every?: ProposalItemWhereInput
    some?: ProposalItemWhereInput
    none?: ProposalItemWhereInput
  }

  export type ProposalItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProposalCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    customerPersona?: SortOrder
    voiceTranscript?: SortOrder
    aiSummary?: SortOrder
    totalAmount?: SortOrder
    validUntil?: SortOrder
    isExistingCustomer?: SortOrder
    customerId?: SortOrder
    prospectName?: SortOrder
    prospectCompany?: SortOrder
    prospectEmail?: SortOrder
    prospectPhone?: SortOrder
    prospectStatus?: SortOrder
    propertyId?: SortOrder
    projectId?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProposalAvgOrderByAggregateInput = {
    totalAmount?: SortOrder
  }

  export type ProposalMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    customerPersona?: SortOrder
    voiceTranscript?: SortOrder
    aiSummary?: SortOrder
    totalAmount?: SortOrder
    validUntil?: SortOrder
    isExistingCustomer?: SortOrder
    customerId?: SortOrder
    prospectName?: SortOrder
    prospectCompany?: SortOrder
    prospectEmail?: SortOrder
    prospectPhone?: SortOrder
    prospectStatus?: SortOrder
    propertyId?: SortOrder
    projectId?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProposalMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    customerPersona?: SortOrder
    voiceTranscript?: SortOrder
    aiSummary?: SortOrder
    totalAmount?: SortOrder
    validUntil?: SortOrder
    isExistingCustomer?: SortOrder
    customerId?: SortOrder
    prospectName?: SortOrder
    prospectCompany?: SortOrder
    prospectEmail?: SortOrder
    prospectPhone?: SortOrder
    prospectStatus?: SortOrder
    propertyId?: SortOrder
    projectId?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProposalSumOrderByAggregateInput = {
    totalAmount?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type ProductNullableScalarRelationFilter = {
    is?: ProductWhereInput | null
    isNot?: ProductWhereInput | null
  }

  export type ProposalScalarRelationFilter = {
    is?: ProposalWhereInput
    isNot?: ProposalWhereInput
  }

  export type ProposalItemCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
    productId?: SortOrder
    proposalId?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProposalItemAvgOrderByAggregateInput = {
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
    sortOrder?: SortOrder
  }

  export type ProposalItemMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
    productId?: SortOrder
    proposalId?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProposalItemMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
    productId?: SortOrder
    proposalId?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProposalItemSumOrderByAggregateInput = {
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
    sortOrder?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type ProductCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    brand?: SortOrder
    model?: SortOrder
    sku?: SortOrder
    basePrice?: SortOrder
    goodTierPrice?: SortOrder
    betterTierPrice?: SortOrder
    bestTierPrice?: SortOrder
    isActive?: SortOrder
    specifications?: SortOrder
    compatibility?: SortOrder
    installation?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductAvgOrderByAggregateInput = {
    basePrice?: SortOrder
    goodTierPrice?: SortOrder
    betterTierPrice?: SortOrder
    bestTierPrice?: SortOrder
  }

  export type ProductMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    brand?: SortOrder
    model?: SortOrder
    sku?: SortOrder
    basePrice?: SortOrder
    goodTierPrice?: SortOrder
    betterTierPrice?: SortOrder
    bestTierPrice?: SortOrder
    isActive?: SortOrder
    specifications?: SortOrder
    compatibility?: SortOrder
    installation?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    brand?: SortOrder
    model?: SortOrder
    sku?: SortOrder
    basePrice?: SortOrder
    goodTierPrice?: SortOrder
    betterTierPrice?: SortOrder
    bestTierPrice?: SortOrder
    isActive?: SortOrder
    specifications?: SortOrder
    compatibility?: SortOrder
    installation?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductSumOrderByAggregateInput = {
    basePrice?: SortOrder
    goodTierPrice?: SortOrder
    betterTierPrice?: SortOrder
    bestTierPrice?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type ProposalPersonaCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    description?: SortOrder
    keyFeatures?: SortOrder
    recommendedTier?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProposalPersonaMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    description?: SortOrder
    keyFeatures?: SortOrder
    recommendedTier?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProposalPersonaMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    description?: SortOrder
    keyFeatures?: SortOrder
    recommendedTier?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AddressCreateNestedOneWithoutCustomerInput = {
    create?: XOR<AddressCreateWithoutCustomerInput, AddressUncheckedCreateWithoutCustomerInput>
    connectOrCreate?: AddressCreateOrConnectWithoutCustomerInput
    connect?: AddressWhereUniqueInput
  }

  export type PropertyCreateNestedManyWithoutCustomerInput = {
    create?: XOR<PropertyCreateWithoutCustomerInput, PropertyUncheckedCreateWithoutCustomerInput> | PropertyCreateWithoutCustomerInput[] | PropertyUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: PropertyCreateOrConnectWithoutCustomerInput | PropertyCreateOrConnectWithoutCustomerInput[]
    createMany?: PropertyCreateManyCustomerInputEnvelope
    connect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
  }

  export type ProjectCreateNestedManyWithoutCustomerInput = {
    create?: XOR<ProjectCreateWithoutCustomerInput, ProjectUncheckedCreateWithoutCustomerInput> | ProjectCreateWithoutCustomerInput[] | ProjectUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutCustomerInput | ProjectCreateOrConnectWithoutCustomerInput[]
    createMany?: ProjectCreateManyCustomerInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type InteractionCreateNestedManyWithoutCustomerInput = {
    create?: XOR<InteractionCreateWithoutCustomerInput, InteractionUncheckedCreateWithoutCustomerInput> | InteractionCreateWithoutCustomerInput[] | InteractionUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: InteractionCreateOrConnectWithoutCustomerInput | InteractionCreateOrConnectWithoutCustomerInput[]
    createMany?: InteractionCreateManyCustomerInputEnvelope
    connect?: InteractionWhereUniqueInput | InteractionWhereUniqueInput[]
  }

  export type TagCreateNestedManyWithoutCustomerInput = {
    create?: XOR<TagCreateWithoutCustomerInput, TagUncheckedCreateWithoutCustomerInput> | TagCreateWithoutCustomerInput[] | TagUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: TagCreateOrConnectWithoutCustomerInput | TagCreateOrConnectWithoutCustomerInput[]
    createMany?: TagCreateManyCustomerInputEnvelope
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
  }

  export type CustomerMetricsCreateNestedOneWithoutCustomerInput = {
    create?: XOR<CustomerMetricsCreateWithoutCustomerInput, CustomerMetricsUncheckedCreateWithoutCustomerInput>
    connectOrCreate?: CustomerMetricsCreateOrConnectWithoutCustomerInput
    connect?: CustomerMetricsWhereUniqueInput
  }

  export type ProposalCreateNestedManyWithoutCustomerInput = {
    create?: XOR<ProposalCreateWithoutCustomerInput, ProposalUncheckedCreateWithoutCustomerInput> | ProposalCreateWithoutCustomerInput[] | ProposalUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: ProposalCreateOrConnectWithoutCustomerInput | ProposalCreateOrConnectWithoutCustomerInput[]
    createMany?: ProposalCreateManyCustomerInputEnvelope
    connect?: ProposalWhereUniqueInput | ProposalWhereUniqueInput[]
  }

  export type AddressUncheckedCreateNestedOneWithoutCustomerInput = {
    create?: XOR<AddressCreateWithoutCustomerInput, AddressUncheckedCreateWithoutCustomerInput>
    connectOrCreate?: AddressCreateOrConnectWithoutCustomerInput
    connect?: AddressWhereUniqueInput
  }

  export type PropertyUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<PropertyCreateWithoutCustomerInput, PropertyUncheckedCreateWithoutCustomerInput> | PropertyCreateWithoutCustomerInput[] | PropertyUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: PropertyCreateOrConnectWithoutCustomerInput | PropertyCreateOrConnectWithoutCustomerInput[]
    createMany?: PropertyCreateManyCustomerInputEnvelope
    connect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
  }

  export type ProjectUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<ProjectCreateWithoutCustomerInput, ProjectUncheckedCreateWithoutCustomerInput> | ProjectCreateWithoutCustomerInput[] | ProjectUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutCustomerInput | ProjectCreateOrConnectWithoutCustomerInput[]
    createMany?: ProjectCreateManyCustomerInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type InteractionUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<InteractionCreateWithoutCustomerInput, InteractionUncheckedCreateWithoutCustomerInput> | InteractionCreateWithoutCustomerInput[] | InteractionUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: InteractionCreateOrConnectWithoutCustomerInput | InteractionCreateOrConnectWithoutCustomerInput[]
    createMany?: InteractionCreateManyCustomerInputEnvelope
    connect?: InteractionWhereUniqueInput | InteractionWhereUniqueInput[]
  }

  export type TagUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<TagCreateWithoutCustomerInput, TagUncheckedCreateWithoutCustomerInput> | TagCreateWithoutCustomerInput[] | TagUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: TagCreateOrConnectWithoutCustomerInput | TagCreateOrConnectWithoutCustomerInput[]
    createMany?: TagCreateManyCustomerInputEnvelope
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
  }

  export type CustomerMetricsUncheckedCreateNestedOneWithoutCustomerInput = {
    create?: XOR<CustomerMetricsCreateWithoutCustomerInput, CustomerMetricsUncheckedCreateWithoutCustomerInput>
    connectOrCreate?: CustomerMetricsCreateOrConnectWithoutCustomerInput
    connect?: CustomerMetricsWhereUniqueInput
  }

  export type ProposalUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<ProposalCreateWithoutCustomerInput, ProposalUncheckedCreateWithoutCustomerInput> | ProposalCreateWithoutCustomerInput[] | ProposalUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: ProposalCreateOrConnectWithoutCustomerInput | ProposalCreateOrConnectWithoutCustomerInput[]
    createMany?: ProposalCreateManyCustomerInputEnvelope
    connect?: ProposalWhereUniqueInput | ProposalWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type AddressUpdateOneWithoutCustomerNestedInput = {
    create?: XOR<AddressCreateWithoutCustomerInput, AddressUncheckedCreateWithoutCustomerInput>
    connectOrCreate?: AddressCreateOrConnectWithoutCustomerInput
    upsert?: AddressUpsertWithoutCustomerInput
    disconnect?: AddressWhereInput | boolean
    delete?: AddressWhereInput | boolean
    connect?: AddressWhereUniqueInput
    update?: XOR<XOR<AddressUpdateToOneWithWhereWithoutCustomerInput, AddressUpdateWithoutCustomerInput>, AddressUncheckedUpdateWithoutCustomerInput>
  }

  export type PropertyUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<PropertyCreateWithoutCustomerInput, PropertyUncheckedCreateWithoutCustomerInput> | PropertyCreateWithoutCustomerInput[] | PropertyUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: PropertyCreateOrConnectWithoutCustomerInput | PropertyCreateOrConnectWithoutCustomerInput[]
    upsert?: PropertyUpsertWithWhereUniqueWithoutCustomerInput | PropertyUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: PropertyCreateManyCustomerInputEnvelope
    set?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    disconnect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    delete?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    connect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    update?: PropertyUpdateWithWhereUniqueWithoutCustomerInput | PropertyUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: PropertyUpdateManyWithWhereWithoutCustomerInput | PropertyUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: PropertyScalarWhereInput | PropertyScalarWhereInput[]
  }

  export type ProjectUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<ProjectCreateWithoutCustomerInput, ProjectUncheckedCreateWithoutCustomerInput> | ProjectCreateWithoutCustomerInput[] | ProjectUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutCustomerInput | ProjectCreateOrConnectWithoutCustomerInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutCustomerInput | ProjectUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: ProjectCreateManyCustomerInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutCustomerInput | ProjectUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutCustomerInput | ProjectUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type InteractionUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<InteractionCreateWithoutCustomerInput, InteractionUncheckedCreateWithoutCustomerInput> | InteractionCreateWithoutCustomerInput[] | InteractionUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: InteractionCreateOrConnectWithoutCustomerInput | InteractionCreateOrConnectWithoutCustomerInput[]
    upsert?: InteractionUpsertWithWhereUniqueWithoutCustomerInput | InteractionUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: InteractionCreateManyCustomerInputEnvelope
    set?: InteractionWhereUniqueInput | InteractionWhereUniqueInput[]
    disconnect?: InteractionWhereUniqueInput | InteractionWhereUniqueInput[]
    delete?: InteractionWhereUniqueInput | InteractionWhereUniqueInput[]
    connect?: InteractionWhereUniqueInput | InteractionWhereUniqueInput[]
    update?: InteractionUpdateWithWhereUniqueWithoutCustomerInput | InteractionUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: InteractionUpdateManyWithWhereWithoutCustomerInput | InteractionUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: InteractionScalarWhereInput | InteractionScalarWhereInput[]
  }

  export type TagUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<TagCreateWithoutCustomerInput, TagUncheckedCreateWithoutCustomerInput> | TagCreateWithoutCustomerInput[] | TagUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: TagCreateOrConnectWithoutCustomerInput | TagCreateOrConnectWithoutCustomerInput[]
    upsert?: TagUpsertWithWhereUniqueWithoutCustomerInput | TagUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: TagCreateManyCustomerInputEnvelope
    set?: TagWhereUniqueInput | TagWhereUniqueInput[]
    disconnect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    delete?: TagWhereUniqueInput | TagWhereUniqueInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    update?: TagUpdateWithWhereUniqueWithoutCustomerInput | TagUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: TagUpdateManyWithWhereWithoutCustomerInput | TagUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: TagScalarWhereInput | TagScalarWhereInput[]
  }

  export type CustomerMetricsUpdateOneWithoutCustomerNestedInput = {
    create?: XOR<CustomerMetricsCreateWithoutCustomerInput, CustomerMetricsUncheckedCreateWithoutCustomerInput>
    connectOrCreate?: CustomerMetricsCreateOrConnectWithoutCustomerInput
    upsert?: CustomerMetricsUpsertWithoutCustomerInput
    disconnect?: CustomerMetricsWhereInput | boolean
    delete?: CustomerMetricsWhereInput | boolean
    connect?: CustomerMetricsWhereUniqueInput
    update?: XOR<XOR<CustomerMetricsUpdateToOneWithWhereWithoutCustomerInput, CustomerMetricsUpdateWithoutCustomerInput>, CustomerMetricsUncheckedUpdateWithoutCustomerInput>
  }

  export type ProposalUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<ProposalCreateWithoutCustomerInput, ProposalUncheckedCreateWithoutCustomerInput> | ProposalCreateWithoutCustomerInput[] | ProposalUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: ProposalCreateOrConnectWithoutCustomerInput | ProposalCreateOrConnectWithoutCustomerInput[]
    upsert?: ProposalUpsertWithWhereUniqueWithoutCustomerInput | ProposalUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: ProposalCreateManyCustomerInputEnvelope
    set?: ProposalWhereUniqueInput | ProposalWhereUniqueInput[]
    disconnect?: ProposalWhereUniqueInput | ProposalWhereUniqueInput[]
    delete?: ProposalWhereUniqueInput | ProposalWhereUniqueInput[]
    connect?: ProposalWhereUniqueInput | ProposalWhereUniqueInput[]
    update?: ProposalUpdateWithWhereUniqueWithoutCustomerInput | ProposalUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: ProposalUpdateManyWithWhereWithoutCustomerInput | ProposalUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: ProposalScalarWhereInput | ProposalScalarWhereInput[]
  }

  export type AddressUncheckedUpdateOneWithoutCustomerNestedInput = {
    create?: XOR<AddressCreateWithoutCustomerInput, AddressUncheckedCreateWithoutCustomerInput>
    connectOrCreate?: AddressCreateOrConnectWithoutCustomerInput
    upsert?: AddressUpsertWithoutCustomerInput
    disconnect?: AddressWhereInput | boolean
    delete?: AddressWhereInput | boolean
    connect?: AddressWhereUniqueInput
    update?: XOR<XOR<AddressUpdateToOneWithWhereWithoutCustomerInput, AddressUpdateWithoutCustomerInput>, AddressUncheckedUpdateWithoutCustomerInput>
  }

  export type PropertyUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<PropertyCreateWithoutCustomerInput, PropertyUncheckedCreateWithoutCustomerInput> | PropertyCreateWithoutCustomerInput[] | PropertyUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: PropertyCreateOrConnectWithoutCustomerInput | PropertyCreateOrConnectWithoutCustomerInput[]
    upsert?: PropertyUpsertWithWhereUniqueWithoutCustomerInput | PropertyUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: PropertyCreateManyCustomerInputEnvelope
    set?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    disconnect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    delete?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    connect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    update?: PropertyUpdateWithWhereUniqueWithoutCustomerInput | PropertyUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: PropertyUpdateManyWithWhereWithoutCustomerInput | PropertyUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: PropertyScalarWhereInput | PropertyScalarWhereInput[]
  }

  export type ProjectUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<ProjectCreateWithoutCustomerInput, ProjectUncheckedCreateWithoutCustomerInput> | ProjectCreateWithoutCustomerInput[] | ProjectUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutCustomerInput | ProjectCreateOrConnectWithoutCustomerInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutCustomerInput | ProjectUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: ProjectCreateManyCustomerInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutCustomerInput | ProjectUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutCustomerInput | ProjectUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type InteractionUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<InteractionCreateWithoutCustomerInput, InteractionUncheckedCreateWithoutCustomerInput> | InteractionCreateWithoutCustomerInput[] | InteractionUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: InteractionCreateOrConnectWithoutCustomerInput | InteractionCreateOrConnectWithoutCustomerInput[]
    upsert?: InteractionUpsertWithWhereUniqueWithoutCustomerInput | InteractionUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: InteractionCreateManyCustomerInputEnvelope
    set?: InteractionWhereUniqueInput | InteractionWhereUniqueInput[]
    disconnect?: InteractionWhereUniqueInput | InteractionWhereUniqueInput[]
    delete?: InteractionWhereUniqueInput | InteractionWhereUniqueInput[]
    connect?: InteractionWhereUniqueInput | InteractionWhereUniqueInput[]
    update?: InteractionUpdateWithWhereUniqueWithoutCustomerInput | InteractionUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: InteractionUpdateManyWithWhereWithoutCustomerInput | InteractionUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: InteractionScalarWhereInput | InteractionScalarWhereInput[]
  }

  export type TagUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<TagCreateWithoutCustomerInput, TagUncheckedCreateWithoutCustomerInput> | TagCreateWithoutCustomerInput[] | TagUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: TagCreateOrConnectWithoutCustomerInput | TagCreateOrConnectWithoutCustomerInput[]
    upsert?: TagUpsertWithWhereUniqueWithoutCustomerInput | TagUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: TagCreateManyCustomerInputEnvelope
    set?: TagWhereUniqueInput | TagWhereUniqueInput[]
    disconnect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    delete?: TagWhereUniqueInput | TagWhereUniqueInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    update?: TagUpdateWithWhereUniqueWithoutCustomerInput | TagUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: TagUpdateManyWithWhereWithoutCustomerInput | TagUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: TagScalarWhereInput | TagScalarWhereInput[]
  }

  export type CustomerMetricsUncheckedUpdateOneWithoutCustomerNestedInput = {
    create?: XOR<CustomerMetricsCreateWithoutCustomerInput, CustomerMetricsUncheckedCreateWithoutCustomerInput>
    connectOrCreate?: CustomerMetricsCreateOrConnectWithoutCustomerInput
    upsert?: CustomerMetricsUpsertWithoutCustomerInput
    disconnect?: CustomerMetricsWhereInput | boolean
    delete?: CustomerMetricsWhereInput | boolean
    connect?: CustomerMetricsWhereUniqueInput
    update?: XOR<XOR<CustomerMetricsUpdateToOneWithWhereWithoutCustomerInput, CustomerMetricsUpdateWithoutCustomerInput>, CustomerMetricsUncheckedUpdateWithoutCustomerInput>
  }

  export type ProposalUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<ProposalCreateWithoutCustomerInput, ProposalUncheckedCreateWithoutCustomerInput> | ProposalCreateWithoutCustomerInput[] | ProposalUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: ProposalCreateOrConnectWithoutCustomerInput | ProposalCreateOrConnectWithoutCustomerInput[]
    upsert?: ProposalUpsertWithWhereUniqueWithoutCustomerInput | ProposalUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: ProposalCreateManyCustomerInputEnvelope
    set?: ProposalWhereUniqueInput | ProposalWhereUniqueInput[]
    disconnect?: ProposalWhereUniqueInput | ProposalWhereUniqueInput[]
    delete?: ProposalWhereUniqueInput | ProposalWhereUniqueInput[]
    connect?: ProposalWhereUniqueInput | ProposalWhereUniqueInput[]
    update?: ProposalUpdateWithWhereUniqueWithoutCustomerInput | ProposalUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: ProposalUpdateManyWithWhereWithoutCustomerInput | ProposalUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: ProposalScalarWhereInput | ProposalScalarWhereInput[]
  }

  export type CustomerCreateNestedOneWithoutTagsInput = {
    create?: XOR<CustomerCreateWithoutTagsInput, CustomerUncheckedCreateWithoutTagsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutTagsInput
    connect?: CustomerWhereUniqueInput
  }

  export type CustomerUpdateOneRequiredWithoutTagsNestedInput = {
    create?: XOR<CustomerCreateWithoutTagsInput, CustomerUncheckedCreateWithoutTagsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutTagsInput
    upsert?: CustomerUpsertWithoutTagsInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutTagsInput, CustomerUpdateWithoutTagsInput>, CustomerUncheckedUpdateWithoutTagsInput>
  }

  export type CustomerCreateNestedOneWithoutBillingAddressInput = {
    create?: XOR<CustomerCreateWithoutBillingAddressInput, CustomerUncheckedCreateWithoutBillingAddressInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutBillingAddressInput
    connect?: CustomerWhereUniqueInput
  }

  export type PropertyCreateNestedOneWithoutAddressInput = {
    create?: XOR<PropertyCreateWithoutAddressInput, PropertyUncheckedCreateWithoutAddressInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutAddressInput
    connect?: PropertyWhereUniqueInput
  }

  export type PropertyUncheckedCreateNestedOneWithoutAddressInput = {
    create?: XOR<PropertyCreateWithoutAddressInput, PropertyUncheckedCreateWithoutAddressInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutAddressInput
    connect?: PropertyWhereUniqueInput
  }

  export type CustomerUpdateOneRequiredWithoutBillingAddressNestedInput = {
    create?: XOR<CustomerCreateWithoutBillingAddressInput, CustomerUncheckedCreateWithoutBillingAddressInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutBillingAddressInput
    upsert?: CustomerUpsertWithoutBillingAddressInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutBillingAddressInput, CustomerUpdateWithoutBillingAddressInput>, CustomerUncheckedUpdateWithoutBillingAddressInput>
  }

  export type PropertyUpdateOneWithoutAddressNestedInput = {
    create?: XOR<PropertyCreateWithoutAddressInput, PropertyUncheckedCreateWithoutAddressInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutAddressInput
    upsert?: PropertyUpsertWithoutAddressInput
    disconnect?: PropertyWhereInput | boolean
    delete?: PropertyWhereInput | boolean
    connect?: PropertyWhereUniqueInput
    update?: XOR<XOR<PropertyUpdateToOneWithWhereWithoutAddressInput, PropertyUpdateWithoutAddressInput>, PropertyUncheckedUpdateWithoutAddressInput>
  }

  export type PropertyUncheckedUpdateOneWithoutAddressNestedInput = {
    create?: XOR<PropertyCreateWithoutAddressInput, PropertyUncheckedCreateWithoutAddressInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutAddressInput
    upsert?: PropertyUpsertWithoutAddressInput
    disconnect?: PropertyWhereInput | boolean
    delete?: PropertyWhereInput | boolean
    connect?: PropertyWhereUniqueInput
    update?: XOR<XOR<PropertyUpdateToOneWithWhereWithoutAddressInput, PropertyUpdateWithoutAddressInput>, PropertyUncheckedUpdateWithoutAddressInput>
  }

  export type AddressCreateNestedOneWithoutPropertyInput = {
    create?: XOR<AddressCreateWithoutPropertyInput, AddressUncheckedCreateWithoutPropertyInput>
    connectOrCreate?: AddressCreateOrConnectWithoutPropertyInput
    connect?: AddressWhereUniqueInput
  }

  export type PhotoCreateNestedManyWithoutPropertyInput = {
    create?: XOR<PhotoCreateWithoutPropertyInput, PhotoUncheckedCreateWithoutPropertyInput> | PhotoCreateWithoutPropertyInput[] | PhotoUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: PhotoCreateOrConnectWithoutPropertyInput | PhotoCreateOrConnectWithoutPropertyInput[]
    createMany?: PhotoCreateManyPropertyInputEnvelope
    connect?: PhotoWhereUniqueInput | PhotoWhereUniqueInput[]
  }

  export type DocumentCreateNestedManyWithoutPropertyInput = {
    create?: XOR<DocumentCreateWithoutPropertyInput, DocumentUncheckedCreateWithoutPropertyInput> | DocumentCreateWithoutPropertyInput[] | DocumentUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutPropertyInput | DocumentCreateOrConnectWithoutPropertyInput[]
    createMany?: DocumentCreateManyPropertyInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type SystemInstallationCreateNestedManyWithoutPropertyInput = {
    create?: XOR<SystemInstallationCreateWithoutPropertyInput, SystemInstallationUncheckedCreateWithoutPropertyInput> | SystemInstallationCreateWithoutPropertyInput[] | SystemInstallationUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: SystemInstallationCreateOrConnectWithoutPropertyInput | SystemInstallationCreateOrConnectWithoutPropertyInput[]
    createMany?: SystemInstallationCreateManyPropertyInputEnvelope
    connect?: SystemInstallationWhereUniqueInput | SystemInstallationWhereUniqueInput[]
  }

  export type ServiceRecordCreateNestedManyWithoutPropertyInput = {
    create?: XOR<ServiceRecordCreateWithoutPropertyInput, ServiceRecordUncheckedCreateWithoutPropertyInput> | ServiceRecordCreateWithoutPropertyInput[] | ServiceRecordUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: ServiceRecordCreateOrConnectWithoutPropertyInput | ServiceRecordCreateOrConnectWithoutPropertyInput[]
    createMany?: ServiceRecordCreateManyPropertyInputEnvelope
    connect?: ServiceRecordWhereUniqueInput | ServiceRecordWhereUniqueInput[]
  }

  export type CustomerCreateNestedOneWithoutPropertiesInput = {
    create?: XOR<CustomerCreateWithoutPropertiesInput, CustomerUncheckedCreateWithoutPropertiesInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutPropertiesInput
    connect?: CustomerWhereUniqueInput
  }

  export type ProjectCreateNestedManyWithoutPropertyInput = {
    create?: XOR<ProjectCreateWithoutPropertyInput, ProjectUncheckedCreateWithoutPropertyInput> | ProjectCreateWithoutPropertyInput[] | ProjectUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutPropertyInput | ProjectCreateOrConnectWithoutPropertyInput[]
    createMany?: ProjectCreateManyPropertyInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type ProposalCreateNestedManyWithoutPropertyInput = {
    create?: XOR<ProposalCreateWithoutPropertyInput, ProposalUncheckedCreateWithoutPropertyInput> | ProposalCreateWithoutPropertyInput[] | ProposalUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: ProposalCreateOrConnectWithoutPropertyInput | ProposalCreateOrConnectWithoutPropertyInput[]
    createMany?: ProposalCreateManyPropertyInputEnvelope
    connect?: ProposalWhereUniqueInput | ProposalWhereUniqueInput[]
  }

  export type PhotoUncheckedCreateNestedManyWithoutPropertyInput = {
    create?: XOR<PhotoCreateWithoutPropertyInput, PhotoUncheckedCreateWithoutPropertyInput> | PhotoCreateWithoutPropertyInput[] | PhotoUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: PhotoCreateOrConnectWithoutPropertyInput | PhotoCreateOrConnectWithoutPropertyInput[]
    createMany?: PhotoCreateManyPropertyInputEnvelope
    connect?: PhotoWhereUniqueInput | PhotoWhereUniqueInput[]
  }

  export type DocumentUncheckedCreateNestedManyWithoutPropertyInput = {
    create?: XOR<DocumentCreateWithoutPropertyInput, DocumentUncheckedCreateWithoutPropertyInput> | DocumentCreateWithoutPropertyInput[] | DocumentUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutPropertyInput | DocumentCreateOrConnectWithoutPropertyInput[]
    createMany?: DocumentCreateManyPropertyInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type SystemInstallationUncheckedCreateNestedManyWithoutPropertyInput = {
    create?: XOR<SystemInstallationCreateWithoutPropertyInput, SystemInstallationUncheckedCreateWithoutPropertyInput> | SystemInstallationCreateWithoutPropertyInput[] | SystemInstallationUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: SystemInstallationCreateOrConnectWithoutPropertyInput | SystemInstallationCreateOrConnectWithoutPropertyInput[]
    createMany?: SystemInstallationCreateManyPropertyInputEnvelope
    connect?: SystemInstallationWhereUniqueInput | SystemInstallationWhereUniqueInput[]
  }

  export type ServiceRecordUncheckedCreateNestedManyWithoutPropertyInput = {
    create?: XOR<ServiceRecordCreateWithoutPropertyInput, ServiceRecordUncheckedCreateWithoutPropertyInput> | ServiceRecordCreateWithoutPropertyInput[] | ServiceRecordUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: ServiceRecordCreateOrConnectWithoutPropertyInput | ServiceRecordCreateOrConnectWithoutPropertyInput[]
    createMany?: ServiceRecordCreateManyPropertyInputEnvelope
    connect?: ServiceRecordWhereUniqueInput | ServiceRecordWhereUniqueInput[]
  }

  export type ProjectUncheckedCreateNestedManyWithoutPropertyInput = {
    create?: XOR<ProjectCreateWithoutPropertyInput, ProjectUncheckedCreateWithoutPropertyInput> | ProjectCreateWithoutPropertyInput[] | ProjectUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutPropertyInput | ProjectCreateOrConnectWithoutPropertyInput[]
    createMany?: ProjectCreateManyPropertyInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type ProposalUncheckedCreateNestedManyWithoutPropertyInput = {
    create?: XOR<ProposalCreateWithoutPropertyInput, ProposalUncheckedCreateWithoutPropertyInput> | ProposalCreateWithoutPropertyInput[] | ProposalUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: ProposalCreateOrConnectWithoutPropertyInput | ProposalCreateOrConnectWithoutPropertyInput[]
    createMany?: ProposalCreateManyPropertyInputEnvelope
    connect?: ProposalWhereUniqueInput | ProposalWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type AddressUpdateOneWithoutPropertyNestedInput = {
    create?: XOR<AddressCreateWithoutPropertyInput, AddressUncheckedCreateWithoutPropertyInput>
    connectOrCreate?: AddressCreateOrConnectWithoutPropertyInput
    upsert?: AddressUpsertWithoutPropertyInput
    disconnect?: AddressWhereInput | boolean
    delete?: AddressWhereInput | boolean
    connect?: AddressWhereUniqueInput
    update?: XOR<XOR<AddressUpdateToOneWithWhereWithoutPropertyInput, AddressUpdateWithoutPropertyInput>, AddressUncheckedUpdateWithoutPropertyInput>
  }

  export type PhotoUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<PhotoCreateWithoutPropertyInput, PhotoUncheckedCreateWithoutPropertyInput> | PhotoCreateWithoutPropertyInput[] | PhotoUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: PhotoCreateOrConnectWithoutPropertyInput | PhotoCreateOrConnectWithoutPropertyInput[]
    upsert?: PhotoUpsertWithWhereUniqueWithoutPropertyInput | PhotoUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: PhotoCreateManyPropertyInputEnvelope
    set?: PhotoWhereUniqueInput | PhotoWhereUniqueInput[]
    disconnect?: PhotoWhereUniqueInput | PhotoWhereUniqueInput[]
    delete?: PhotoWhereUniqueInput | PhotoWhereUniqueInput[]
    connect?: PhotoWhereUniqueInput | PhotoWhereUniqueInput[]
    update?: PhotoUpdateWithWhereUniqueWithoutPropertyInput | PhotoUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: PhotoUpdateManyWithWhereWithoutPropertyInput | PhotoUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: PhotoScalarWhereInput | PhotoScalarWhereInput[]
  }

  export type DocumentUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<DocumentCreateWithoutPropertyInput, DocumentUncheckedCreateWithoutPropertyInput> | DocumentCreateWithoutPropertyInput[] | DocumentUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutPropertyInput | DocumentCreateOrConnectWithoutPropertyInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutPropertyInput | DocumentUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: DocumentCreateManyPropertyInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutPropertyInput | DocumentUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutPropertyInput | DocumentUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type SystemInstallationUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<SystemInstallationCreateWithoutPropertyInput, SystemInstallationUncheckedCreateWithoutPropertyInput> | SystemInstallationCreateWithoutPropertyInput[] | SystemInstallationUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: SystemInstallationCreateOrConnectWithoutPropertyInput | SystemInstallationCreateOrConnectWithoutPropertyInput[]
    upsert?: SystemInstallationUpsertWithWhereUniqueWithoutPropertyInput | SystemInstallationUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: SystemInstallationCreateManyPropertyInputEnvelope
    set?: SystemInstallationWhereUniqueInput | SystemInstallationWhereUniqueInput[]
    disconnect?: SystemInstallationWhereUniqueInput | SystemInstallationWhereUniqueInput[]
    delete?: SystemInstallationWhereUniqueInput | SystemInstallationWhereUniqueInput[]
    connect?: SystemInstallationWhereUniqueInput | SystemInstallationWhereUniqueInput[]
    update?: SystemInstallationUpdateWithWhereUniqueWithoutPropertyInput | SystemInstallationUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: SystemInstallationUpdateManyWithWhereWithoutPropertyInput | SystemInstallationUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: SystemInstallationScalarWhereInput | SystemInstallationScalarWhereInput[]
  }

  export type ServiceRecordUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<ServiceRecordCreateWithoutPropertyInput, ServiceRecordUncheckedCreateWithoutPropertyInput> | ServiceRecordCreateWithoutPropertyInput[] | ServiceRecordUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: ServiceRecordCreateOrConnectWithoutPropertyInput | ServiceRecordCreateOrConnectWithoutPropertyInput[]
    upsert?: ServiceRecordUpsertWithWhereUniqueWithoutPropertyInput | ServiceRecordUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: ServiceRecordCreateManyPropertyInputEnvelope
    set?: ServiceRecordWhereUniqueInput | ServiceRecordWhereUniqueInput[]
    disconnect?: ServiceRecordWhereUniqueInput | ServiceRecordWhereUniqueInput[]
    delete?: ServiceRecordWhereUniqueInput | ServiceRecordWhereUniqueInput[]
    connect?: ServiceRecordWhereUniqueInput | ServiceRecordWhereUniqueInput[]
    update?: ServiceRecordUpdateWithWhereUniqueWithoutPropertyInput | ServiceRecordUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: ServiceRecordUpdateManyWithWhereWithoutPropertyInput | ServiceRecordUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: ServiceRecordScalarWhereInput | ServiceRecordScalarWhereInput[]
  }

  export type CustomerUpdateOneRequiredWithoutPropertiesNestedInput = {
    create?: XOR<CustomerCreateWithoutPropertiesInput, CustomerUncheckedCreateWithoutPropertiesInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutPropertiesInput
    upsert?: CustomerUpsertWithoutPropertiesInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutPropertiesInput, CustomerUpdateWithoutPropertiesInput>, CustomerUncheckedUpdateWithoutPropertiesInput>
  }

  export type ProjectUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<ProjectCreateWithoutPropertyInput, ProjectUncheckedCreateWithoutPropertyInput> | ProjectCreateWithoutPropertyInput[] | ProjectUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutPropertyInput | ProjectCreateOrConnectWithoutPropertyInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutPropertyInput | ProjectUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: ProjectCreateManyPropertyInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutPropertyInput | ProjectUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutPropertyInput | ProjectUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type ProposalUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<ProposalCreateWithoutPropertyInput, ProposalUncheckedCreateWithoutPropertyInput> | ProposalCreateWithoutPropertyInput[] | ProposalUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: ProposalCreateOrConnectWithoutPropertyInput | ProposalCreateOrConnectWithoutPropertyInput[]
    upsert?: ProposalUpsertWithWhereUniqueWithoutPropertyInput | ProposalUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: ProposalCreateManyPropertyInputEnvelope
    set?: ProposalWhereUniqueInput | ProposalWhereUniqueInput[]
    disconnect?: ProposalWhereUniqueInput | ProposalWhereUniqueInput[]
    delete?: ProposalWhereUniqueInput | ProposalWhereUniqueInput[]
    connect?: ProposalWhereUniqueInput | ProposalWhereUniqueInput[]
    update?: ProposalUpdateWithWhereUniqueWithoutPropertyInput | ProposalUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: ProposalUpdateManyWithWhereWithoutPropertyInput | ProposalUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: ProposalScalarWhereInput | ProposalScalarWhereInput[]
  }

  export type PhotoUncheckedUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<PhotoCreateWithoutPropertyInput, PhotoUncheckedCreateWithoutPropertyInput> | PhotoCreateWithoutPropertyInput[] | PhotoUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: PhotoCreateOrConnectWithoutPropertyInput | PhotoCreateOrConnectWithoutPropertyInput[]
    upsert?: PhotoUpsertWithWhereUniqueWithoutPropertyInput | PhotoUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: PhotoCreateManyPropertyInputEnvelope
    set?: PhotoWhereUniqueInput | PhotoWhereUniqueInput[]
    disconnect?: PhotoWhereUniqueInput | PhotoWhereUniqueInput[]
    delete?: PhotoWhereUniqueInput | PhotoWhereUniqueInput[]
    connect?: PhotoWhereUniqueInput | PhotoWhereUniqueInput[]
    update?: PhotoUpdateWithWhereUniqueWithoutPropertyInput | PhotoUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: PhotoUpdateManyWithWhereWithoutPropertyInput | PhotoUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: PhotoScalarWhereInput | PhotoScalarWhereInput[]
  }

  export type DocumentUncheckedUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<DocumentCreateWithoutPropertyInput, DocumentUncheckedCreateWithoutPropertyInput> | DocumentCreateWithoutPropertyInput[] | DocumentUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutPropertyInput | DocumentCreateOrConnectWithoutPropertyInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutPropertyInput | DocumentUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: DocumentCreateManyPropertyInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutPropertyInput | DocumentUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutPropertyInput | DocumentUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type SystemInstallationUncheckedUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<SystemInstallationCreateWithoutPropertyInput, SystemInstallationUncheckedCreateWithoutPropertyInput> | SystemInstallationCreateWithoutPropertyInput[] | SystemInstallationUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: SystemInstallationCreateOrConnectWithoutPropertyInput | SystemInstallationCreateOrConnectWithoutPropertyInput[]
    upsert?: SystemInstallationUpsertWithWhereUniqueWithoutPropertyInput | SystemInstallationUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: SystemInstallationCreateManyPropertyInputEnvelope
    set?: SystemInstallationWhereUniqueInput | SystemInstallationWhereUniqueInput[]
    disconnect?: SystemInstallationWhereUniqueInput | SystemInstallationWhereUniqueInput[]
    delete?: SystemInstallationWhereUniqueInput | SystemInstallationWhereUniqueInput[]
    connect?: SystemInstallationWhereUniqueInput | SystemInstallationWhereUniqueInput[]
    update?: SystemInstallationUpdateWithWhereUniqueWithoutPropertyInput | SystemInstallationUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: SystemInstallationUpdateManyWithWhereWithoutPropertyInput | SystemInstallationUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: SystemInstallationScalarWhereInput | SystemInstallationScalarWhereInput[]
  }

  export type ServiceRecordUncheckedUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<ServiceRecordCreateWithoutPropertyInput, ServiceRecordUncheckedCreateWithoutPropertyInput> | ServiceRecordCreateWithoutPropertyInput[] | ServiceRecordUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: ServiceRecordCreateOrConnectWithoutPropertyInput | ServiceRecordCreateOrConnectWithoutPropertyInput[]
    upsert?: ServiceRecordUpsertWithWhereUniqueWithoutPropertyInput | ServiceRecordUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: ServiceRecordCreateManyPropertyInputEnvelope
    set?: ServiceRecordWhereUniqueInput | ServiceRecordWhereUniqueInput[]
    disconnect?: ServiceRecordWhereUniqueInput | ServiceRecordWhereUniqueInput[]
    delete?: ServiceRecordWhereUniqueInput | ServiceRecordWhereUniqueInput[]
    connect?: ServiceRecordWhereUniqueInput | ServiceRecordWhereUniqueInput[]
    update?: ServiceRecordUpdateWithWhereUniqueWithoutPropertyInput | ServiceRecordUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: ServiceRecordUpdateManyWithWhereWithoutPropertyInput | ServiceRecordUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: ServiceRecordScalarWhereInput | ServiceRecordScalarWhereInput[]
  }

  export type ProjectUncheckedUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<ProjectCreateWithoutPropertyInput, ProjectUncheckedCreateWithoutPropertyInput> | ProjectCreateWithoutPropertyInput[] | ProjectUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutPropertyInput | ProjectCreateOrConnectWithoutPropertyInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutPropertyInput | ProjectUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: ProjectCreateManyPropertyInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutPropertyInput | ProjectUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutPropertyInput | ProjectUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type ProposalUncheckedUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<ProposalCreateWithoutPropertyInput, ProposalUncheckedCreateWithoutPropertyInput> | ProposalCreateWithoutPropertyInput[] | ProposalUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: ProposalCreateOrConnectWithoutPropertyInput | ProposalCreateOrConnectWithoutPropertyInput[]
    upsert?: ProposalUpsertWithWhereUniqueWithoutPropertyInput | ProposalUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: ProposalCreateManyPropertyInputEnvelope
    set?: ProposalWhereUniqueInput | ProposalWhereUniqueInput[]
    disconnect?: ProposalWhereUniqueInput | ProposalWhereUniqueInput[]
    delete?: ProposalWhereUniqueInput | ProposalWhereUniqueInput[]
    connect?: ProposalWhereUniqueInput | ProposalWhereUniqueInput[]
    update?: ProposalUpdateWithWhereUniqueWithoutPropertyInput | ProposalUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: ProposalUpdateManyWithWhereWithoutPropertyInput | ProposalUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: ProposalScalarWhereInput | ProposalScalarWhereInput[]
  }

  export type PropertyCreateNestedOneWithoutPhotosInput = {
    create?: XOR<PropertyCreateWithoutPhotosInput, PropertyUncheckedCreateWithoutPhotosInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutPhotosInput
    connect?: PropertyWhereUniqueInput
  }

  export type PropertyUpdateOneRequiredWithoutPhotosNestedInput = {
    create?: XOR<PropertyCreateWithoutPhotosInput, PropertyUncheckedCreateWithoutPhotosInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutPhotosInput
    upsert?: PropertyUpsertWithoutPhotosInput
    connect?: PropertyWhereUniqueInput
    update?: XOR<XOR<PropertyUpdateToOneWithWhereWithoutPhotosInput, PropertyUpdateWithoutPhotosInput>, PropertyUncheckedUpdateWithoutPhotosInput>
  }

  export type PropertyCreateNestedOneWithoutDocumentsInput = {
    create?: XOR<PropertyCreateWithoutDocumentsInput, PropertyUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutDocumentsInput
    connect?: PropertyWhereUniqueInput
  }

  export type ProjectCreateNestedOneWithoutDocumentsInput = {
    create?: XOR<ProjectCreateWithoutDocumentsInput, ProjectUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutDocumentsInput
    connect?: ProjectWhereUniqueInput
  }

  export type PropertyUpdateOneWithoutDocumentsNestedInput = {
    create?: XOR<PropertyCreateWithoutDocumentsInput, PropertyUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutDocumentsInput
    upsert?: PropertyUpsertWithoutDocumentsInput
    disconnect?: PropertyWhereInput | boolean
    delete?: PropertyWhereInput | boolean
    connect?: PropertyWhereUniqueInput
    update?: XOR<XOR<PropertyUpdateToOneWithWhereWithoutDocumentsInput, PropertyUpdateWithoutDocumentsInput>, PropertyUncheckedUpdateWithoutDocumentsInput>
  }

  export type ProjectUpdateOneWithoutDocumentsNestedInput = {
    create?: XOR<ProjectCreateWithoutDocumentsInput, ProjectUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutDocumentsInput
    upsert?: ProjectUpsertWithoutDocumentsInput
    disconnect?: ProjectWhereInput | boolean
    delete?: ProjectWhereInput | boolean
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutDocumentsInput, ProjectUpdateWithoutDocumentsInput>, ProjectUncheckedUpdateWithoutDocumentsInput>
  }

  export type PropertyCreateNestedOneWithoutSystemsInput = {
    create?: XOR<PropertyCreateWithoutSystemsInput, PropertyUncheckedCreateWithoutSystemsInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutSystemsInput
    connect?: PropertyWhereUniqueInput
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type PropertyUpdateOneRequiredWithoutSystemsNestedInput = {
    create?: XOR<PropertyCreateWithoutSystemsInput, PropertyUncheckedCreateWithoutSystemsInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutSystemsInput
    upsert?: PropertyUpsertWithoutSystemsInput
    connect?: PropertyWhereUniqueInput
    update?: XOR<XOR<PropertyUpdateToOneWithWhereWithoutSystemsInput, PropertyUpdateWithoutSystemsInput>, PropertyUncheckedUpdateWithoutSystemsInput>
  }

  export type PropertyCreateNestedOneWithoutServiceHistoryInput = {
    create?: XOR<PropertyCreateWithoutServiceHistoryInput, PropertyUncheckedCreateWithoutServiceHistoryInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutServiceHistoryInput
    connect?: PropertyWhereUniqueInput
  }

  export type PropertyUpdateOneRequiredWithoutServiceHistoryNestedInput = {
    create?: XOR<PropertyCreateWithoutServiceHistoryInput, PropertyUncheckedCreateWithoutServiceHistoryInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutServiceHistoryInput
    upsert?: PropertyUpsertWithoutServiceHistoryInput
    connect?: PropertyWhereUniqueInput
    update?: XOR<XOR<PropertyUpdateToOneWithWhereWithoutServiceHistoryInput, PropertyUpdateWithoutServiceHistoryInput>, PropertyUncheckedUpdateWithoutServiceHistoryInput>
  }

  export type PropertyCreateNestedOneWithoutProjectsInput = {
    create?: XOR<PropertyCreateWithoutProjectsInput, PropertyUncheckedCreateWithoutProjectsInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutProjectsInput
    connect?: PropertyWhereUniqueInput
  }

  export type ProjectTeamMemberCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectTeamMemberCreateWithoutProjectInput, ProjectTeamMemberUncheckedCreateWithoutProjectInput> | ProjectTeamMemberCreateWithoutProjectInput[] | ProjectTeamMemberUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectTeamMemberCreateOrConnectWithoutProjectInput | ProjectTeamMemberCreateOrConnectWithoutProjectInput[]
    createMany?: ProjectTeamMemberCreateManyProjectInputEnvelope
    connect?: ProjectTeamMemberWhereUniqueInput | ProjectTeamMemberWhereUniqueInput[]
  }

  export type MilestoneCreateNestedManyWithoutProjectInput = {
    create?: XOR<MilestoneCreateWithoutProjectInput, MilestoneUncheckedCreateWithoutProjectInput> | MilestoneCreateWithoutProjectInput[] | MilestoneUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: MilestoneCreateOrConnectWithoutProjectInput | MilestoneCreateOrConnectWithoutProjectInput[]
    createMany?: MilestoneCreateManyProjectInputEnvelope
    connect?: MilestoneWhereUniqueInput | MilestoneWhereUniqueInput[]
  }

  export type BudgetCreateNestedOneWithoutProjectInput = {
    create?: XOR<BudgetCreateWithoutProjectInput, BudgetUncheckedCreateWithoutProjectInput>
    connectOrCreate?: BudgetCreateOrConnectWithoutProjectInput
    connect?: BudgetWhereUniqueInput
  }

  export type DocumentCreateNestedManyWithoutProjectInput = {
    create?: XOR<DocumentCreateWithoutProjectInput, DocumentUncheckedCreateWithoutProjectInput> | DocumentCreateWithoutProjectInput[] | DocumentUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutProjectInput | DocumentCreateOrConnectWithoutProjectInput[]
    createMany?: DocumentCreateManyProjectInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type CustomerCreateNestedOneWithoutProjectsInput = {
    create?: XOR<CustomerCreateWithoutProjectsInput, CustomerUncheckedCreateWithoutProjectsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutProjectsInput
    connect?: CustomerWhereUniqueInput
  }

  export type ProposalCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProposalCreateWithoutProjectInput, ProposalUncheckedCreateWithoutProjectInput> | ProposalCreateWithoutProjectInput[] | ProposalUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProposalCreateOrConnectWithoutProjectInput | ProposalCreateOrConnectWithoutProjectInput[]
    createMany?: ProposalCreateManyProjectInputEnvelope
    connect?: ProposalWhereUniqueInput | ProposalWhereUniqueInput[]
  }

  export type ProjectTeamMemberUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectTeamMemberCreateWithoutProjectInput, ProjectTeamMemberUncheckedCreateWithoutProjectInput> | ProjectTeamMemberCreateWithoutProjectInput[] | ProjectTeamMemberUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectTeamMemberCreateOrConnectWithoutProjectInput | ProjectTeamMemberCreateOrConnectWithoutProjectInput[]
    createMany?: ProjectTeamMemberCreateManyProjectInputEnvelope
    connect?: ProjectTeamMemberWhereUniqueInput | ProjectTeamMemberWhereUniqueInput[]
  }

  export type MilestoneUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<MilestoneCreateWithoutProjectInput, MilestoneUncheckedCreateWithoutProjectInput> | MilestoneCreateWithoutProjectInput[] | MilestoneUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: MilestoneCreateOrConnectWithoutProjectInput | MilestoneCreateOrConnectWithoutProjectInput[]
    createMany?: MilestoneCreateManyProjectInputEnvelope
    connect?: MilestoneWhereUniqueInput | MilestoneWhereUniqueInput[]
  }

  export type BudgetUncheckedCreateNestedOneWithoutProjectInput = {
    create?: XOR<BudgetCreateWithoutProjectInput, BudgetUncheckedCreateWithoutProjectInput>
    connectOrCreate?: BudgetCreateOrConnectWithoutProjectInput
    connect?: BudgetWhereUniqueInput
  }

  export type DocumentUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<DocumentCreateWithoutProjectInput, DocumentUncheckedCreateWithoutProjectInput> | DocumentCreateWithoutProjectInput[] | DocumentUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutProjectInput | DocumentCreateOrConnectWithoutProjectInput[]
    createMany?: DocumentCreateManyProjectInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type ProposalUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProposalCreateWithoutProjectInput, ProposalUncheckedCreateWithoutProjectInput> | ProposalCreateWithoutProjectInput[] | ProposalUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProposalCreateOrConnectWithoutProjectInput | ProposalCreateOrConnectWithoutProjectInput[]
    createMany?: ProposalCreateManyProjectInputEnvelope
    connect?: ProposalWhereUniqueInput | ProposalWhereUniqueInput[]
  }

  export type PropertyUpdateOneRequiredWithoutProjectsNestedInput = {
    create?: XOR<PropertyCreateWithoutProjectsInput, PropertyUncheckedCreateWithoutProjectsInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutProjectsInput
    upsert?: PropertyUpsertWithoutProjectsInput
    connect?: PropertyWhereUniqueInput
    update?: XOR<XOR<PropertyUpdateToOneWithWhereWithoutProjectsInput, PropertyUpdateWithoutProjectsInput>, PropertyUncheckedUpdateWithoutProjectsInput>
  }

  export type ProjectTeamMemberUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectTeamMemberCreateWithoutProjectInput, ProjectTeamMemberUncheckedCreateWithoutProjectInput> | ProjectTeamMemberCreateWithoutProjectInput[] | ProjectTeamMemberUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectTeamMemberCreateOrConnectWithoutProjectInput | ProjectTeamMemberCreateOrConnectWithoutProjectInput[]
    upsert?: ProjectTeamMemberUpsertWithWhereUniqueWithoutProjectInput | ProjectTeamMemberUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectTeamMemberCreateManyProjectInputEnvelope
    set?: ProjectTeamMemberWhereUniqueInput | ProjectTeamMemberWhereUniqueInput[]
    disconnect?: ProjectTeamMemberWhereUniqueInput | ProjectTeamMemberWhereUniqueInput[]
    delete?: ProjectTeamMemberWhereUniqueInput | ProjectTeamMemberWhereUniqueInput[]
    connect?: ProjectTeamMemberWhereUniqueInput | ProjectTeamMemberWhereUniqueInput[]
    update?: ProjectTeamMemberUpdateWithWhereUniqueWithoutProjectInput | ProjectTeamMemberUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectTeamMemberUpdateManyWithWhereWithoutProjectInput | ProjectTeamMemberUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectTeamMemberScalarWhereInput | ProjectTeamMemberScalarWhereInput[]
  }

  export type MilestoneUpdateManyWithoutProjectNestedInput = {
    create?: XOR<MilestoneCreateWithoutProjectInput, MilestoneUncheckedCreateWithoutProjectInput> | MilestoneCreateWithoutProjectInput[] | MilestoneUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: MilestoneCreateOrConnectWithoutProjectInput | MilestoneCreateOrConnectWithoutProjectInput[]
    upsert?: MilestoneUpsertWithWhereUniqueWithoutProjectInput | MilestoneUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: MilestoneCreateManyProjectInputEnvelope
    set?: MilestoneWhereUniqueInput | MilestoneWhereUniqueInput[]
    disconnect?: MilestoneWhereUniqueInput | MilestoneWhereUniqueInput[]
    delete?: MilestoneWhereUniqueInput | MilestoneWhereUniqueInput[]
    connect?: MilestoneWhereUniqueInput | MilestoneWhereUniqueInput[]
    update?: MilestoneUpdateWithWhereUniqueWithoutProjectInput | MilestoneUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: MilestoneUpdateManyWithWhereWithoutProjectInput | MilestoneUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: MilestoneScalarWhereInput | MilestoneScalarWhereInput[]
  }

  export type BudgetUpdateOneWithoutProjectNestedInput = {
    create?: XOR<BudgetCreateWithoutProjectInput, BudgetUncheckedCreateWithoutProjectInput>
    connectOrCreate?: BudgetCreateOrConnectWithoutProjectInput
    upsert?: BudgetUpsertWithoutProjectInput
    disconnect?: BudgetWhereInput | boolean
    delete?: BudgetWhereInput | boolean
    connect?: BudgetWhereUniqueInput
    update?: XOR<XOR<BudgetUpdateToOneWithWhereWithoutProjectInput, BudgetUpdateWithoutProjectInput>, BudgetUncheckedUpdateWithoutProjectInput>
  }

  export type DocumentUpdateManyWithoutProjectNestedInput = {
    create?: XOR<DocumentCreateWithoutProjectInput, DocumentUncheckedCreateWithoutProjectInput> | DocumentCreateWithoutProjectInput[] | DocumentUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutProjectInput | DocumentCreateOrConnectWithoutProjectInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutProjectInput | DocumentUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: DocumentCreateManyProjectInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutProjectInput | DocumentUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutProjectInput | DocumentUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type CustomerUpdateOneRequiredWithoutProjectsNestedInput = {
    create?: XOR<CustomerCreateWithoutProjectsInput, CustomerUncheckedCreateWithoutProjectsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutProjectsInput
    upsert?: CustomerUpsertWithoutProjectsInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutProjectsInput, CustomerUpdateWithoutProjectsInput>, CustomerUncheckedUpdateWithoutProjectsInput>
  }

  export type ProposalUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProposalCreateWithoutProjectInput, ProposalUncheckedCreateWithoutProjectInput> | ProposalCreateWithoutProjectInput[] | ProposalUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProposalCreateOrConnectWithoutProjectInput | ProposalCreateOrConnectWithoutProjectInput[]
    upsert?: ProposalUpsertWithWhereUniqueWithoutProjectInput | ProposalUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProposalCreateManyProjectInputEnvelope
    set?: ProposalWhereUniqueInput | ProposalWhereUniqueInput[]
    disconnect?: ProposalWhereUniqueInput | ProposalWhereUniqueInput[]
    delete?: ProposalWhereUniqueInput | ProposalWhereUniqueInput[]
    connect?: ProposalWhereUniqueInput | ProposalWhereUniqueInput[]
    update?: ProposalUpdateWithWhereUniqueWithoutProjectInput | ProposalUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProposalUpdateManyWithWhereWithoutProjectInput | ProposalUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProposalScalarWhereInput | ProposalScalarWhereInput[]
  }

  export type ProjectTeamMemberUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectTeamMemberCreateWithoutProjectInput, ProjectTeamMemberUncheckedCreateWithoutProjectInput> | ProjectTeamMemberCreateWithoutProjectInput[] | ProjectTeamMemberUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectTeamMemberCreateOrConnectWithoutProjectInput | ProjectTeamMemberCreateOrConnectWithoutProjectInput[]
    upsert?: ProjectTeamMemberUpsertWithWhereUniqueWithoutProjectInput | ProjectTeamMemberUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectTeamMemberCreateManyProjectInputEnvelope
    set?: ProjectTeamMemberWhereUniqueInput | ProjectTeamMemberWhereUniqueInput[]
    disconnect?: ProjectTeamMemberWhereUniqueInput | ProjectTeamMemberWhereUniqueInput[]
    delete?: ProjectTeamMemberWhereUniqueInput | ProjectTeamMemberWhereUniqueInput[]
    connect?: ProjectTeamMemberWhereUniqueInput | ProjectTeamMemberWhereUniqueInput[]
    update?: ProjectTeamMemberUpdateWithWhereUniqueWithoutProjectInput | ProjectTeamMemberUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectTeamMemberUpdateManyWithWhereWithoutProjectInput | ProjectTeamMemberUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectTeamMemberScalarWhereInput | ProjectTeamMemberScalarWhereInput[]
  }

  export type MilestoneUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<MilestoneCreateWithoutProjectInput, MilestoneUncheckedCreateWithoutProjectInput> | MilestoneCreateWithoutProjectInput[] | MilestoneUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: MilestoneCreateOrConnectWithoutProjectInput | MilestoneCreateOrConnectWithoutProjectInput[]
    upsert?: MilestoneUpsertWithWhereUniqueWithoutProjectInput | MilestoneUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: MilestoneCreateManyProjectInputEnvelope
    set?: MilestoneWhereUniqueInput | MilestoneWhereUniqueInput[]
    disconnect?: MilestoneWhereUniqueInput | MilestoneWhereUniqueInput[]
    delete?: MilestoneWhereUniqueInput | MilestoneWhereUniqueInput[]
    connect?: MilestoneWhereUniqueInput | MilestoneWhereUniqueInput[]
    update?: MilestoneUpdateWithWhereUniqueWithoutProjectInput | MilestoneUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: MilestoneUpdateManyWithWhereWithoutProjectInput | MilestoneUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: MilestoneScalarWhereInput | MilestoneScalarWhereInput[]
  }

  export type BudgetUncheckedUpdateOneWithoutProjectNestedInput = {
    create?: XOR<BudgetCreateWithoutProjectInput, BudgetUncheckedCreateWithoutProjectInput>
    connectOrCreate?: BudgetCreateOrConnectWithoutProjectInput
    upsert?: BudgetUpsertWithoutProjectInput
    disconnect?: BudgetWhereInput | boolean
    delete?: BudgetWhereInput | boolean
    connect?: BudgetWhereUniqueInput
    update?: XOR<XOR<BudgetUpdateToOneWithWhereWithoutProjectInput, BudgetUpdateWithoutProjectInput>, BudgetUncheckedUpdateWithoutProjectInput>
  }

  export type DocumentUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<DocumentCreateWithoutProjectInput, DocumentUncheckedCreateWithoutProjectInput> | DocumentCreateWithoutProjectInput[] | DocumentUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutProjectInput | DocumentCreateOrConnectWithoutProjectInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutProjectInput | DocumentUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: DocumentCreateManyProjectInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutProjectInput | DocumentUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutProjectInput | DocumentUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type ProposalUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProposalCreateWithoutProjectInput, ProposalUncheckedCreateWithoutProjectInput> | ProposalCreateWithoutProjectInput[] | ProposalUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProposalCreateOrConnectWithoutProjectInput | ProposalCreateOrConnectWithoutProjectInput[]
    upsert?: ProposalUpsertWithWhereUniqueWithoutProjectInput | ProposalUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProposalCreateManyProjectInputEnvelope
    set?: ProposalWhereUniqueInput | ProposalWhereUniqueInput[]
    disconnect?: ProposalWhereUniqueInput | ProposalWhereUniqueInput[]
    delete?: ProposalWhereUniqueInput | ProposalWhereUniqueInput[]
    connect?: ProposalWhereUniqueInput | ProposalWhereUniqueInput[]
    update?: ProposalUpdateWithWhereUniqueWithoutProjectInput | ProposalUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProposalUpdateManyWithWhereWithoutProjectInput | ProposalUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProposalScalarWhereInput | ProposalScalarWhereInput[]
  }

  export type ProjectCreateNestedOneWithoutTeamMembersInput = {
    create?: XOR<ProjectCreateWithoutTeamMembersInput, ProjectUncheckedCreateWithoutTeamMembersInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutTeamMembersInput
    connect?: ProjectWhereUniqueInput
  }

  export type TeamMemberCreateNestedOneWithoutProjectsInput = {
    create?: XOR<TeamMemberCreateWithoutProjectsInput, TeamMemberUncheckedCreateWithoutProjectsInput>
    connectOrCreate?: TeamMemberCreateOrConnectWithoutProjectsInput
    connect?: TeamMemberWhereUniqueInput
  }

  export type ProjectUpdateOneRequiredWithoutTeamMembersNestedInput = {
    create?: XOR<ProjectCreateWithoutTeamMembersInput, ProjectUncheckedCreateWithoutTeamMembersInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutTeamMembersInput
    upsert?: ProjectUpsertWithoutTeamMembersInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutTeamMembersInput, ProjectUpdateWithoutTeamMembersInput>, ProjectUncheckedUpdateWithoutTeamMembersInput>
  }

  export type TeamMemberUpdateOneRequiredWithoutProjectsNestedInput = {
    create?: XOR<TeamMemberCreateWithoutProjectsInput, TeamMemberUncheckedCreateWithoutProjectsInput>
    connectOrCreate?: TeamMemberCreateOrConnectWithoutProjectsInput
    upsert?: TeamMemberUpsertWithoutProjectsInput
    connect?: TeamMemberWhereUniqueInput
    update?: XOR<XOR<TeamMemberUpdateToOneWithWhereWithoutProjectsInput, TeamMemberUpdateWithoutProjectsInput>, TeamMemberUncheckedUpdateWithoutProjectsInput>
  }

  export type ProjectTeamMemberCreateNestedManyWithoutTeamMemberInput = {
    create?: XOR<ProjectTeamMemberCreateWithoutTeamMemberInput, ProjectTeamMemberUncheckedCreateWithoutTeamMemberInput> | ProjectTeamMemberCreateWithoutTeamMemberInput[] | ProjectTeamMemberUncheckedCreateWithoutTeamMemberInput[]
    connectOrCreate?: ProjectTeamMemberCreateOrConnectWithoutTeamMemberInput | ProjectTeamMemberCreateOrConnectWithoutTeamMemberInput[]
    createMany?: ProjectTeamMemberCreateManyTeamMemberInputEnvelope
    connect?: ProjectTeamMemberWhereUniqueInput | ProjectTeamMemberWhereUniqueInput[]
  }

  export type ProjectTeamMemberUncheckedCreateNestedManyWithoutTeamMemberInput = {
    create?: XOR<ProjectTeamMemberCreateWithoutTeamMemberInput, ProjectTeamMemberUncheckedCreateWithoutTeamMemberInput> | ProjectTeamMemberCreateWithoutTeamMemberInput[] | ProjectTeamMemberUncheckedCreateWithoutTeamMemberInput[]
    connectOrCreate?: ProjectTeamMemberCreateOrConnectWithoutTeamMemberInput | ProjectTeamMemberCreateOrConnectWithoutTeamMemberInput[]
    createMany?: ProjectTeamMemberCreateManyTeamMemberInputEnvelope
    connect?: ProjectTeamMemberWhereUniqueInput | ProjectTeamMemberWhereUniqueInput[]
  }

  export type ProjectTeamMemberUpdateManyWithoutTeamMemberNestedInput = {
    create?: XOR<ProjectTeamMemberCreateWithoutTeamMemberInput, ProjectTeamMemberUncheckedCreateWithoutTeamMemberInput> | ProjectTeamMemberCreateWithoutTeamMemberInput[] | ProjectTeamMemberUncheckedCreateWithoutTeamMemberInput[]
    connectOrCreate?: ProjectTeamMemberCreateOrConnectWithoutTeamMemberInput | ProjectTeamMemberCreateOrConnectWithoutTeamMemberInput[]
    upsert?: ProjectTeamMemberUpsertWithWhereUniqueWithoutTeamMemberInput | ProjectTeamMemberUpsertWithWhereUniqueWithoutTeamMemberInput[]
    createMany?: ProjectTeamMemberCreateManyTeamMemberInputEnvelope
    set?: ProjectTeamMemberWhereUniqueInput | ProjectTeamMemberWhereUniqueInput[]
    disconnect?: ProjectTeamMemberWhereUniqueInput | ProjectTeamMemberWhereUniqueInput[]
    delete?: ProjectTeamMemberWhereUniqueInput | ProjectTeamMemberWhereUniqueInput[]
    connect?: ProjectTeamMemberWhereUniqueInput | ProjectTeamMemberWhereUniqueInput[]
    update?: ProjectTeamMemberUpdateWithWhereUniqueWithoutTeamMemberInput | ProjectTeamMemberUpdateWithWhereUniqueWithoutTeamMemberInput[]
    updateMany?: ProjectTeamMemberUpdateManyWithWhereWithoutTeamMemberInput | ProjectTeamMemberUpdateManyWithWhereWithoutTeamMemberInput[]
    deleteMany?: ProjectTeamMemberScalarWhereInput | ProjectTeamMemberScalarWhereInput[]
  }

  export type ProjectTeamMemberUncheckedUpdateManyWithoutTeamMemberNestedInput = {
    create?: XOR<ProjectTeamMemberCreateWithoutTeamMemberInput, ProjectTeamMemberUncheckedCreateWithoutTeamMemberInput> | ProjectTeamMemberCreateWithoutTeamMemberInput[] | ProjectTeamMemberUncheckedCreateWithoutTeamMemberInput[]
    connectOrCreate?: ProjectTeamMemberCreateOrConnectWithoutTeamMemberInput | ProjectTeamMemberCreateOrConnectWithoutTeamMemberInput[]
    upsert?: ProjectTeamMemberUpsertWithWhereUniqueWithoutTeamMemberInput | ProjectTeamMemberUpsertWithWhereUniqueWithoutTeamMemberInput[]
    createMany?: ProjectTeamMemberCreateManyTeamMemberInputEnvelope
    set?: ProjectTeamMemberWhereUniqueInput | ProjectTeamMemberWhereUniqueInput[]
    disconnect?: ProjectTeamMemberWhereUniqueInput | ProjectTeamMemberWhereUniqueInput[]
    delete?: ProjectTeamMemberWhereUniqueInput | ProjectTeamMemberWhereUniqueInput[]
    connect?: ProjectTeamMemberWhereUniqueInput | ProjectTeamMemberWhereUniqueInput[]
    update?: ProjectTeamMemberUpdateWithWhereUniqueWithoutTeamMemberInput | ProjectTeamMemberUpdateWithWhereUniqueWithoutTeamMemberInput[]
    updateMany?: ProjectTeamMemberUpdateManyWithWhereWithoutTeamMemberInput | ProjectTeamMemberUpdateManyWithWhereWithoutTeamMemberInput[]
    deleteMany?: ProjectTeamMemberScalarWhereInput | ProjectTeamMemberScalarWhereInput[]
  }

  export type ProjectCreateNestedOneWithoutMilestonesInput = {
    create?: XOR<ProjectCreateWithoutMilestonesInput, ProjectUncheckedCreateWithoutMilestonesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutMilestonesInput
    connect?: ProjectWhereUniqueInput
  }

  export type ProjectUpdateOneRequiredWithoutMilestonesNestedInput = {
    create?: XOR<ProjectCreateWithoutMilestonesInput, ProjectUncheckedCreateWithoutMilestonesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutMilestonesInput
    upsert?: ProjectUpsertWithoutMilestonesInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutMilestonesInput, ProjectUpdateWithoutMilestonesInput>, ProjectUncheckedUpdateWithoutMilestonesInput>
  }

  export type BudgetLineItemCreateNestedManyWithoutBudgetInput = {
    create?: XOR<BudgetLineItemCreateWithoutBudgetInput, BudgetLineItemUncheckedCreateWithoutBudgetInput> | BudgetLineItemCreateWithoutBudgetInput[] | BudgetLineItemUncheckedCreateWithoutBudgetInput[]
    connectOrCreate?: BudgetLineItemCreateOrConnectWithoutBudgetInput | BudgetLineItemCreateOrConnectWithoutBudgetInput[]
    createMany?: BudgetLineItemCreateManyBudgetInputEnvelope
    connect?: BudgetLineItemWhereUniqueInput | BudgetLineItemWhereUniqueInput[]
  }

  export type ProjectCreateNestedOneWithoutBudgetInput = {
    create?: XOR<ProjectCreateWithoutBudgetInput, ProjectUncheckedCreateWithoutBudgetInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutBudgetInput
    connect?: ProjectWhereUniqueInput
  }

  export type BudgetLineItemUncheckedCreateNestedManyWithoutBudgetInput = {
    create?: XOR<BudgetLineItemCreateWithoutBudgetInput, BudgetLineItemUncheckedCreateWithoutBudgetInput> | BudgetLineItemCreateWithoutBudgetInput[] | BudgetLineItemUncheckedCreateWithoutBudgetInput[]
    connectOrCreate?: BudgetLineItemCreateOrConnectWithoutBudgetInput | BudgetLineItemCreateOrConnectWithoutBudgetInput[]
    createMany?: BudgetLineItemCreateManyBudgetInputEnvelope
    connect?: BudgetLineItemWhereUniqueInput | BudgetLineItemWhereUniqueInput[]
  }

  export type BudgetLineItemUpdateManyWithoutBudgetNestedInput = {
    create?: XOR<BudgetLineItemCreateWithoutBudgetInput, BudgetLineItemUncheckedCreateWithoutBudgetInput> | BudgetLineItemCreateWithoutBudgetInput[] | BudgetLineItemUncheckedCreateWithoutBudgetInput[]
    connectOrCreate?: BudgetLineItemCreateOrConnectWithoutBudgetInput | BudgetLineItemCreateOrConnectWithoutBudgetInput[]
    upsert?: BudgetLineItemUpsertWithWhereUniqueWithoutBudgetInput | BudgetLineItemUpsertWithWhereUniqueWithoutBudgetInput[]
    createMany?: BudgetLineItemCreateManyBudgetInputEnvelope
    set?: BudgetLineItemWhereUniqueInput | BudgetLineItemWhereUniqueInput[]
    disconnect?: BudgetLineItemWhereUniqueInput | BudgetLineItemWhereUniqueInput[]
    delete?: BudgetLineItemWhereUniqueInput | BudgetLineItemWhereUniqueInput[]
    connect?: BudgetLineItemWhereUniqueInput | BudgetLineItemWhereUniqueInput[]
    update?: BudgetLineItemUpdateWithWhereUniqueWithoutBudgetInput | BudgetLineItemUpdateWithWhereUniqueWithoutBudgetInput[]
    updateMany?: BudgetLineItemUpdateManyWithWhereWithoutBudgetInput | BudgetLineItemUpdateManyWithWhereWithoutBudgetInput[]
    deleteMany?: BudgetLineItemScalarWhereInput | BudgetLineItemScalarWhereInput[]
  }

  export type ProjectUpdateOneRequiredWithoutBudgetNestedInput = {
    create?: XOR<ProjectCreateWithoutBudgetInput, ProjectUncheckedCreateWithoutBudgetInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutBudgetInput
    upsert?: ProjectUpsertWithoutBudgetInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutBudgetInput, ProjectUpdateWithoutBudgetInput>, ProjectUncheckedUpdateWithoutBudgetInput>
  }

  export type BudgetLineItemUncheckedUpdateManyWithoutBudgetNestedInput = {
    create?: XOR<BudgetLineItemCreateWithoutBudgetInput, BudgetLineItemUncheckedCreateWithoutBudgetInput> | BudgetLineItemCreateWithoutBudgetInput[] | BudgetLineItemUncheckedCreateWithoutBudgetInput[]
    connectOrCreate?: BudgetLineItemCreateOrConnectWithoutBudgetInput | BudgetLineItemCreateOrConnectWithoutBudgetInput[]
    upsert?: BudgetLineItemUpsertWithWhereUniqueWithoutBudgetInput | BudgetLineItemUpsertWithWhereUniqueWithoutBudgetInput[]
    createMany?: BudgetLineItemCreateManyBudgetInputEnvelope
    set?: BudgetLineItemWhereUniqueInput | BudgetLineItemWhereUniqueInput[]
    disconnect?: BudgetLineItemWhereUniqueInput | BudgetLineItemWhereUniqueInput[]
    delete?: BudgetLineItemWhereUniqueInput | BudgetLineItemWhereUniqueInput[]
    connect?: BudgetLineItemWhereUniqueInput | BudgetLineItemWhereUniqueInput[]
    update?: BudgetLineItemUpdateWithWhereUniqueWithoutBudgetInput | BudgetLineItemUpdateWithWhereUniqueWithoutBudgetInput[]
    updateMany?: BudgetLineItemUpdateManyWithWhereWithoutBudgetInput | BudgetLineItemUpdateManyWithWhereWithoutBudgetInput[]
    deleteMany?: BudgetLineItemScalarWhereInput | BudgetLineItemScalarWhereInput[]
  }

  export type BudgetCreateNestedOneWithoutLineItemsInput = {
    create?: XOR<BudgetCreateWithoutLineItemsInput, BudgetUncheckedCreateWithoutLineItemsInput>
    connectOrCreate?: BudgetCreateOrConnectWithoutLineItemsInput
    connect?: BudgetWhereUniqueInput
  }

  export type BudgetUpdateOneRequiredWithoutLineItemsNestedInput = {
    create?: XOR<BudgetCreateWithoutLineItemsInput, BudgetUncheckedCreateWithoutLineItemsInput>
    connectOrCreate?: BudgetCreateOrConnectWithoutLineItemsInput
    upsert?: BudgetUpsertWithoutLineItemsInput
    connect?: BudgetWhereUniqueInput
    update?: XOR<XOR<BudgetUpdateToOneWithWhereWithoutLineItemsInput, BudgetUpdateWithoutLineItemsInput>, BudgetUncheckedUpdateWithoutLineItemsInput>
  }

  export type CustomerCreateNestedOneWithoutInteractionsInput = {
    create?: XOR<CustomerCreateWithoutInteractionsInput, CustomerUncheckedCreateWithoutInteractionsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutInteractionsInput
    connect?: CustomerWhereUniqueInput
  }

  export type CustomerUpdateOneRequiredWithoutInteractionsNestedInput = {
    create?: XOR<CustomerCreateWithoutInteractionsInput, CustomerUncheckedCreateWithoutInteractionsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutInteractionsInput
    upsert?: CustomerUpsertWithoutInteractionsInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutInteractionsInput, CustomerUpdateWithoutInteractionsInput>, CustomerUncheckedUpdateWithoutInteractionsInput>
  }

  export type CustomerCreateNestedOneWithoutMetricsInput = {
    create?: XOR<CustomerCreateWithoutMetricsInput, CustomerUncheckedCreateWithoutMetricsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutMetricsInput
    connect?: CustomerWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CustomerUpdateOneRequiredWithoutMetricsNestedInput = {
    create?: XOR<CustomerCreateWithoutMetricsInput, CustomerUncheckedCreateWithoutMetricsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutMetricsInput
    upsert?: CustomerUpsertWithoutMetricsInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutMetricsInput, CustomerUpdateWithoutMetricsInput>, CustomerUncheckedUpdateWithoutMetricsInput>
  }

  export type CustomerCreateNestedOneWithoutProposalsInput = {
    create?: XOR<CustomerCreateWithoutProposalsInput, CustomerUncheckedCreateWithoutProposalsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutProposalsInput
    connect?: CustomerWhereUniqueInput
  }

  export type PropertyCreateNestedOneWithoutProposalsInput = {
    create?: XOR<PropertyCreateWithoutProposalsInput, PropertyUncheckedCreateWithoutProposalsInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutProposalsInput
    connect?: PropertyWhereUniqueInput
  }

  export type ProjectCreateNestedOneWithoutProposalsInput = {
    create?: XOR<ProjectCreateWithoutProposalsInput, ProjectUncheckedCreateWithoutProposalsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutProposalsInput
    connect?: ProjectWhereUniqueInput
  }

  export type ProposalItemCreateNestedManyWithoutProposalInput = {
    create?: XOR<ProposalItemCreateWithoutProposalInput, ProposalItemUncheckedCreateWithoutProposalInput> | ProposalItemCreateWithoutProposalInput[] | ProposalItemUncheckedCreateWithoutProposalInput[]
    connectOrCreate?: ProposalItemCreateOrConnectWithoutProposalInput | ProposalItemCreateOrConnectWithoutProposalInput[]
    createMany?: ProposalItemCreateManyProposalInputEnvelope
    connect?: ProposalItemWhereUniqueInput | ProposalItemWhereUniqueInput[]
  }

  export type ProposalItemUncheckedCreateNestedManyWithoutProposalInput = {
    create?: XOR<ProposalItemCreateWithoutProposalInput, ProposalItemUncheckedCreateWithoutProposalInput> | ProposalItemCreateWithoutProposalInput[] | ProposalItemUncheckedCreateWithoutProposalInput[]
    connectOrCreate?: ProposalItemCreateOrConnectWithoutProposalInput | ProposalItemCreateOrConnectWithoutProposalInput[]
    createMany?: ProposalItemCreateManyProposalInputEnvelope
    connect?: ProposalItemWhereUniqueInput | ProposalItemWhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type CustomerUpdateOneWithoutProposalsNestedInput = {
    create?: XOR<CustomerCreateWithoutProposalsInput, CustomerUncheckedCreateWithoutProposalsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutProposalsInput
    upsert?: CustomerUpsertWithoutProposalsInput
    disconnect?: CustomerWhereInput | boolean
    delete?: CustomerWhereInput | boolean
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutProposalsInput, CustomerUpdateWithoutProposalsInput>, CustomerUncheckedUpdateWithoutProposalsInput>
  }

  export type PropertyUpdateOneWithoutProposalsNestedInput = {
    create?: XOR<PropertyCreateWithoutProposalsInput, PropertyUncheckedCreateWithoutProposalsInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutProposalsInput
    upsert?: PropertyUpsertWithoutProposalsInput
    disconnect?: PropertyWhereInput | boolean
    delete?: PropertyWhereInput | boolean
    connect?: PropertyWhereUniqueInput
    update?: XOR<XOR<PropertyUpdateToOneWithWhereWithoutProposalsInput, PropertyUpdateWithoutProposalsInput>, PropertyUncheckedUpdateWithoutProposalsInput>
  }

  export type ProjectUpdateOneWithoutProposalsNestedInput = {
    create?: XOR<ProjectCreateWithoutProposalsInput, ProjectUncheckedCreateWithoutProposalsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutProposalsInput
    upsert?: ProjectUpsertWithoutProposalsInput
    disconnect?: ProjectWhereInput | boolean
    delete?: ProjectWhereInput | boolean
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutProposalsInput, ProjectUpdateWithoutProposalsInput>, ProjectUncheckedUpdateWithoutProposalsInput>
  }

  export type ProposalItemUpdateManyWithoutProposalNestedInput = {
    create?: XOR<ProposalItemCreateWithoutProposalInput, ProposalItemUncheckedCreateWithoutProposalInput> | ProposalItemCreateWithoutProposalInput[] | ProposalItemUncheckedCreateWithoutProposalInput[]
    connectOrCreate?: ProposalItemCreateOrConnectWithoutProposalInput | ProposalItemCreateOrConnectWithoutProposalInput[]
    upsert?: ProposalItemUpsertWithWhereUniqueWithoutProposalInput | ProposalItemUpsertWithWhereUniqueWithoutProposalInput[]
    createMany?: ProposalItemCreateManyProposalInputEnvelope
    set?: ProposalItemWhereUniqueInput | ProposalItemWhereUniqueInput[]
    disconnect?: ProposalItemWhereUniqueInput | ProposalItemWhereUniqueInput[]
    delete?: ProposalItemWhereUniqueInput | ProposalItemWhereUniqueInput[]
    connect?: ProposalItemWhereUniqueInput | ProposalItemWhereUniqueInput[]
    update?: ProposalItemUpdateWithWhereUniqueWithoutProposalInput | ProposalItemUpdateWithWhereUniqueWithoutProposalInput[]
    updateMany?: ProposalItemUpdateManyWithWhereWithoutProposalInput | ProposalItemUpdateManyWithWhereWithoutProposalInput[]
    deleteMany?: ProposalItemScalarWhereInput | ProposalItemScalarWhereInput[]
  }

  export type ProposalItemUncheckedUpdateManyWithoutProposalNestedInput = {
    create?: XOR<ProposalItemCreateWithoutProposalInput, ProposalItemUncheckedCreateWithoutProposalInput> | ProposalItemCreateWithoutProposalInput[] | ProposalItemUncheckedCreateWithoutProposalInput[]
    connectOrCreate?: ProposalItemCreateOrConnectWithoutProposalInput | ProposalItemCreateOrConnectWithoutProposalInput[]
    upsert?: ProposalItemUpsertWithWhereUniqueWithoutProposalInput | ProposalItemUpsertWithWhereUniqueWithoutProposalInput[]
    createMany?: ProposalItemCreateManyProposalInputEnvelope
    set?: ProposalItemWhereUniqueInput | ProposalItemWhereUniqueInput[]
    disconnect?: ProposalItemWhereUniqueInput | ProposalItemWhereUniqueInput[]
    delete?: ProposalItemWhereUniqueInput | ProposalItemWhereUniqueInput[]
    connect?: ProposalItemWhereUniqueInput | ProposalItemWhereUniqueInput[]
    update?: ProposalItemUpdateWithWhereUniqueWithoutProposalInput | ProposalItemUpdateWithWhereUniqueWithoutProposalInput[]
    updateMany?: ProposalItemUpdateManyWithWhereWithoutProposalInput | ProposalItemUpdateManyWithWhereWithoutProposalInput[]
    deleteMany?: ProposalItemScalarWhereInput | ProposalItemScalarWhereInput[]
  }

  export type ProductCreateNestedOneWithoutProposalItemsInput = {
    create?: XOR<ProductCreateWithoutProposalItemsInput, ProductUncheckedCreateWithoutProposalItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutProposalItemsInput
    connect?: ProductWhereUniqueInput
  }

  export type ProposalCreateNestedOneWithoutItemsInput = {
    create?: XOR<ProposalCreateWithoutItemsInput, ProposalUncheckedCreateWithoutItemsInput>
    connectOrCreate?: ProposalCreateOrConnectWithoutItemsInput
    connect?: ProposalWhereUniqueInput
  }

  export type ProductUpdateOneWithoutProposalItemsNestedInput = {
    create?: XOR<ProductCreateWithoutProposalItemsInput, ProductUncheckedCreateWithoutProposalItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutProposalItemsInput
    upsert?: ProductUpsertWithoutProposalItemsInput
    disconnect?: ProductWhereInput | boolean
    delete?: ProductWhereInput | boolean
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutProposalItemsInput, ProductUpdateWithoutProposalItemsInput>, ProductUncheckedUpdateWithoutProposalItemsInput>
  }

  export type ProposalUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<ProposalCreateWithoutItemsInput, ProposalUncheckedCreateWithoutItemsInput>
    connectOrCreate?: ProposalCreateOrConnectWithoutItemsInput
    upsert?: ProposalUpsertWithoutItemsInput
    connect?: ProposalWhereUniqueInput
    update?: XOR<XOR<ProposalUpdateToOneWithWhereWithoutItemsInput, ProposalUpdateWithoutItemsInput>, ProposalUncheckedUpdateWithoutItemsInput>
  }

  export type ProposalItemCreateNestedManyWithoutProductInput = {
    create?: XOR<ProposalItemCreateWithoutProductInput, ProposalItemUncheckedCreateWithoutProductInput> | ProposalItemCreateWithoutProductInput[] | ProposalItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProposalItemCreateOrConnectWithoutProductInput | ProposalItemCreateOrConnectWithoutProductInput[]
    createMany?: ProposalItemCreateManyProductInputEnvelope
    connect?: ProposalItemWhereUniqueInput | ProposalItemWhereUniqueInput[]
  }

  export type ProposalItemUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<ProposalItemCreateWithoutProductInput, ProposalItemUncheckedCreateWithoutProductInput> | ProposalItemCreateWithoutProductInput[] | ProposalItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProposalItemCreateOrConnectWithoutProductInput | ProposalItemCreateOrConnectWithoutProductInput[]
    createMany?: ProposalItemCreateManyProductInputEnvelope
    connect?: ProposalItemWhereUniqueInput | ProposalItemWhereUniqueInput[]
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ProposalItemUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProposalItemCreateWithoutProductInput, ProposalItemUncheckedCreateWithoutProductInput> | ProposalItemCreateWithoutProductInput[] | ProposalItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProposalItemCreateOrConnectWithoutProductInput | ProposalItemCreateOrConnectWithoutProductInput[]
    upsert?: ProposalItemUpsertWithWhereUniqueWithoutProductInput | ProposalItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProposalItemCreateManyProductInputEnvelope
    set?: ProposalItemWhereUniqueInput | ProposalItemWhereUniqueInput[]
    disconnect?: ProposalItemWhereUniqueInput | ProposalItemWhereUniqueInput[]
    delete?: ProposalItemWhereUniqueInput | ProposalItemWhereUniqueInput[]
    connect?: ProposalItemWhereUniqueInput | ProposalItemWhereUniqueInput[]
    update?: ProposalItemUpdateWithWhereUniqueWithoutProductInput | ProposalItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProposalItemUpdateManyWithWhereWithoutProductInput | ProposalItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProposalItemScalarWhereInput | ProposalItemScalarWhereInput[]
  }

  export type ProposalItemUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProposalItemCreateWithoutProductInput, ProposalItemUncheckedCreateWithoutProductInput> | ProposalItemCreateWithoutProductInput[] | ProposalItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProposalItemCreateOrConnectWithoutProductInput | ProposalItemCreateOrConnectWithoutProductInput[]
    upsert?: ProposalItemUpsertWithWhereUniqueWithoutProductInput | ProposalItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProposalItemCreateManyProductInputEnvelope
    set?: ProposalItemWhereUniqueInput | ProposalItemWhereUniqueInput[]
    disconnect?: ProposalItemWhereUniqueInput | ProposalItemWhereUniqueInput[]
    delete?: ProposalItemWhereUniqueInput | ProposalItemWhereUniqueInput[]
    connect?: ProposalItemWhereUniqueInput | ProposalItemWhereUniqueInput[]
    update?: ProposalItemUpdateWithWhereUniqueWithoutProductInput | ProposalItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProposalItemUpdateManyWithWhereWithoutProductInput | ProposalItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProposalItemScalarWhereInput | ProposalItemScalarWhereInput[]
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type AddressCreateWithoutCustomerInput = {
    id?: string
    street: string
    city: string
    state: string
    zipCode: string
    country: string
    property?: PropertyCreateNestedOneWithoutAddressInput
  }

  export type AddressUncheckedCreateWithoutCustomerInput = {
    id?: string
    street: string
    city: string
    state: string
    zipCode: string
    country: string
    property?: PropertyUncheckedCreateNestedOneWithoutAddressInput
  }

  export type AddressCreateOrConnectWithoutCustomerInput = {
    where: AddressWhereUniqueInput
    create: XOR<AddressCreateWithoutCustomerInput, AddressUncheckedCreateWithoutCustomerInput>
  }

  export type PropertyCreateWithoutCustomerInput = {
    id?: string
    name: string
    type: string
    squareFootage: number
    bedrooms?: number | null
    bathrooms?: number | null
    yearBuilt?: number | null
    address?: AddressCreateNestedOneWithoutPropertyInput
    photos?: PhotoCreateNestedManyWithoutPropertyInput
    documents?: DocumentCreateNestedManyWithoutPropertyInput
    systems?: SystemInstallationCreateNestedManyWithoutPropertyInput
    serviceHistory?: ServiceRecordCreateNestedManyWithoutPropertyInput
    projects?: ProjectCreateNestedManyWithoutPropertyInput
    proposals?: ProposalCreateNestedManyWithoutPropertyInput
  }

  export type PropertyUncheckedCreateWithoutCustomerInput = {
    id?: string
    name: string
    type: string
    addressId?: string | null
    squareFootage: number
    bedrooms?: number | null
    bathrooms?: number | null
    yearBuilt?: number | null
    photos?: PhotoUncheckedCreateNestedManyWithoutPropertyInput
    documents?: DocumentUncheckedCreateNestedManyWithoutPropertyInput
    systems?: SystemInstallationUncheckedCreateNestedManyWithoutPropertyInput
    serviceHistory?: ServiceRecordUncheckedCreateNestedManyWithoutPropertyInput
    projects?: ProjectUncheckedCreateNestedManyWithoutPropertyInput
    proposals?: ProposalUncheckedCreateNestedManyWithoutPropertyInput
  }

  export type PropertyCreateOrConnectWithoutCustomerInput = {
    where: PropertyWhereUniqueInput
    create: XOR<PropertyCreateWithoutCustomerInput, PropertyUncheckedCreateWithoutCustomerInput>
  }

  export type PropertyCreateManyCustomerInputEnvelope = {
    data: PropertyCreateManyCustomerInput | PropertyCreateManyCustomerInput[]
  }

  export type ProjectCreateWithoutCustomerInput = {
    id?: string
    name: string
    description: string
    status: string
    startDate: Date | string
    endDate?: Date | string | null
    property: PropertyCreateNestedOneWithoutProjectsInput
    teamMembers?: ProjectTeamMemberCreateNestedManyWithoutProjectInput
    milestones?: MilestoneCreateNestedManyWithoutProjectInput
    budget?: BudgetCreateNestedOneWithoutProjectInput
    documents?: DocumentCreateNestedManyWithoutProjectInput
    proposals?: ProposalCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutCustomerInput = {
    id?: string
    name: string
    description: string
    status: string
    startDate: Date | string
    endDate?: Date | string | null
    propertyId: string
    teamMembers?: ProjectTeamMemberUncheckedCreateNestedManyWithoutProjectInput
    milestones?: MilestoneUncheckedCreateNestedManyWithoutProjectInput
    budget?: BudgetUncheckedCreateNestedOneWithoutProjectInput
    documents?: DocumentUncheckedCreateNestedManyWithoutProjectInput
    proposals?: ProposalUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutCustomerInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutCustomerInput, ProjectUncheckedCreateWithoutCustomerInput>
  }

  export type ProjectCreateManyCustomerInputEnvelope = {
    data: ProjectCreateManyCustomerInput | ProjectCreateManyCustomerInput[]
  }

  export type InteractionCreateWithoutCustomerInput = {
    id?: string
    type: string
    date: Date | string
    summary: string
    details: string
    followUpDate?: Date | string | null
    followUpNotes?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InteractionUncheckedCreateWithoutCustomerInput = {
    id?: string
    type: string
    date: Date | string
    summary: string
    details: string
    followUpDate?: Date | string | null
    followUpNotes?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InteractionCreateOrConnectWithoutCustomerInput = {
    where: InteractionWhereUniqueInput
    create: XOR<InteractionCreateWithoutCustomerInput, InteractionUncheckedCreateWithoutCustomerInput>
  }

  export type InteractionCreateManyCustomerInputEnvelope = {
    data: InteractionCreateManyCustomerInput | InteractionCreateManyCustomerInput[]
  }

  export type TagCreateWithoutCustomerInput = {
    id?: string
    name: string
  }

  export type TagUncheckedCreateWithoutCustomerInput = {
    id?: string
    name: string
  }

  export type TagCreateOrConnectWithoutCustomerInput = {
    where: TagWhereUniqueInput
    create: XOR<TagCreateWithoutCustomerInput, TagUncheckedCreateWithoutCustomerInput>
  }

  export type TagCreateManyCustomerInputEnvelope = {
    data: TagCreateManyCustomerInput | TagCreateManyCustomerInput[]
  }

  export type CustomerMetricsCreateWithoutCustomerInput = {
    id?: string
    totalRevenue: number
    projectsCompleted: number
    avgResponseTime: number
    lastInteraction?: Date | string | null
    nextScheduledInteraction?: Date | string | null
  }

  export type CustomerMetricsUncheckedCreateWithoutCustomerInput = {
    id?: string
    totalRevenue: number
    projectsCompleted: number
    avgResponseTime: number
    lastInteraction?: Date | string | null
    nextScheduledInteraction?: Date | string | null
  }

  export type CustomerMetricsCreateOrConnectWithoutCustomerInput = {
    where: CustomerMetricsWhereUniqueInput
    create: XOR<CustomerMetricsCreateWithoutCustomerInput, CustomerMetricsUncheckedCreateWithoutCustomerInput>
  }

  export type ProposalCreateWithoutCustomerInput = {
    id?: string
    name: string
    description?: string | null
    status: string
    customerPersona: string
    voiceTranscript?: string | null
    aiSummary?: string | null
    totalAmount?: number
    validUntil?: Date | string | null
    isExistingCustomer?: boolean
    prospectName?: string | null
    prospectCompany?: string | null
    prospectEmail?: string | null
    prospectPhone?: string | null
    prospectStatus?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    property?: PropertyCreateNestedOneWithoutProposalsInput
    project?: ProjectCreateNestedOneWithoutProposalsInput
    items?: ProposalItemCreateNestedManyWithoutProposalInput
  }

  export type ProposalUncheckedCreateWithoutCustomerInput = {
    id?: string
    name: string
    description?: string | null
    status: string
    customerPersona: string
    voiceTranscript?: string | null
    aiSummary?: string | null
    totalAmount?: number
    validUntil?: Date | string | null
    isExistingCustomer?: boolean
    prospectName?: string | null
    prospectCompany?: string | null
    prospectEmail?: string | null
    prospectPhone?: string | null
    prospectStatus?: string | null
    propertyId?: string | null
    projectId?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: ProposalItemUncheckedCreateNestedManyWithoutProposalInput
  }

  export type ProposalCreateOrConnectWithoutCustomerInput = {
    where: ProposalWhereUniqueInput
    create: XOR<ProposalCreateWithoutCustomerInput, ProposalUncheckedCreateWithoutCustomerInput>
  }

  export type ProposalCreateManyCustomerInputEnvelope = {
    data: ProposalCreateManyCustomerInput | ProposalCreateManyCustomerInput[]
  }

  export type AddressUpsertWithoutCustomerInput = {
    update: XOR<AddressUpdateWithoutCustomerInput, AddressUncheckedUpdateWithoutCustomerInput>
    create: XOR<AddressCreateWithoutCustomerInput, AddressUncheckedCreateWithoutCustomerInput>
    where?: AddressWhereInput
  }

  export type AddressUpdateToOneWithWhereWithoutCustomerInput = {
    where?: AddressWhereInput
    data: XOR<AddressUpdateWithoutCustomerInput, AddressUncheckedUpdateWithoutCustomerInput>
  }

  export type AddressUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    property?: PropertyUpdateOneWithoutAddressNestedInput
  }

  export type AddressUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    property?: PropertyUncheckedUpdateOneWithoutAddressNestedInput
  }

  export type PropertyUpsertWithWhereUniqueWithoutCustomerInput = {
    where: PropertyWhereUniqueInput
    update: XOR<PropertyUpdateWithoutCustomerInput, PropertyUncheckedUpdateWithoutCustomerInput>
    create: XOR<PropertyCreateWithoutCustomerInput, PropertyUncheckedCreateWithoutCustomerInput>
  }

  export type PropertyUpdateWithWhereUniqueWithoutCustomerInput = {
    where: PropertyWhereUniqueInput
    data: XOR<PropertyUpdateWithoutCustomerInput, PropertyUncheckedUpdateWithoutCustomerInput>
  }

  export type PropertyUpdateManyWithWhereWithoutCustomerInput = {
    where: PropertyScalarWhereInput
    data: XOR<PropertyUpdateManyMutationInput, PropertyUncheckedUpdateManyWithoutCustomerInput>
  }

  export type PropertyScalarWhereInput = {
    AND?: PropertyScalarWhereInput | PropertyScalarWhereInput[]
    OR?: PropertyScalarWhereInput[]
    NOT?: PropertyScalarWhereInput | PropertyScalarWhereInput[]
    id?: StringFilter<"Property"> | string
    name?: StringFilter<"Property"> | string
    type?: StringFilter<"Property"> | string
    addressId?: StringNullableFilter<"Property"> | string | null
    squareFootage?: FloatFilter<"Property"> | number
    bedrooms?: IntNullableFilter<"Property"> | number | null
    bathrooms?: IntNullableFilter<"Property"> | number | null
    yearBuilt?: IntNullableFilter<"Property"> | number | null
    customerId?: StringFilter<"Property"> | string
  }

  export type ProjectUpsertWithWhereUniqueWithoutCustomerInput = {
    where: ProjectWhereUniqueInput
    update: XOR<ProjectUpdateWithoutCustomerInput, ProjectUncheckedUpdateWithoutCustomerInput>
    create: XOR<ProjectCreateWithoutCustomerInput, ProjectUncheckedCreateWithoutCustomerInput>
  }

  export type ProjectUpdateWithWhereUniqueWithoutCustomerInput = {
    where: ProjectWhereUniqueInput
    data: XOR<ProjectUpdateWithoutCustomerInput, ProjectUncheckedUpdateWithoutCustomerInput>
  }

  export type ProjectUpdateManyWithWhereWithoutCustomerInput = {
    where: ProjectScalarWhereInput
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyWithoutCustomerInput>
  }

  export type ProjectScalarWhereInput = {
    AND?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
    OR?: ProjectScalarWhereInput[]
    NOT?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
    id?: StringFilter<"Project"> | string
    name?: StringFilter<"Project"> | string
    description?: StringFilter<"Project"> | string
    status?: StringFilter<"Project"> | string
    startDate?: DateTimeFilter<"Project"> | Date | string
    endDate?: DateTimeNullableFilter<"Project"> | Date | string | null
    propertyId?: StringFilter<"Project"> | string
    customerId?: StringFilter<"Project"> | string
  }

  export type InteractionUpsertWithWhereUniqueWithoutCustomerInput = {
    where: InteractionWhereUniqueInput
    update: XOR<InteractionUpdateWithoutCustomerInput, InteractionUncheckedUpdateWithoutCustomerInput>
    create: XOR<InteractionCreateWithoutCustomerInput, InteractionUncheckedCreateWithoutCustomerInput>
  }

  export type InteractionUpdateWithWhereUniqueWithoutCustomerInput = {
    where: InteractionWhereUniqueInput
    data: XOR<InteractionUpdateWithoutCustomerInput, InteractionUncheckedUpdateWithoutCustomerInput>
  }

  export type InteractionUpdateManyWithWhereWithoutCustomerInput = {
    where: InteractionScalarWhereInput
    data: XOR<InteractionUpdateManyMutationInput, InteractionUncheckedUpdateManyWithoutCustomerInput>
  }

  export type InteractionScalarWhereInput = {
    AND?: InteractionScalarWhereInput | InteractionScalarWhereInput[]
    OR?: InteractionScalarWhereInput[]
    NOT?: InteractionScalarWhereInput | InteractionScalarWhereInput[]
    id?: StringFilter<"Interaction"> | string
    type?: StringFilter<"Interaction"> | string
    date?: DateTimeFilter<"Interaction"> | Date | string
    summary?: StringFilter<"Interaction"> | string
    details?: StringFilter<"Interaction"> | string
    followUpDate?: DateTimeNullableFilter<"Interaction"> | Date | string | null
    followUpNotes?: StringNullableFilter<"Interaction"> | string | null
    createdBy?: StringFilter<"Interaction"> | string
    createdAt?: DateTimeFilter<"Interaction"> | Date | string
    updatedAt?: DateTimeFilter<"Interaction"> | Date | string
    customerId?: StringFilter<"Interaction"> | string
  }

  export type TagUpsertWithWhereUniqueWithoutCustomerInput = {
    where: TagWhereUniqueInput
    update: XOR<TagUpdateWithoutCustomerInput, TagUncheckedUpdateWithoutCustomerInput>
    create: XOR<TagCreateWithoutCustomerInput, TagUncheckedCreateWithoutCustomerInput>
  }

  export type TagUpdateWithWhereUniqueWithoutCustomerInput = {
    where: TagWhereUniqueInput
    data: XOR<TagUpdateWithoutCustomerInput, TagUncheckedUpdateWithoutCustomerInput>
  }

  export type TagUpdateManyWithWhereWithoutCustomerInput = {
    where: TagScalarWhereInput
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyWithoutCustomerInput>
  }

  export type TagScalarWhereInput = {
    AND?: TagScalarWhereInput | TagScalarWhereInput[]
    OR?: TagScalarWhereInput[]
    NOT?: TagScalarWhereInput | TagScalarWhereInput[]
    id?: StringFilter<"Tag"> | string
    name?: StringFilter<"Tag"> | string
    customerId?: StringFilter<"Tag"> | string
  }

  export type CustomerMetricsUpsertWithoutCustomerInput = {
    update: XOR<CustomerMetricsUpdateWithoutCustomerInput, CustomerMetricsUncheckedUpdateWithoutCustomerInput>
    create: XOR<CustomerMetricsCreateWithoutCustomerInput, CustomerMetricsUncheckedCreateWithoutCustomerInput>
    where?: CustomerMetricsWhereInput
  }

  export type CustomerMetricsUpdateToOneWithWhereWithoutCustomerInput = {
    where?: CustomerMetricsWhereInput
    data: XOR<CustomerMetricsUpdateWithoutCustomerInput, CustomerMetricsUncheckedUpdateWithoutCustomerInput>
  }

  export type CustomerMetricsUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalRevenue?: FloatFieldUpdateOperationsInput | number
    projectsCompleted?: IntFieldUpdateOperationsInput | number
    avgResponseTime?: FloatFieldUpdateOperationsInput | number
    lastInteraction?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextScheduledInteraction?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CustomerMetricsUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalRevenue?: FloatFieldUpdateOperationsInput | number
    projectsCompleted?: IntFieldUpdateOperationsInput | number
    avgResponseTime?: FloatFieldUpdateOperationsInput | number
    lastInteraction?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextScheduledInteraction?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProposalUpsertWithWhereUniqueWithoutCustomerInput = {
    where: ProposalWhereUniqueInput
    update: XOR<ProposalUpdateWithoutCustomerInput, ProposalUncheckedUpdateWithoutCustomerInput>
    create: XOR<ProposalCreateWithoutCustomerInput, ProposalUncheckedCreateWithoutCustomerInput>
  }

  export type ProposalUpdateWithWhereUniqueWithoutCustomerInput = {
    where: ProposalWhereUniqueInput
    data: XOR<ProposalUpdateWithoutCustomerInput, ProposalUncheckedUpdateWithoutCustomerInput>
  }

  export type ProposalUpdateManyWithWhereWithoutCustomerInput = {
    where: ProposalScalarWhereInput
    data: XOR<ProposalUpdateManyMutationInput, ProposalUncheckedUpdateManyWithoutCustomerInput>
  }

  export type ProposalScalarWhereInput = {
    AND?: ProposalScalarWhereInput | ProposalScalarWhereInput[]
    OR?: ProposalScalarWhereInput[]
    NOT?: ProposalScalarWhereInput | ProposalScalarWhereInput[]
    id?: StringFilter<"Proposal"> | string
    name?: StringFilter<"Proposal"> | string
    description?: StringNullableFilter<"Proposal"> | string | null
    status?: StringFilter<"Proposal"> | string
    customerPersona?: StringFilter<"Proposal"> | string
    voiceTranscript?: StringNullableFilter<"Proposal"> | string | null
    aiSummary?: StringNullableFilter<"Proposal"> | string | null
    totalAmount?: FloatFilter<"Proposal"> | number
    validUntil?: DateTimeNullableFilter<"Proposal"> | Date | string | null
    isExistingCustomer?: BoolFilter<"Proposal"> | boolean
    customerId?: StringNullableFilter<"Proposal"> | string | null
    prospectName?: StringNullableFilter<"Proposal"> | string | null
    prospectCompany?: StringNullableFilter<"Proposal"> | string | null
    prospectEmail?: StringNullableFilter<"Proposal"> | string | null
    prospectPhone?: StringNullableFilter<"Proposal"> | string | null
    prospectStatus?: StringNullableFilter<"Proposal"> | string | null
    propertyId?: StringNullableFilter<"Proposal"> | string | null
    projectId?: StringNullableFilter<"Proposal"> | string | null
    createdBy?: StringFilter<"Proposal"> | string
    createdAt?: DateTimeFilter<"Proposal"> | Date | string
    updatedAt?: DateTimeFilter<"Proposal"> | Date | string
  }

  export type CustomerCreateWithoutTagsInput = {
    id?: string
    type: string
    status: string
    firstName: string
    lastName: string
    company?: string | null
    email: string
    phone: string
    preferredCommunication: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    billingAddress?: AddressCreateNestedOneWithoutCustomerInput
    properties?: PropertyCreateNestedManyWithoutCustomerInput
    projects?: ProjectCreateNestedManyWithoutCustomerInput
    interactions?: InteractionCreateNestedManyWithoutCustomerInput
    metrics?: CustomerMetricsCreateNestedOneWithoutCustomerInput
    proposals?: ProposalCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutTagsInput = {
    id?: string
    type: string
    status: string
    firstName: string
    lastName: string
    company?: string | null
    email: string
    phone: string
    preferredCommunication: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    billingAddress?: AddressUncheckedCreateNestedOneWithoutCustomerInput
    properties?: PropertyUncheckedCreateNestedManyWithoutCustomerInput
    projects?: ProjectUncheckedCreateNestedManyWithoutCustomerInput
    interactions?: InteractionUncheckedCreateNestedManyWithoutCustomerInput
    metrics?: CustomerMetricsUncheckedCreateNestedOneWithoutCustomerInput
    proposals?: ProposalUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutTagsInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutTagsInput, CustomerUncheckedCreateWithoutTagsInput>
  }

  export type CustomerUpsertWithoutTagsInput = {
    update: XOR<CustomerUpdateWithoutTagsInput, CustomerUncheckedUpdateWithoutTagsInput>
    create: XOR<CustomerCreateWithoutTagsInput, CustomerUncheckedCreateWithoutTagsInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutTagsInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutTagsInput, CustomerUncheckedUpdateWithoutTagsInput>
  }

  export type CustomerUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    company?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    preferredCommunication?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    billingAddress?: AddressUpdateOneWithoutCustomerNestedInput
    properties?: PropertyUpdateManyWithoutCustomerNestedInput
    projects?: ProjectUpdateManyWithoutCustomerNestedInput
    interactions?: InteractionUpdateManyWithoutCustomerNestedInput
    metrics?: CustomerMetricsUpdateOneWithoutCustomerNestedInput
    proposals?: ProposalUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    company?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    preferredCommunication?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    billingAddress?: AddressUncheckedUpdateOneWithoutCustomerNestedInput
    properties?: PropertyUncheckedUpdateManyWithoutCustomerNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutCustomerNestedInput
    interactions?: InteractionUncheckedUpdateManyWithoutCustomerNestedInput
    metrics?: CustomerMetricsUncheckedUpdateOneWithoutCustomerNestedInput
    proposals?: ProposalUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerCreateWithoutBillingAddressInput = {
    id?: string
    type: string
    status: string
    firstName: string
    lastName: string
    company?: string | null
    email: string
    phone: string
    preferredCommunication: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    properties?: PropertyCreateNestedManyWithoutCustomerInput
    projects?: ProjectCreateNestedManyWithoutCustomerInput
    interactions?: InteractionCreateNestedManyWithoutCustomerInput
    tags?: TagCreateNestedManyWithoutCustomerInput
    metrics?: CustomerMetricsCreateNestedOneWithoutCustomerInput
    proposals?: ProposalCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutBillingAddressInput = {
    id?: string
    type: string
    status: string
    firstName: string
    lastName: string
    company?: string | null
    email: string
    phone: string
    preferredCommunication: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    properties?: PropertyUncheckedCreateNestedManyWithoutCustomerInput
    projects?: ProjectUncheckedCreateNestedManyWithoutCustomerInput
    interactions?: InteractionUncheckedCreateNestedManyWithoutCustomerInput
    tags?: TagUncheckedCreateNestedManyWithoutCustomerInput
    metrics?: CustomerMetricsUncheckedCreateNestedOneWithoutCustomerInput
    proposals?: ProposalUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutBillingAddressInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutBillingAddressInput, CustomerUncheckedCreateWithoutBillingAddressInput>
  }

  export type PropertyCreateWithoutAddressInput = {
    id?: string
    name: string
    type: string
    squareFootage: number
    bedrooms?: number | null
    bathrooms?: number | null
    yearBuilt?: number | null
    photos?: PhotoCreateNestedManyWithoutPropertyInput
    documents?: DocumentCreateNestedManyWithoutPropertyInput
    systems?: SystemInstallationCreateNestedManyWithoutPropertyInput
    serviceHistory?: ServiceRecordCreateNestedManyWithoutPropertyInput
    customer: CustomerCreateNestedOneWithoutPropertiesInput
    projects?: ProjectCreateNestedManyWithoutPropertyInput
    proposals?: ProposalCreateNestedManyWithoutPropertyInput
  }

  export type PropertyUncheckedCreateWithoutAddressInput = {
    id?: string
    name: string
    type: string
    squareFootage: number
    bedrooms?: number | null
    bathrooms?: number | null
    yearBuilt?: number | null
    customerId: string
    photos?: PhotoUncheckedCreateNestedManyWithoutPropertyInput
    documents?: DocumentUncheckedCreateNestedManyWithoutPropertyInput
    systems?: SystemInstallationUncheckedCreateNestedManyWithoutPropertyInput
    serviceHistory?: ServiceRecordUncheckedCreateNestedManyWithoutPropertyInput
    projects?: ProjectUncheckedCreateNestedManyWithoutPropertyInput
    proposals?: ProposalUncheckedCreateNestedManyWithoutPropertyInput
  }

  export type PropertyCreateOrConnectWithoutAddressInput = {
    where: PropertyWhereUniqueInput
    create: XOR<PropertyCreateWithoutAddressInput, PropertyUncheckedCreateWithoutAddressInput>
  }

  export type CustomerUpsertWithoutBillingAddressInput = {
    update: XOR<CustomerUpdateWithoutBillingAddressInput, CustomerUncheckedUpdateWithoutBillingAddressInput>
    create: XOR<CustomerCreateWithoutBillingAddressInput, CustomerUncheckedCreateWithoutBillingAddressInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutBillingAddressInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutBillingAddressInput, CustomerUncheckedUpdateWithoutBillingAddressInput>
  }

  export type CustomerUpdateWithoutBillingAddressInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    company?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    preferredCommunication?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    properties?: PropertyUpdateManyWithoutCustomerNestedInput
    projects?: ProjectUpdateManyWithoutCustomerNestedInput
    interactions?: InteractionUpdateManyWithoutCustomerNestedInput
    tags?: TagUpdateManyWithoutCustomerNestedInput
    metrics?: CustomerMetricsUpdateOneWithoutCustomerNestedInput
    proposals?: ProposalUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutBillingAddressInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    company?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    preferredCommunication?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    properties?: PropertyUncheckedUpdateManyWithoutCustomerNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutCustomerNestedInput
    interactions?: InteractionUncheckedUpdateManyWithoutCustomerNestedInput
    tags?: TagUncheckedUpdateManyWithoutCustomerNestedInput
    metrics?: CustomerMetricsUncheckedUpdateOneWithoutCustomerNestedInput
    proposals?: ProposalUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type PropertyUpsertWithoutAddressInput = {
    update: XOR<PropertyUpdateWithoutAddressInput, PropertyUncheckedUpdateWithoutAddressInput>
    create: XOR<PropertyCreateWithoutAddressInput, PropertyUncheckedCreateWithoutAddressInput>
    where?: PropertyWhereInput
  }

  export type PropertyUpdateToOneWithWhereWithoutAddressInput = {
    where?: PropertyWhereInput
    data: XOR<PropertyUpdateWithoutAddressInput, PropertyUncheckedUpdateWithoutAddressInput>
  }

  export type PropertyUpdateWithoutAddressInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    squareFootage?: FloatFieldUpdateOperationsInput | number
    bedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    bathrooms?: NullableIntFieldUpdateOperationsInput | number | null
    yearBuilt?: NullableIntFieldUpdateOperationsInput | number | null
    photos?: PhotoUpdateManyWithoutPropertyNestedInput
    documents?: DocumentUpdateManyWithoutPropertyNestedInput
    systems?: SystemInstallationUpdateManyWithoutPropertyNestedInput
    serviceHistory?: ServiceRecordUpdateManyWithoutPropertyNestedInput
    customer?: CustomerUpdateOneRequiredWithoutPropertiesNestedInput
    projects?: ProjectUpdateManyWithoutPropertyNestedInput
    proposals?: ProposalUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateWithoutAddressInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    squareFootage?: FloatFieldUpdateOperationsInput | number
    bedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    bathrooms?: NullableIntFieldUpdateOperationsInput | number | null
    yearBuilt?: NullableIntFieldUpdateOperationsInput | number | null
    customerId?: StringFieldUpdateOperationsInput | string
    photos?: PhotoUncheckedUpdateManyWithoutPropertyNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutPropertyNestedInput
    systems?: SystemInstallationUncheckedUpdateManyWithoutPropertyNestedInput
    serviceHistory?: ServiceRecordUncheckedUpdateManyWithoutPropertyNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutPropertyNestedInput
    proposals?: ProposalUncheckedUpdateManyWithoutPropertyNestedInput
  }

  export type AddressCreateWithoutPropertyInput = {
    id?: string
    street: string
    city: string
    state: string
    zipCode: string
    country: string
    customer: CustomerCreateNestedOneWithoutBillingAddressInput
  }

  export type AddressUncheckedCreateWithoutPropertyInput = {
    id?: string
    street: string
    city: string
    state: string
    zipCode: string
    country: string
    customerId: string
  }

  export type AddressCreateOrConnectWithoutPropertyInput = {
    where: AddressWhereUniqueInput
    create: XOR<AddressCreateWithoutPropertyInput, AddressUncheckedCreateWithoutPropertyInput>
  }

  export type PhotoCreateWithoutPropertyInput = {
    id?: string
    url: string
    uploadedAt?: Date | string
    uploadedBy: string
  }

  export type PhotoUncheckedCreateWithoutPropertyInput = {
    id?: string
    url: string
    uploadedAt?: Date | string
    uploadedBy: string
  }

  export type PhotoCreateOrConnectWithoutPropertyInput = {
    where: PhotoWhereUniqueInput
    create: XOR<PhotoCreateWithoutPropertyInput, PhotoUncheckedCreateWithoutPropertyInput>
  }

  export type PhotoCreateManyPropertyInputEnvelope = {
    data: PhotoCreateManyPropertyInput | PhotoCreateManyPropertyInput[]
  }

  export type DocumentCreateWithoutPropertyInput = {
    id?: string
    name: string
    url: string
    type: string
    uploadedAt?: Date | string
    uploadedBy: string
    project?: ProjectCreateNestedOneWithoutDocumentsInput
  }

  export type DocumentUncheckedCreateWithoutPropertyInput = {
    id?: string
    name: string
    url: string
    type: string
    projectId?: string | null
    uploadedAt?: Date | string
    uploadedBy: string
  }

  export type DocumentCreateOrConnectWithoutPropertyInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutPropertyInput, DocumentUncheckedCreateWithoutPropertyInput>
  }

  export type DocumentCreateManyPropertyInputEnvelope = {
    data: DocumentCreateManyPropertyInput | DocumentCreateManyPropertyInput[]
  }

  export type SystemInstallationCreateWithoutPropertyInput = {
    id?: string
    type: string
    details: string
    installDate?: Date | string | null
    lastService?: Date | string | null
  }

  export type SystemInstallationUncheckedCreateWithoutPropertyInput = {
    id?: string
    type: string
    details: string
    installDate?: Date | string | null
    lastService?: Date | string | null
  }

  export type SystemInstallationCreateOrConnectWithoutPropertyInput = {
    where: SystemInstallationWhereUniqueInput
    create: XOR<SystemInstallationCreateWithoutPropertyInput, SystemInstallationUncheckedCreateWithoutPropertyInput>
  }

  export type SystemInstallationCreateManyPropertyInputEnvelope = {
    data: SystemInstallationCreateManyPropertyInput | SystemInstallationCreateManyPropertyInput[]
  }

  export type ServiceRecordCreateWithoutPropertyInput = {
    id?: string
    date: Date | string
    type: string
    description: string
    technician: string
    cost: number
  }

  export type ServiceRecordUncheckedCreateWithoutPropertyInput = {
    id?: string
    date: Date | string
    type: string
    description: string
    technician: string
    cost: number
  }

  export type ServiceRecordCreateOrConnectWithoutPropertyInput = {
    where: ServiceRecordWhereUniqueInput
    create: XOR<ServiceRecordCreateWithoutPropertyInput, ServiceRecordUncheckedCreateWithoutPropertyInput>
  }

  export type ServiceRecordCreateManyPropertyInputEnvelope = {
    data: ServiceRecordCreateManyPropertyInput | ServiceRecordCreateManyPropertyInput[]
  }

  export type CustomerCreateWithoutPropertiesInput = {
    id?: string
    type: string
    status: string
    firstName: string
    lastName: string
    company?: string | null
    email: string
    phone: string
    preferredCommunication: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    billingAddress?: AddressCreateNestedOneWithoutCustomerInput
    projects?: ProjectCreateNestedManyWithoutCustomerInput
    interactions?: InteractionCreateNestedManyWithoutCustomerInput
    tags?: TagCreateNestedManyWithoutCustomerInput
    metrics?: CustomerMetricsCreateNestedOneWithoutCustomerInput
    proposals?: ProposalCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutPropertiesInput = {
    id?: string
    type: string
    status: string
    firstName: string
    lastName: string
    company?: string | null
    email: string
    phone: string
    preferredCommunication: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    billingAddress?: AddressUncheckedCreateNestedOneWithoutCustomerInput
    projects?: ProjectUncheckedCreateNestedManyWithoutCustomerInput
    interactions?: InteractionUncheckedCreateNestedManyWithoutCustomerInput
    tags?: TagUncheckedCreateNestedManyWithoutCustomerInput
    metrics?: CustomerMetricsUncheckedCreateNestedOneWithoutCustomerInput
    proposals?: ProposalUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutPropertiesInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutPropertiesInput, CustomerUncheckedCreateWithoutPropertiesInput>
  }

  export type ProjectCreateWithoutPropertyInput = {
    id?: string
    name: string
    description: string
    status: string
    startDate: Date | string
    endDate?: Date | string | null
    teamMembers?: ProjectTeamMemberCreateNestedManyWithoutProjectInput
    milestones?: MilestoneCreateNestedManyWithoutProjectInput
    budget?: BudgetCreateNestedOneWithoutProjectInput
    documents?: DocumentCreateNestedManyWithoutProjectInput
    customer: CustomerCreateNestedOneWithoutProjectsInput
    proposals?: ProposalCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutPropertyInput = {
    id?: string
    name: string
    description: string
    status: string
    startDate: Date | string
    endDate?: Date | string | null
    customerId: string
    teamMembers?: ProjectTeamMemberUncheckedCreateNestedManyWithoutProjectInput
    milestones?: MilestoneUncheckedCreateNestedManyWithoutProjectInput
    budget?: BudgetUncheckedCreateNestedOneWithoutProjectInput
    documents?: DocumentUncheckedCreateNestedManyWithoutProjectInput
    proposals?: ProposalUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutPropertyInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutPropertyInput, ProjectUncheckedCreateWithoutPropertyInput>
  }

  export type ProjectCreateManyPropertyInputEnvelope = {
    data: ProjectCreateManyPropertyInput | ProjectCreateManyPropertyInput[]
  }

  export type ProposalCreateWithoutPropertyInput = {
    id?: string
    name: string
    description?: string | null
    status: string
    customerPersona: string
    voiceTranscript?: string | null
    aiSummary?: string | null
    totalAmount?: number
    validUntil?: Date | string | null
    isExistingCustomer?: boolean
    prospectName?: string | null
    prospectCompany?: string | null
    prospectEmail?: string | null
    prospectPhone?: string | null
    prospectStatus?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    customer?: CustomerCreateNestedOneWithoutProposalsInput
    project?: ProjectCreateNestedOneWithoutProposalsInput
    items?: ProposalItemCreateNestedManyWithoutProposalInput
  }

  export type ProposalUncheckedCreateWithoutPropertyInput = {
    id?: string
    name: string
    description?: string | null
    status: string
    customerPersona: string
    voiceTranscript?: string | null
    aiSummary?: string | null
    totalAmount?: number
    validUntil?: Date | string | null
    isExistingCustomer?: boolean
    customerId?: string | null
    prospectName?: string | null
    prospectCompany?: string | null
    prospectEmail?: string | null
    prospectPhone?: string | null
    prospectStatus?: string | null
    projectId?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: ProposalItemUncheckedCreateNestedManyWithoutProposalInput
  }

  export type ProposalCreateOrConnectWithoutPropertyInput = {
    where: ProposalWhereUniqueInput
    create: XOR<ProposalCreateWithoutPropertyInput, ProposalUncheckedCreateWithoutPropertyInput>
  }

  export type ProposalCreateManyPropertyInputEnvelope = {
    data: ProposalCreateManyPropertyInput | ProposalCreateManyPropertyInput[]
  }

  export type AddressUpsertWithoutPropertyInput = {
    update: XOR<AddressUpdateWithoutPropertyInput, AddressUncheckedUpdateWithoutPropertyInput>
    create: XOR<AddressCreateWithoutPropertyInput, AddressUncheckedCreateWithoutPropertyInput>
    where?: AddressWhereInput
  }

  export type AddressUpdateToOneWithWhereWithoutPropertyInput = {
    where?: AddressWhereInput
    data: XOR<AddressUpdateWithoutPropertyInput, AddressUncheckedUpdateWithoutPropertyInput>
  }

  export type AddressUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    customer?: CustomerUpdateOneRequiredWithoutBillingAddressNestedInput
  }

  export type AddressUncheckedUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
  }

  export type PhotoUpsertWithWhereUniqueWithoutPropertyInput = {
    where: PhotoWhereUniqueInput
    update: XOR<PhotoUpdateWithoutPropertyInput, PhotoUncheckedUpdateWithoutPropertyInput>
    create: XOR<PhotoCreateWithoutPropertyInput, PhotoUncheckedCreateWithoutPropertyInput>
  }

  export type PhotoUpdateWithWhereUniqueWithoutPropertyInput = {
    where: PhotoWhereUniqueInput
    data: XOR<PhotoUpdateWithoutPropertyInput, PhotoUncheckedUpdateWithoutPropertyInput>
  }

  export type PhotoUpdateManyWithWhereWithoutPropertyInput = {
    where: PhotoScalarWhereInput
    data: XOR<PhotoUpdateManyMutationInput, PhotoUncheckedUpdateManyWithoutPropertyInput>
  }

  export type PhotoScalarWhereInput = {
    AND?: PhotoScalarWhereInput | PhotoScalarWhereInput[]
    OR?: PhotoScalarWhereInput[]
    NOT?: PhotoScalarWhereInput | PhotoScalarWhereInput[]
    id?: StringFilter<"Photo"> | string
    url?: StringFilter<"Photo"> | string
    propertyId?: StringFilter<"Photo"> | string
    uploadedAt?: DateTimeFilter<"Photo"> | Date | string
    uploadedBy?: StringFilter<"Photo"> | string
  }

  export type DocumentUpsertWithWhereUniqueWithoutPropertyInput = {
    where: DocumentWhereUniqueInput
    update: XOR<DocumentUpdateWithoutPropertyInput, DocumentUncheckedUpdateWithoutPropertyInput>
    create: XOR<DocumentCreateWithoutPropertyInput, DocumentUncheckedCreateWithoutPropertyInput>
  }

  export type DocumentUpdateWithWhereUniqueWithoutPropertyInput = {
    where: DocumentWhereUniqueInput
    data: XOR<DocumentUpdateWithoutPropertyInput, DocumentUncheckedUpdateWithoutPropertyInput>
  }

  export type DocumentUpdateManyWithWhereWithoutPropertyInput = {
    where: DocumentScalarWhereInput
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyWithoutPropertyInput>
  }

  export type DocumentScalarWhereInput = {
    AND?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
    OR?: DocumentScalarWhereInput[]
    NOT?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
    id?: StringFilter<"Document"> | string
    name?: StringFilter<"Document"> | string
    url?: StringFilter<"Document"> | string
    type?: StringFilter<"Document"> | string
    propertyId?: StringNullableFilter<"Document"> | string | null
    projectId?: StringNullableFilter<"Document"> | string | null
    uploadedAt?: DateTimeFilter<"Document"> | Date | string
    uploadedBy?: StringFilter<"Document"> | string
  }

  export type SystemInstallationUpsertWithWhereUniqueWithoutPropertyInput = {
    where: SystemInstallationWhereUniqueInput
    update: XOR<SystemInstallationUpdateWithoutPropertyInput, SystemInstallationUncheckedUpdateWithoutPropertyInput>
    create: XOR<SystemInstallationCreateWithoutPropertyInput, SystemInstallationUncheckedCreateWithoutPropertyInput>
  }

  export type SystemInstallationUpdateWithWhereUniqueWithoutPropertyInput = {
    where: SystemInstallationWhereUniqueInput
    data: XOR<SystemInstallationUpdateWithoutPropertyInput, SystemInstallationUncheckedUpdateWithoutPropertyInput>
  }

  export type SystemInstallationUpdateManyWithWhereWithoutPropertyInput = {
    where: SystemInstallationScalarWhereInput
    data: XOR<SystemInstallationUpdateManyMutationInput, SystemInstallationUncheckedUpdateManyWithoutPropertyInput>
  }

  export type SystemInstallationScalarWhereInput = {
    AND?: SystemInstallationScalarWhereInput | SystemInstallationScalarWhereInput[]
    OR?: SystemInstallationScalarWhereInput[]
    NOT?: SystemInstallationScalarWhereInput | SystemInstallationScalarWhereInput[]
    id?: StringFilter<"SystemInstallation"> | string
    type?: StringFilter<"SystemInstallation"> | string
    details?: StringFilter<"SystemInstallation"> | string
    installDate?: DateTimeNullableFilter<"SystemInstallation"> | Date | string | null
    lastService?: DateTimeNullableFilter<"SystemInstallation"> | Date | string | null
    propertyId?: StringFilter<"SystemInstallation"> | string
  }

  export type ServiceRecordUpsertWithWhereUniqueWithoutPropertyInput = {
    where: ServiceRecordWhereUniqueInput
    update: XOR<ServiceRecordUpdateWithoutPropertyInput, ServiceRecordUncheckedUpdateWithoutPropertyInput>
    create: XOR<ServiceRecordCreateWithoutPropertyInput, ServiceRecordUncheckedCreateWithoutPropertyInput>
  }

  export type ServiceRecordUpdateWithWhereUniqueWithoutPropertyInput = {
    where: ServiceRecordWhereUniqueInput
    data: XOR<ServiceRecordUpdateWithoutPropertyInput, ServiceRecordUncheckedUpdateWithoutPropertyInput>
  }

  export type ServiceRecordUpdateManyWithWhereWithoutPropertyInput = {
    where: ServiceRecordScalarWhereInput
    data: XOR<ServiceRecordUpdateManyMutationInput, ServiceRecordUncheckedUpdateManyWithoutPropertyInput>
  }

  export type ServiceRecordScalarWhereInput = {
    AND?: ServiceRecordScalarWhereInput | ServiceRecordScalarWhereInput[]
    OR?: ServiceRecordScalarWhereInput[]
    NOT?: ServiceRecordScalarWhereInput | ServiceRecordScalarWhereInput[]
    id?: StringFilter<"ServiceRecord"> | string
    date?: DateTimeFilter<"ServiceRecord"> | Date | string
    type?: StringFilter<"ServiceRecord"> | string
    description?: StringFilter<"ServiceRecord"> | string
    technician?: StringFilter<"ServiceRecord"> | string
    cost?: FloatFilter<"ServiceRecord"> | number
    propertyId?: StringFilter<"ServiceRecord"> | string
  }

  export type CustomerUpsertWithoutPropertiesInput = {
    update: XOR<CustomerUpdateWithoutPropertiesInput, CustomerUncheckedUpdateWithoutPropertiesInput>
    create: XOR<CustomerCreateWithoutPropertiesInput, CustomerUncheckedCreateWithoutPropertiesInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutPropertiesInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutPropertiesInput, CustomerUncheckedUpdateWithoutPropertiesInput>
  }

  export type CustomerUpdateWithoutPropertiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    company?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    preferredCommunication?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    billingAddress?: AddressUpdateOneWithoutCustomerNestedInput
    projects?: ProjectUpdateManyWithoutCustomerNestedInput
    interactions?: InteractionUpdateManyWithoutCustomerNestedInput
    tags?: TagUpdateManyWithoutCustomerNestedInput
    metrics?: CustomerMetricsUpdateOneWithoutCustomerNestedInput
    proposals?: ProposalUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutPropertiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    company?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    preferredCommunication?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    billingAddress?: AddressUncheckedUpdateOneWithoutCustomerNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutCustomerNestedInput
    interactions?: InteractionUncheckedUpdateManyWithoutCustomerNestedInput
    tags?: TagUncheckedUpdateManyWithoutCustomerNestedInput
    metrics?: CustomerMetricsUncheckedUpdateOneWithoutCustomerNestedInput
    proposals?: ProposalUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type ProjectUpsertWithWhereUniqueWithoutPropertyInput = {
    where: ProjectWhereUniqueInput
    update: XOR<ProjectUpdateWithoutPropertyInput, ProjectUncheckedUpdateWithoutPropertyInput>
    create: XOR<ProjectCreateWithoutPropertyInput, ProjectUncheckedCreateWithoutPropertyInput>
  }

  export type ProjectUpdateWithWhereUniqueWithoutPropertyInput = {
    where: ProjectWhereUniqueInput
    data: XOR<ProjectUpdateWithoutPropertyInput, ProjectUncheckedUpdateWithoutPropertyInput>
  }

  export type ProjectUpdateManyWithWhereWithoutPropertyInput = {
    where: ProjectScalarWhereInput
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyWithoutPropertyInput>
  }

  export type ProposalUpsertWithWhereUniqueWithoutPropertyInput = {
    where: ProposalWhereUniqueInput
    update: XOR<ProposalUpdateWithoutPropertyInput, ProposalUncheckedUpdateWithoutPropertyInput>
    create: XOR<ProposalCreateWithoutPropertyInput, ProposalUncheckedCreateWithoutPropertyInput>
  }

  export type ProposalUpdateWithWhereUniqueWithoutPropertyInput = {
    where: ProposalWhereUniqueInput
    data: XOR<ProposalUpdateWithoutPropertyInput, ProposalUncheckedUpdateWithoutPropertyInput>
  }

  export type ProposalUpdateManyWithWhereWithoutPropertyInput = {
    where: ProposalScalarWhereInput
    data: XOR<ProposalUpdateManyMutationInput, ProposalUncheckedUpdateManyWithoutPropertyInput>
  }

  export type PropertyCreateWithoutPhotosInput = {
    id?: string
    name: string
    type: string
    squareFootage: number
    bedrooms?: number | null
    bathrooms?: number | null
    yearBuilt?: number | null
    address?: AddressCreateNestedOneWithoutPropertyInput
    documents?: DocumentCreateNestedManyWithoutPropertyInput
    systems?: SystemInstallationCreateNestedManyWithoutPropertyInput
    serviceHistory?: ServiceRecordCreateNestedManyWithoutPropertyInput
    customer: CustomerCreateNestedOneWithoutPropertiesInput
    projects?: ProjectCreateNestedManyWithoutPropertyInput
    proposals?: ProposalCreateNestedManyWithoutPropertyInput
  }

  export type PropertyUncheckedCreateWithoutPhotosInput = {
    id?: string
    name: string
    type: string
    addressId?: string | null
    squareFootage: number
    bedrooms?: number | null
    bathrooms?: number | null
    yearBuilt?: number | null
    customerId: string
    documents?: DocumentUncheckedCreateNestedManyWithoutPropertyInput
    systems?: SystemInstallationUncheckedCreateNestedManyWithoutPropertyInput
    serviceHistory?: ServiceRecordUncheckedCreateNestedManyWithoutPropertyInput
    projects?: ProjectUncheckedCreateNestedManyWithoutPropertyInput
    proposals?: ProposalUncheckedCreateNestedManyWithoutPropertyInput
  }

  export type PropertyCreateOrConnectWithoutPhotosInput = {
    where: PropertyWhereUniqueInput
    create: XOR<PropertyCreateWithoutPhotosInput, PropertyUncheckedCreateWithoutPhotosInput>
  }

  export type PropertyUpsertWithoutPhotosInput = {
    update: XOR<PropertyUpdateWithoutPhotosInput, PropertyUncheckedUpdateWithoutPhotosInput>
    create: XOR<PropertyCreateWithoutPhotosInput, PropertyUncheckedCreateWithoutPhotosInput>
    where?: PropertyWhereInput
  }

  export type PropertyUpdateToOneWithWhereWithoutPhotosInput = {
    where?: PropertyWhereInput
    data: XOR<PropertyUpdateWithoutPhotosInput, PropertyUncheckedUpdateWithoutPhotosInput>
  }

  export type PropertyUpdateWithoutPhotosInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    squareFootage?: FloatFieldUpdateOperationsInput | number
    bedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    bathrooms?: NullableIntFieldUpdateOperationsInput | number | null
    yearBuilt?: NullableIntFieldUpdateOperationsInput | number | null
    address?: AddressUpdateOneWithoutPropertyNestedInput
    documents?: DocumentUpdateManyWithoutPropertyNestedInput
    systems?: SystemInstallationUpdateManyWithoutPropertyNestedInput
    serviceHistory?: ServiceRecordUpdateManyWithoutPropertyNestedInput
    customer?: CustomerUpdateOneRequiredWithoutPropertiesNestedInput
    projects?: ProjectUpdateManyWithoutPropertyNestedInput
    proposals?: ProposalUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateWithoutPhotosInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    addressId?: NullableStringFieldUpdateOperationsInput | string | null
    squareFootage?: FloatFieldUpdateOperationsInput | number
    bedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    bathrooms?: NullableIntFieldUpdateOperationsInput | number | null
    yearBuilt?: NullableIntFieldUpdateOperationsInput | number | null
    customerId?: StringFieldUpdateOperationsInput | string
    documents?: DocumentUncheckedUpdateManyWithoutPropertyNestedInput
    systems?: SystemInstallationUncheckedUpdateManyWithoutPropertyNestedInput
    serviceHistory?: ServiceRecordUncheckedUpdateManyWithoutPropertyNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutPropertyNestedInput
    proposals?: ProposalUncheckedUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyCreateWithoutDocumentsInput = {
    id?: string
    name: string
    type: string
    squareFootage: number
    bedrooms?: number | null
    bathrooms?: number | null
    yearBuilt?: number | null
    address?: AddressCreateNestedOneWithoutPropertyInput
    photos?: PhotoCreateNestedManyWithoutPropertyInput
    systems?: SystemInstallationCreateNestedManyWithoutPropertyInput
    serviceHistory?: ServiceRecordCreateNestedManyWithoutPropertyInput
    customer: CustomerCreateNestedOneWithoutPropertiesInput
    projects?: ProjectCreateNestedManyWithoutPropertyInput
    proposals?: ProposalCreateNestedManyWithoutPropertyInput
  }

  export type PropertyUncheckedCreateWithoutDocumentsInput = {
    id?: string
    name: string
    type: string
    addressId?: string | null
    squareFootage: number
    bedrooms?: number | null
    bathrooms?: number | null
    yearBuilt?: number | null
    customerId: string
    photos?: PhotoUncheckedCreateNestedManyWithoutPropertyInput
    systems?: SystemInstallationUncheckedCreateNestedManyWithoutPropertyInput
    serviceHistory?: ServiceRecordUncheckedCreateNestedManyWithoutPropertyInput
    projects?: ProjectUncheckedCreateNestedManyWithoutPropertyInput
    proposals?: ProposalUncheckedCreateNestedManyWithoutPropertyInput
  }

  export type PropertyCreateOrConnectWithoutDocumentsInput = {
    where: PropertyWhereUniqueInput
    create: XOR<PropertyCreateWithoutDocumentsInput, PropertyUncheckedCreateWithoutDocumentsInput>
  }

  export type ProjectCreateWithoutDocumentsInput = {
    id?: string
    name: string
    description: string
    status: string
    startDate: Date | string
    endDate?: Date | string | null
    property: PropertyCreateNestedOneWithoutProjectsInput
    teamMembers?: ProjectTeamMemberCreateNestedManyWithoutProjectInput
    milestones?: MilestoneCreateNestedManyWithoutProjectInput
    budget?: BudgetCreateNestedOneWithoutProjectInput
    customer: CustomerCreateNestedOneWithoutProjectsInput
    proposals?: ProposalCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutDocumentsInput = {
    id?: string
    name: string
    description: string
    status: string
    startDate: Date | string
    endDate?: Date | string | null
    propertyId: string
    customerId: string
    teamMembers?: ProjectTeamMemberUncheckedCreateNestedManyWithoutProjectInput
    milestones?: MilestoneUncheckedCreateNestedManyWithoutProjectInput
    budget?: BudgetUncheckedCreateNestedOneWithoutProjectInput
    proposals?: ProposalUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutDocumentsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutDocumentsInput, ProjectUncheckedCreateWithoutDocumentsInput>
  }

  export type PropertyUpsertWithoutDocumentsInput = {
    update: XOR<PropertyUpdateWithoutDocumentsInput, PropertyUncheckedUpdateWithoutDocumentsInput>
    create: XOR<PropertyCreateWithoutDocumentsInput, PropertyUncheckedCreateWithoutDocumentsInput>
    where?: PropertyWhereInput
  }

  export type PropertyUpdateToOneWithWhereWithoutDocumentsInput = {
    where?: PropertyWhereInput
    data: XOR<PropertyUpdateWithoutDocumentsInput, PropertyUncheckedUpdateWithoutDocumentsInput>
  }

  export type PropertyUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    squareFootage?: FloatFieldUpdateOperationsInput | number
    bedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    bathrooms?: NullableIntFieldUpdateOperationsInput | number | null
    yearBuilt?: NullableIntFieldUpdateOperationsInput | number | null
    address?: AddressUpdateOneWithoutPropertyNestedInput
    photos?: PhotoUpdateManyWithoutPropertyNestedInput
    systems?: SystemInstallationUpdateManyWithoutPropertyNestedInput
    serviceHistory?: ServiceRecordUpdateManyWithoutPropertyNestedInput
    customer?: CustomerUpdateOneRequiredWithoutPropertiesNestedInput
    projects?: ProjectUpdateManyWithoutPropertyNestedInput
    proposals?: ProposalUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    addressId?: NullableStringFieldUpdateOperationsInput | string | null
    squareFootage?: FloatFieldUpdateOperationsInput | number
    bedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    bathrooms?: NullableIntFieldUpdateOperationsInput | number | null
    yearBuilt?: NullableIntFieldUpdateOperationsInput | number | null
    customerId?: StringFieldUpdateOperationsInput | string
    photos?: PhotoUncheckedUpdateManyWithoutPropertyNestedInput
    systems?: SystemInstallationUncheckedUpdateManyWithoutPropertyNestedInput
    serviceHistory?: ServiceRecordUncheckedUpdateManyWithoutPropertyNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutPropertyNestedInput
    proposals?: ProposalUncheckedUpdateManyWithoutPropertyNestedInput
  }

  export type ProjectUpsertWithoutDocumentsInput = {
    update: XOR<ProjectUpdateWithoutDocumentsInput, ProjectUncheckedUpdateWithoutDocumentsInput>
    create: XOR<ProjectCreateWithoutDocumentsInput, ProjectUncheckedCreateWithoutDocumentsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutDocumentsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutDocumentsInput, ProjectUncheckedUpdateWithoutDocumentsInput>
  }

  export type ProjectUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    property?: PropertyUpdateOneRequiredWithoutProjectsNestedInput
    teamMembers?: ProjectTeamMemberUpdateManyWithoutProjectNestedInput
    milestones?: MilestoneUpdateManyWithoutProjectNestedInput
    budget?: BudgetUpdateOneWithoutProjectNestedInput
    customer?: CustomerUpdateOneRequiredWithoutProjectsNestedInput
    proposals?: ProposalUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    propertyId?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    teamMembers?: ProjectTeamMemberUncheckedUpdateManyWithoutProjectNestedInput
    milestones?: MilestoneUncheckedUpdateManyWithoutProjectNestedInput
    budget?: BudgetUncheckedUpdateOneWithoutProjectNestedInput
    proposals?: ProposalUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type PropertyCreateWithoutSystemsInput = {
    id?: string
    name: string
    type: string
    squareFootage: number
    bedrooms?: number | null
    bathrooms?: number | null
    yearBuilt?: number | null
    address?: AddressCreateNestedOneWithoutPropertyInput
    photos?: PhotoCreateNestedManyWithoutPropertyInput
    documents?: DocumentCreateNestedManyWithoutPropertyInput
    serviceHistory?: ServiceRecordCreateNestedManyWithoutPropertyInput
    customer: CustomerCreateNestedOneWithoutPropertiesInput
    projects?: ProjectCreateNestedManyWithoutPropertyInput
    proposals?: ProposalCreateNestedManyWithoutPropertyInput
  }

  export type PropertyUncheckedCreateWithoutSystemsInput = {
    id?: string
    name: string
    type: string
    addressId?: string | null
    squareFootage: number
    bedrooms?: number | null
    bathrooms?: number | null
    yearBuilt?: number | null
    customerId: string
    photos?: PhotoUncheckedCreateNestedManyWithoutPropertyInput
    documents?: DocumentUncheckedCreateNestedManyWithoutPropertyInput
    serviceHistory?: ServiceRecordUncheckedCreateNestedManyWithoutPropertyInput
    projects?: ProjectUncheckedCreateNestedManyWithoutPropertyInput
    proposals?: ProposalUncheckedCreateNestedManyWithoutPropertyInput
  }

  export type PropertyCreateOrConnectWithoutSystemsInput = {
    where: PropertyWhereUniqueInput
    create: XOR<PropertyCreateWithoutSystemsInput, PropertyUncheckedCreateWithoutSystemsInput>
  }

  export type PropertyUpsertWithoutSystemsInput = {
    update: XOR<PropertyUpdateWithoutSystemsInput, PropertyUncheckedUpdateWithoutSystemsInput>
    create: XOR<PropertyCreateWithoutSystemsInput, PropertyUncheckedCreateWithoutSystemsInput>
    where?: PropertyWhereInput
  }

  export type PropertyUpdateToOneWithWhereWithoutSystemsInput = {
    where?: PropertyWhereInput
    data: XOR<PropertyUpdateWithoutSystemsInput, PropertyUncheckedUpdateWithoutSystemsInput>
  }

  export type PropertyUpdateWithoutSystemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    squareFootage?: FloatFieldUpdateOperationsInput | number
    bedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    bathrooms?: NullableIntFieldUpdateOperationsInput | number | null
    yearBuilt?: NullableIntFieldUpdateOperationsInput | number | null
    address?: AddressUpdateOneWithoutPropertyNestedInput
    photos?: PhotoUpdateManyWithoutPropertyNestedInput
    documents?: DocumentUpdateManyWithoutPropertyNestedInput
    serviceHistory?: ServiceRecordUpdateManyWithoutPropertyNestedInput
    customer?: CustomerUpdateOneRequiredWithoutPropertiesNestedInput
    projects?: ProjectUpdateManyWithoutPropertyNestedInput
    proposals?: ProposalUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateWithoutSystemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    addressId?: NullableStringFieldUpdateOperationsInput | string | null
    squareFootage?: FloatFieldUpdateOperationsInput | number
    bedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    bathrooms?: NullableIntFieldUpdateOperationsInput | number | null
    yearBuilt?: NullableIntFieldUpdateOperationsInput | number | null
    customerId?: StringFieldUpdateOperationsInput | string
    photos?: PhotoUncheckedUpdateManyWithoutPropertyNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutPropertyNestedInput
    serviceHistory?: ServiceRecordUncheckedUpdateManyWithoutPropertyNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutPropertyNestedInput
    proposals?: ProposalUncheckedUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyCreateWithoutServiceHistoryInput = {
    id?: string
    name: string
    type: string
    squareFootage: number
    bedrooms?: number | null
    bathrooms?: number | null
    yearBuilt?: number | null
    address?: AddressCreateNestedOneWithoutPropertyInput
    photos?: PhotoCreateNestedManyWithoutPropertyInput
    documents?: DocumentCreateNestedManyWithoutPropertyInput
    systems?: SystemInstallationCreateNestedManyWithoutPropertyInput
    customer: CustomerCreateNestedOneWithoutPropertiesInput
    projects?: ProjectCreateNestedManyWithoutPropertyInput
    proposals?: ProposalCreateNestedManyWithoutPropertyInput
  }

  export type PropertyUncheckedCreateWithoutServiceHistoryInput = {
    id?: string
    name: string
    type: string
    addressId?: string | null
    squareFootage: number
    bedrooms?: number | null
    bathrooms?: number | null
    yearBuilt?: number | null
    customerId: string
    photos?: PhotoUncheckedCreateNestedManyWithoutPropertyInput
    documents?: DocumentUncheckedCreateNestedManyWithoutPropertyInput
    systems?: SystemInstallationUncheckedCreateNestedManyWithoutPropertyInput
    projects?: ProjectUncheckedCreateNestedManyWithoutPropertyInput
    proposals?: ProposalUncheckedCreateNestedManyWithoutPropertyInput
  }

  export type PropertyCreateOrConnectWithoutServiceHistoryInput = {
    where: PropertyWhereUniqueInput
    create: XOR<PropertyCreateWithoutServiceHistoryInput, PropertyUncheckedCreateWithoutServiceHistoryInput>
  }

  export type PropertyUpsertWithoutServiceHistoryInput = {
    update: XOR<PropertyUpdateWithoutServiceHistoryInput, PropertyUncheckedUpdateWithoutServiceHistoryInput>
    create: XOR<PropertyCreateWithoutServiceHistoryInput, PropertyUncheckedCreateWithoutServiceHistoryInput>
    where?: PropertyWhereInput
  }

  export type PropertyUpdateToOneWithWhereWithoutServiceHistoryInput = {
    where?: PropertyWhereInput
    data: XOR<PropertyUpdateWithoutServiceHistoryInput, PropertyUncheckedUpdateWithoutServiceHistoryInput>
  }

  export type PropertyUpdateWithoutServiceHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    squareFootage?: FloatFieldUpdateOperationsInput | number
    bedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    bathrooms?: NullableIntFieldUpdateOperationsInput | number | null
    yearBuilt?: NullableIntFieldUpdateOperationsInput | number | null
    address?: AddressUpdateOneWithoutPropertyNestedInput
    photos?: PhotoUpdateManyWithoutPropertyNestedInput
    documents?: DocumentUpdateManyWithoutPropertyNestedInput
    systems?: SystemInstallationUpdateManyWithoutPropertyNestedInput
    customer?: CustomerUpdateOneRequiredWithoutPropertiesNestedInput
    projects?: ProjectUpdateManyWithoutPropertyNestedInput
    proposals?: ProposalUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateWithoutServiceHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    addressId?: NullableStringFieldUpdateOperationsInput | string | null
    squareFootage?: FloatFieldUpdateOperationsInput | number
    bedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    bathrooms?: NullableIntFieldUpdateOperationsInput | number | null
    yearBuilt?: NullableIntFieldUpdateOperationsInput | number | null
    customerId?: StringFieldUpdateOperationsInput | string
    photos?: PhotoUncheckedUpdateManyWithoutPropertyNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutPropertyNestedInput
    systems?: SystemInstallationUncheckedUpdateManyWithoutPropertyNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutPropertyNestedInput
    proposals?: ProposalUncheckedUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyCreateWithoutProjectsInput = {
    id?: string
    name: string
    type: string
    squareFootage: number
    bedrooms?: number | null
    bathrooms?: number | null
    yearBuilt?: number | null
    address?: AddressCreateNestedOneWithoutPropertyInput
    photos?: PhotoCreateNestedManyWithoutPropertyInput
    documents?: DocumentCreateNestedManyWithoutPropertyInput
    systems?: SystemInstallationCreateNestedManyWithoutPropertyInput
    serviceHistory?: ServiceRecordCreateNestedManyWithoutPropertyInput
    customer: CustomerCreateNestedOneWithoutPropertiesInput
    proposals?: ProposalCreateNestedManyWithoutPropertyInput
  }

  export type PropertyUncheckedCreateWithoutProjectsInput = {
    id?: string
    name: string
    type: string
    addressId?: string | null
    squareFootage: number
    bedrooms?: number | null
    bathrooms?: number | null
    yearBuilt?: number | null
    customerId: string
    photos?: PhotoUncheckedCreateNestedManyWithoutPropertyInput
    documents?: DocumentUncheckedCreateNestedManyWithoutPropertyInput
    systems?: SystemInstallationUncheckedCreateNestedManyWithoutPropertyInput
    serviceHistory?: ServiceRecordUncheckedCreateNestedManyWithoutPropertyInput
    proposals?: ProposalUncheckedCreateNestedManyWithoutPropertyInput
  }

  export type PropertyCreateOrConnectWithoutProjectsInput = {
    where: PropertyWhereUniqueInput
    create: XOR<PropertyCreateWithoutProjectsInput, PropertyUncheckedCreateWithoutProjectsInput>
  }

  export type ProjectTeamMemberCreateWithoutProjectInput = {
    id?: string
    teamMember: TeamMemberCreateNestedOneWithoutProjectsInput
  }

  export type ProjectTeamMemberUncheckedCreateWithoutProjectInput = {
    id?: string
    teamMemberId: string
  }

  export type ProjectTeamMemberCreateOrConnectWithoutProjectInput = {
    where: ProjectTeamMemberWhereUniqueInput
    create: XOR<ProjectTeamMemberCreateWithoutProjectInput, ProjectTeamMemberUncheckedCreateWithoutProjectInput>
  }

  export type ProjectTeamMemberCreateManyProjectInputEnvelope = {
    data: ProjectTeamMemberCreateManyProjectInput | ProjectTeamMemberCreateManyProjectInput[]
  }

  export type MilestoneCreateWithoutProjectInput = {
    id?: string
    name: string
    description: string
    status: string
    dueDate: Date | string
    completedDate?: Date | string | null
    assignedTo?: string | null
  }

  export type MilestoneUncheckedCreateWithoutProjectInput = {
    id?: string
    name: string
    description: string
    status: string
    dueDate: Date | string
    completedDate?: Date | string | null
    assignedTo?: string | null
  }

  export type MilestoneCreateOrConnectWithoutProjectInput = {
    where: MilestoneWhereUniqueInput
    create: XOR<MilestoneCreateWithoutProjectInput, MilestoneUncheckedCreateWithoutProjectInput>
  }

  export type MilestoneCreateManyProjectInputEnvelope = {
    data: MilestoneCreateManyProjectInput | MilestoneCreateManyProjectInput[]
  }

  export type BudgetCreateWithoutProjectInput = {
    id?: string
    currency: string
    total: number
    spent: number
    remaining: number
    lineItems?: BudgetLineItemCreateNestedManyWithoutBudgetInput
  }

  export type BudgetUncheckedCreateWithoutProjectInput = {
    id?: string
    currency: string
    total: number
    spent: number
    remaining: number
    lineItems?: BudgetLineItemUncheckedCreateNestedManyWithoutBudgetInput
  }

  export type BudgetCreateOrConnectWithoutProjectInput = {
    where: BudgetWhereUniqueInput
    create: XOR<BudgetCreateWithoutProjectInput, BudgetUncheckedCreateWithoutProjectInput>
  }

  export type DocumentCreateWithoutProjectInput = {
    id?: string
    name: string
    url: string
    type: string
    uploadedAt?: Date | string
    uploadedBy: string
    property?: PropertyCreateNestedOneWithoutDocumentsInput
  }

  export type DocumentUncheckedCreateWithoutProjectInput = {
    id?: string
    name: string
    url: string
    type: string
    propertyId?: string | null
    uploadedAt?: Date | string
    uploadedBy: string
  }

  export type DocumentCreateOrConnectWithoutProjectInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutProjectInput, DocumentUncheckedCreateWithoutProjectInput>
  }

  export type DocumentCreateManyProjectInputEnvelope = {
    data: DocumentCreateManyProjectInput | DocumentCreateManyProjectInput[]
  }

  export type CustomerCreateWithoutProjectsInput = {
    id?: string
    type: string
    status: string
    firstName: string
    lastName: string
    company?: string | null
    email: string
    phone: string
    preferredCommunication: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    billingAddress?: AddressCreateNestedOneWithoutCustomerInput
    properties?: PropertyCreateNestedManyWithoutCustomerInput
    interactions?: InteractionCreateNestedManyWithoutCustomerInput
    tags?: TagCreateNestedManyWithoutCustomerInput
    metrics?: CustomerMetricsCreateNestedOneWithoutCustomerInput
    proposals?: ProposalCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutProjectsInput = {
    id?: string
    type: string
    status: string
    firstName: string
    lastName: string
    company?: string | null
    email: string
    phone: string
    preferredCommunication: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    billingAddress?: AddressUncheckedCreateNestedOneWithoutCustomerInput
    properties?: PropertyUncheckedCreateNestedManyWithoutCustomerInput
    interactions?: InteractionUncheckedCreateNestedManyWithoutCustomerInput
    tags?: TagUncheckedCreateNestedManyWithoutCustomerInput
    metrics?: CustomerMetricsUncheckedCreateNestedOneWithoutCustomerInput
    proposals?: ProposalUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutProjectsInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutProjectsInput, CustomerUncheckedCreateWithoutProjectsInput>
  }

  export type ProposalCreateWithoutProjectInput = {
    id?: string
    name: string
    description?: string | null
    status: string
    customerPersona: string
    voiceTranscript?: string | null
    aiSummary?: string | null
    totalAmount?: number
    validUntil?: Date | string | null
    isExistingCustomer?: boolean
    prospectName?: string | null
    prospectCompany?: string | null
    prospectEmail?: string | null
    prospectPhone?: string | null
    prospectStatus?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    customer?: CustomerCreateNestedOneWithoutProposalsInput
    property?: PropertyCreateNestedOneWithoutProposalsInput
    items?: ProposalItemCreateNestedManyWithoutProposalInput
  }

  export type ProposalUncheckedCreateWithoutProjectInput = {
    id?: string
    name: string
    description?: string | null
    status: string
    customerPersona: string
    voiceTranscript?: string | null
    aiSummary?: string | null
    totalAmount?: number
    validUntil?: Date | string | null
    isExistingCustomer?: boolean
    customerId?: string | null
    prospectName?: string | null
    prospectCompany?: string | null
    prospectEmail?: string | null
    prospectPhone?: string | null
    prospectStatus?: string | null
    propertyId?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: ProposalItemUncheckedCreateNestedManyWithoutProposalInput
  }

  export type ProposalCreateOrConnectWithoutProjectInput = {
    where: ProposalWhereUniqueInput
    create: XOR<ProposalCreateWithoutProjectInput, ProposalUncheckedCreateWithoutProjectInput>
  }

  export type ProposalCreateManyProjectInputEnvelope = {
    data: ProposalCreateManyProjectInput | ProposalCreateManyProjectInput[]
  }

  export type PropertyUpsertWithoutProjectsInput = {
    update: XOR<PropertyUpdateWithoutProjectsInput, PropertyUncheckedUpdateWithoutProjectsInput>
    create: XOR<PropertyCreateWithoutProjectsInput, PropertyUncheckedCreateWithoutProjectsInput>
    where?: PropertyWhereInput
  }

  export type PropertyUpdateToOneWithWhereWithoutProjectsInput = {
    where?: PropertyWhereInput
    data: XOR<PropertyUpdateWithoutProjectsInput, PropertyUncheckedUpdateWithoutProjectsInput>
  }

  export type PropertyUpdateWithoutProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    squareFootage?: FloatFieldUpdateOperationsInput | number
    bedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    bathrooms?: NullableIntFieldUpdateOperationsInput | number | null
    yearBuilt?: NullableIntFieldUpdateOperationsInput | number | null
    address?: AddressUpdateOneWithoutPropertyNestedInput
    photos?: PhotoUpdateManyWithoutPropertyNestedInput
    documents?: DocumentUpdateManyWithoutPropertyNestedInput
    systems?: SystemInstallationUpdateManyWithoutPropertyNestedInput
    serviceHistory?: ServiceRecordUpdateManyWithoutPropertyNestedInput
    customer?: CustomerUpdateOneRequiredWithoutPropertiesNestedInput
    proposals?: ProposalUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateWithoutProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    addressId?: NullableStringFieldUpdateOperationsInput | string | null
    squareFootage?: FloatFieldUpdateOperationsInput | number
    bedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    bathrooms?: NullableIntFieldUpdateOperationsInput | number | null
    yearBuilt?: NullableIntFieldUpdateOperationsInput | number | null
    customerId?: StringFieldUpdateOperationsInput | string
    photos?: PhotoUncheckedUpdateManyWithoutPropertyNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutPropertyNestedInput
    systems?: SystemInstallationUncheckedUpdateManyWithoutPropertyNestedInput
    serviceHistory?: ServiceRecordUncheckedUpdateManyWithoutPropertyNestedInput
    proposals?: ProposalUncheckedUpdateManyWithoutPropertyNestedInput
  }

  export type ProjectTeamMemberUpsertWithWhereUniqueWithoutProjectInput = {
    where: ProjectTeamMemberWhereUniqueInput
    update: XOR<ProjectTeamMemberUpdateWithoutProjectInput, ProjectTeamMemberUncheckedUpdateWithoutProjectInput>
    create: XOR<ProjectTeamMemberCreateWithoutProjectInput, ProjectTeamMemberUncheckedCreateWithoutProjectInput>
  }

  export type ProjectTeamMemberUpdateWithWhereUniqueWithoutProjectInput = {
    where: ProjectTeamMemberWhereUniqueInput
    data: XOR<ProjectTeamMemberUpdateWithoutProjectInput, ProjectTeamMemberUncheckedUpdateWithoutProjectInput>
  }

  export type ProjectTeamMemberUpdateManyWithWhereWithoutProjectInput = {
    where: ProjectTeamMemberScalarWhereInput
    data: XOR<ProjectTeamMemberUpdateManyMutationInput, ProjectTeamMemberUncheckedUpdateManyWithoutProjectInput>
  }

  export type ProjectTeamMemberScalarWhereInput = {
    AND?: ProjectTeamMemberScalarWhereInput | ProjectTeamMemberScalarWhereInput[]
    OR?: ProjectTeamMemberScalarWhereInput[]
    NOT?: ProjectTeamMemberScalarWhereInput | ProjectTeamMemberScalarWhereInput[]
    id?: StringFilter<"ProjectTeamMember"> | string
    projectId?: StringFilter<"ProjectTeamMember"> | string
    teamMemberId?: StringFilter<"ProjectTeamMember"> | string
  }

  export type MilestoneUpsertWithWhereUniqueWithoutProjectInput = {
    where: MilestoneWhereUniqueInput
    update: XOR<MilestoneUpdateWithoutProjectInput, MilestoneUncheckedUpdateWithoutProjectInput>
    create: XOR<MilestoneCreateWithoutProjectInput, MilestoneUncheckedCreateWithoutProjectInput>
  }

  export type MilestoneUpdateWithWhereUniqueWithoutProjectInput = {
    where: MilestoneWhereUniqueInput
    data: XOR<MilestoneUpdateWithoutProjectInput, MilestoneUncheckedUpdateWithoutProjectInput>
  }

  export type MilestoneUpdateManyWithWhereWithoutProjectInput = {
    where: MilestoneScalarWhereInput
    data: XOR<MilestoneUpdateManyMutationInput, MilestoneUncheckedUpdateManyWithoutProjectInput>
  }

  export type MilestoneScalarWhereInput = {
    AND?: MilestoneScalarWhereInput | MilestoneScalarWhereInput[]
    OR?: MilestoneScalarWhereInput[]
    NOT?: MilestoneScalarWhereInput | MilestoneScalarWhereInput[]
    id?: StringFilter<"Milestone"> | string
    name?: StringFilter<"Milestone"> | string
    description?: StringFilter<"Milestone"> | string
    status?: StringFilter<"Milestone"> | string
    dueDate?: DateTimeFilter<"Milestone"> | Date | string
    completedDate?: DateTimeNullableFilter<"Milestone"> | Date | string | null
    assignedTo?: StringNullableFilter<"Milestone"> | string | null
    projectId?: StringFilter<"Milestone"> | string
  }

  export type BudgetUpsertWithoutProjectInput = {
    update: XOR<BudgetUpdateWithoutProjectInput, BudgetUncheckedUpdateWithoutProjectInput>
    create: XOR<BudgetCreateWithoutProjectInput, BudgetUncheckedCreateWithoutProjectInput>
    where?: BudgetWhereInput
  }

  export type BudgetUpdateToOneWithWhereWithoutProjectInput = {
    where?: BudgetWhereInput
    data: XOR<BudgetUpdateWithoutProjectInput, BudgetUncheckedUpdateWithoutProjectInput>
  }

  export type BudgetUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    total?: FloatFieldUpdateOperationsInput | number
    spent?: FloatFieldUpdateOperationsInput | number
    remaining?: FloatFieldUpdateOperationsInput | number
    lineItems?: BudgetLineItemUpdateManyWithoutBudgetNestedInput
  }

  export type BudgetUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    total?: FloatFieldUpdateOperationsInput | number
    spent?: FloatFieldUpdateOperationsInput | number
    remaining?: FloatFieldUpdateOperationsInput | number
    lineItems?: BudgetLineItemUncheckedUpdateManyWithoutBudgetNestedInput
  }

  export type DocumentUpsertWithWhereUniqueWithoutProjectInput = {
    where: DocumentWhereUniqueInput
    update: XOR<DocumentUpdateWithoutProjectInput, DocumentUncheckedUpdateWithoutProjectInput>
    create: XOR<DocumentCreateWithoutProjectInput, DocumentUncheckedCreateWithoutProjectInput>
  }

  export type DocumentUpdateWithWhereUniqueWithoutProjectInput = {
    where: DocumentWhereUniqueInput
    data: XOR<DocumentUpdateWithoutProjectInput, DocumentUncheckedUpdateWithoutProjectInput>
  }

  export type DocumentUpdateManyWithWhereWithoutProjectInput = {
    where: DocumentScalarWhereInput
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyWithoutProjectInput>
  }

  export type CustomerUpsertWithoutProjectsInput = {
    update: XOR<CustomerUpdateWithoutProjectsInput, CustomerUncheckedUpdateWithoutProjectsInput>
    create: XOR<CustomerCreateWithoutProjectsInput, CustomerUncheckedCreateWithoutProjectsInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutProjectsInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutProjectsInput, CustomerUncheckedUpdateWithoutProjectsInput>
  }

  export type CustomerUpdateWithoutProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    company?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    preferredCommunication?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    billingAddress?: AddressUpdateOneWithoutCustomerNestedInput
    properties?: PropertyUpdateManyWithoutCustomerNestedInput
    interactions?: InteractionUpdateManyWithoutCustomerNestedInput
    tags?: TagUpdateManyWithoutCustomerNestedInput
    metrics?: CustomerMetricsUpdateOneWithoutCustomerNestedInput
    proposals?: ProposalUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    company?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    preferredCommunication?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    billingAddress?: AddressUncheckedUpdateOneWithoutCustomerNestedInput
    properties?: PropertyUncheckedUpdateManyWithoutCustomerNestedInput
    interactions?: InteractionUncheckedUpdateManyWithoutCustomerNestedInput
    tags?: TagUncheckedUpdateManyWithoutCustomerNestedInput
    metrics?: CustomerMetricsUncheckedUpdateOneWithoutCustomerNestedInput
    proposals?: ProposalUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type ProposalUpsertWithWhereUniqueWithoutProjectInput = {
    where: ProposalWhereUniqueInput
    update: XOR<ProposalUpdateWithoutProjectInput, ProposalUncheckedUpdateWithoutProjectInput>
    create: XOR<ProposalCreateWithoutProjectInput, ProposalUncheckedCreateWithoutProjectInput>
  }

  export type ProposalUpdateWithWhereUniqueWithoutProjectInput = {
    where: ProposalWhereUniqueInput
    data: XOR<ProposalUpdateWithoutProjectInput, ProposalUncheckedUpdateWithoutProjectInput>
  }

  export type ProposalUpdateManyWithWhereWithoutProjectInput = {
    where: ProposalScalarWhereInput
    data: XOR<ProposalUpdateManyMutationInput, ProposalUncheckedUpdateManyWithoutProjectInput>
  }

  export type ProjectCreateWithoutTeamMembersInput = {
    id?: string
    name: string
    description: string
    status: string
    startDate: Date | string
    endDate?: Date | string | null
    property: PropertyCreateNestedOneWithoutProjectsInput
    milestones?: MilestoneCreateNestedManyWithoutProjectInput
    budget?: BudgetCreateNestedOneWithoutProjectInput
    documents?: DocumentCreateNestedManyWithoutProjectInput
    customer: CustomerCreateNestedOneWithoutProjectsInput
    proposals?: ProposalCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutTeamMembersInput = {
    id?: string
    name: string
    description: string
    status: string
    startDate: Date | string
    endDate?: Date | string | null
    propertyId: string
    customerId: string
    milestones?: MilestoneUncheckedCreateNestedManyWithoutProjectInput
    budget?: BudgetUncheckedCreateNestedOneWithoutProjectInput
    documents?: DocumentUncheckedCreateNestedManyWithoutProjectInput
    proposals?: ProposalUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutTeamMembersInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutTeamMembersInput, ProjectUncheckedCreateWithoutTeamMembersInput>
  }

  export type TeamMemberCreateWithoutProjectsInput = {
    id?: string
    name: string
    role: string
    email: string
    phone: string
  }

  export type TeamMemberUncheckedCreateWithoutProjectsInput = {
    id?: string
    name: string
    role: string
    email: string
    phone: string
  }

  export type TeamMemberCreateOrConnectWithoutProjectsInput = {
    where: TeamMemberWhereUniqueInput
    create: XOR<TeamMemberCreateWithoutProjectsInput, TeamMemberUncheckedCreateWithoutProjectsInput>
  }

  export type ProjectUpsertWithoutTeamMembersInput = {
    update: XOR<ProjectUpdateWithoutTeamMembersInput, ProjectUncheckedUpdateWithoutTeamMembersInput>
    create: XOR<ProjectCreateWithoutTeamMembersInput, ProjectUncheckedCreateWithoutTeamMembersInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutTeamMembersInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutTeamMembersInput, ProjectUncheckedUpdateWithoutTeamMembersInput>
  }

  export type ProjectUpdateWithoutTeamMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    property?: PropertyUpdateOneRequiredWithoutProjectsNestedInput
    milestones?: MilestoneUpdateManyWithoutProjectNestedInput
    budget?: BudgetUpdateOneWithoutProjectNestedInput
    documents?: DocumentUpdateManyWithoutProjectNestedInput
    customer?: CustomerUpdateOneRequiredWithoutProjectsNestedInput
    proposals?: ProposalUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutTeamMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    propertyId?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    milestones?: MilestoneUncheckedUpdateManyWithoutProjectNestedInput
    budget?: BudgetUncheckedUpdateOneWithoutProjectNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutProjectNestedInput
    proposals?: ProposalUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type TeamMemberUpsertWithoutProjectsInput = {
    update: XOR<TeamMemberUpdateWithoutProjectsInput, TeamMemberUncheckedUpdateWithoutProjectsInput>
    create: XOR<TeamMemberCreateWithoutProjectsInput, TeamMemberUncheckedCreateWithoutProjectsInput>
    where?: TeamMemberWhereInput
  }

  export type TeamMemberUpdateToOneWithWhereWithoutProjectsInput = {
    where?: TeamMemberWhereInput
    data: XOR<TeamMemberUpdateWithoutProjectsInput, TeamMemberUncheckedUpdateWithoutProjectsInput>
  }

  export type TeamMemberUpdateWithoutProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
  }

  export type TeamMemberUncheckedUpdateWithoutProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectTeamMemberCreateWithoutTeamMemberInput = {
    id?: string
    project: ProjectCreateNestedOneWithoutTeamMembersInput
  }

  export type ProjectTeamMemberUncheckedCreateWithoutTeamMemberInput = {
    id?: string
    projectId: string
  }

  export type ProjectTeamMemberCreateOrConnectWithoutTeamMemberInput = {
    where: ProjectTeamMemberWhereUniqueInput
    create: XOR<ProjectTeamMemberCreateWithoutTeamMemberInput, ProjectTeamMemberUncheckedCreateWithoutTeamMemberInput>
  }

  export type ProjectTeamMemberCreateManyTeamMemberInputEnvelope = {
    data: ProjectTeamMemberCreateManyTeamMemberInput | ProjectTeamMemberCreateManyTeamMemberInput[]
  }

  export type ProjectTeamMemberUpsertWithWhereUniqueWithoutTeamMemberInput = {
    where: ProjectTeamMemberWhereUniqueInput
    update: XOR<ProjectTeamMemberUpdateWithoutTeamMemberInput, ProjectTeamMemberUncheckedUpdateWithoutTeamMemberInput>
    create: XOR<ProjectTeamMemberCreateWithoutTeamMemberInput, ProjectTeamMemberUncheckedCreateWithoutTeamMemberInput>
  }

  export type ProjectTeamMemberUpdateWithWhereUniqueWithoutTeamMemberInput = {
    where: ProjectTeamMemberWhereUniqueInput
    data: XOR<ProjectTeamMemberUpdateWithoutTeamMemberInput, ProjectTeamMemberUncheckedUpdateWithoutTeamMemberInput>
  }

  export type ProjectTeamMemberUpdateManyWithWhereWithoutTeamMemberInput = {
    where: ProjectTeamMemberScalarWhereInput
    data: XOR<ProjectTeamMemberUpdateManyMutationInput, ProjectTeamMemberUncheckedUpdateManyWithoutTeamMemberInput>
  }

  export type ProjectCreateWithoutMilestonesInput = {
    id?: string
    name: string
    description: string
    status: string
    startDate: Date | string
    endDate?: Date | string | null
    property: PropertyCreateNestedOneWithoutProjectsInput
    teamMembers?: ProjectTeamMemberCreateNestedManyWithoutProjectInput
    budget?: BudgetCreateNestedOneWithoutProjectInput
    documents?: DocumentCreateNestedManyWithoutProjectInput
    customer: CustomerCreateNestedOneWithoutProjectsInput
    proposals?: ProposalCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutMilestonesInput = {
    id?: string
    name: string
    description: string
    status: string
    startDate: Date | string
    endDate?: Date | string | null
    propertyId: string
    customerId: string
    teamMembers?: ProjectTeamMemberUncheckedCreateNestedManyWithoutProjectInput
    budget?: BudgetUncheckedCreateNestedOneWithoutProjectInput
    documents?: DocumentUncheckedCreateNestedManyWithoutProjectInput
    proposals?: ProposalUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutMilestonesInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutMilestonesInput, ProjectUncheckedCreateWithoutMilestonesInput>
  }

  export type ProjectUpsertWithoutMilestonesInput = {
    update: XOR<ProjectUpdateWithoutMilestonesInput, ProjectUncheckedUpdateWithoutMilestonesInput>
    create: XOR<ProjectCreateWithoutMilestonesInput, ProjectUncheckedCreateWithoutMilestonesInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutMilestonesInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutMilestonesInput, ProjectUncheckedUpdateWithoutMilestonesInput>
  }

  export type ProjectUpdateWithoutMilestonesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    property?: PropertyUpdateOneRequiredWithoutProjectsNestedInput
    teamMembers?: ProjectTeamMemberUpdateManyWithoutProjectNestedInput
    budget?: BudgetUpdateOneWithoutProjectNestedInput
    documents?: DocumentUpdateManyWithoutProjectNestedInput
    customer?: CustomerUpdateOneRequiredWithoutProjectsNestedInput
    proposals?: ProposalUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutMilestonesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    propertyId?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    teamMembers?: ProjectTeamMemberUncheckedUpdateManyWithoutProjectNestedInput
    budget?: BudgetUncheckedUpdateOneWithoutProjectNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutProjectNestedInput
    proposals?: ProposalUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type BudgetLineItemCreateWithoutBudgetInput = {
    id?: string
    description: string
    amount: number
    category: string
  }

  export type BudgetLineItemUncheckedCreateWithoutBudgetInput = {
    id?: string
    description: string
    amount: number
    category: string
  }

  export type BudgetLineItemCreateOrConnectWithoutBudgetInput = {
    where: BudgetLineItemWhereUniqueInput
    create: XOR<BudgetLineItemCreateWithoutBudgetInput, BudgetLineItemUncheckedCreateWithoutBudgetInput>
  }

  export type BudgetLineItemCreateManyBudgetInputEnvelope = {
    data: BudgetLineItemCreateManyBudgetInput | BudgetLineItemCreateManyBudgetInput[]
  }

  export type ProjectCreateWithoutBudgetInput = {
    id?: string
    name: string
    description: string
    status: string
    startDate: Date | string
    endDate?: Date | string | null
    property: PropertyCreateNestedOneWithoutProjectsInput
    teamMembers?: ProjectTeamMemberCreateNestedManyWithoutProjectInput
    milestones?: MilestoneCreateNestedManyWithoutProjectInput
    documents?: DocumentCreateNestedManyWithoutProjectInput
    customer: CustomerCreateNestedOneWithoutProjectsInput
    proposals?: ProposalCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutBudgetInput = {
    id?: string
    name: string
    description: string
    status: string
    startDate: Date | string
    endDate?: Date | string | null
    propertyId: string
    customerId: string
    teamMembers?: ProjectTeamMemberUncheckedCreateNestedManyWithoutProjectInput
    milestones?: MilestoneUncheckedCreateNestedManyWithoutProjectInput
    documents?: DocumentUncheckedCreateNestedManyWithoutProjectInput
    proposals?: ProposalUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutBudgetInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutBudgetInput, ProjectUncheckedCreateWithoutBudgetInput>
  }

  export type BudgetLineItemUpsertWithWhereUniqueWithoutBudgetInput = {
    where: BudgetLineItemWhereUniqueInput
    update: XOR<BudgetLineItemUpdateWithoutBudgetInput, BudgetLineItemUncheckedUpdateWithoutBudgetInput>
    create: XOR<BudgetLineItemCreateWithoutBudgetInput, BudgetLineItemUncheckedCreateWithoutBudgetInput>
  }

  export type BudgetLineItemUpdateWithWhereUniqueWithoutBudgetInput = {
    where: BudgetLineItemWhereUniqueInput
    data: XOR<BudgetLineItemUpdateWithoutBudgetInput, BudgetLineItemUncheckedUpdateWithoutBudgetInput>
  }

  export type BudgetLineItemUpdateManyWithWhereWithoutBudgetInput = {
    where: BudgetLineItemScalarWhereInput
    data: XOR<BudgetLineItemUpdateManyMutationInput, BudgetLineItemUncheckedUpdateManyWithoutBudgetInput>
  }

  export type BudgetLineItemScalarWhereInput = {
    AND?: BudgetLineItemScalarWhereInput | BudgetLineItemScalarWhereInput[]
    OR?: BudgetLineItemScalarWhereInput[]
    NOT?: BudgetLineItemScalarWhereInput | BudgetLineItemScalarWhereInput[]
    id?: StringFilter<"BudgetLineItem"> | string
    description?: StringFilter<"BudgetLineItem"> | string
    amount?: FloatFilter<"BudgetLineItem"> | number
    category?: StringFilter<"BudgetLineItem"> | string
    budgetId?: StringFilter<"BudgetLineItem"> | string
  }

  export type ProjectUpsertWithoutBudgetInput = {
    update: XOR<ProjectUpdateWithoutBudgetInput, ProjectUncheckedUpdateWithoutBudgetInput>
    create: XOR<ProjectCreateWithoutBudgetInput, ProjectUncheckedCreateWithoutBudgetInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutBudgetInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutBudgetInput, ProjectUncheckedUpdateWithoutBudgetInput>
  }

  export type ProjectUpdateWithoutBudgetInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    property?: PropertyUpdateOneRequiredWithoutProjectsNestedInput
    teamMembers?: ProjectTeamMemberUpdateManyWithoutProjectNestedInput
    milestones?: MilestoneUpdateManyWithoutProjectNestedInput
    documents?: DocumentUpdateManyWithoutProjectNestedInput
    customer?: CustomerUpdateOneRequiredWithoutProjectsNestedInput
    proposals?: ProposalUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutBudgetInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    propertyId?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    teamMembers?: ProjectTeamMemberUncheckedUpdateManyWithoutProjectNestedInput
    milestones?: MilestoneUncheckedUpdateManyWithoutProjectNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutProjectNestedInput
    proposals?: ProposalUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type BudgetCreateWithoutLineItemsInput = {
    id?: string
    currency: string
    total: number
    spent: number
    remaining: number
    project: ProjectCreateNestedOneWithoutBudgetInput
  }

  export type BudgetUncheckedCreateWithoutLineItemsInput = {
    id?: string
    currency: string
    total: number
    spent: number
    remaining: number
    projectId: string
  }

  export type BudgetCreateOrConnectWithoutLineItemsInput = {
    where: BudgetWhereUniqueInput
    create: XOR<BudgetCreateWithoutLineItemsInput, BudgetUncheckedCreateWithoutLineItemsInput>
  }

  export type BudgetUpsertWithoutLineItemsInput = {
    update: XOR<BudgetUpdateWithoutLineItemsInput, BudgetUncheckedUpdateWithoutLineItemsInput>
    create: XOR<BudgetCreateWithoutLineItemsInput, BudgetUncheckedCreateWithoutLineItemsInput>
    where?: BudgetWhereInput
  }

  export type BudgetUpdateToOneWithWhereWithoutLineItemsInput = {
    where?: BudgetWhereInput
    data: XOR<BudgetUpdateWithoutLineItemsInput, BudgetUncheckedUpdateWithoutLineItemsInput>
  }

  export type BudgetUpdateWithoutLineItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    total?: FloatFieldUpdateOperationsInput | number
    spent?: FloatFieldUpdateOperationsInput | number
    remaining?: FloatFieldUpdateOperationsInput | number
    project?: ProjectUpdateOneRequiredWithoutBudgetNestedInput
  }

  export type BudgetUncheckedUpdateWithoutLineItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    total?: FloatFieldUpdateOperationsInput | number
    spent?: FloatFieldUpdateOperationsInput | number
    remaining?: FloatFieldUpdateOperationsInput | number
    projectId?: StringFieldUpdateOperationsInput | string
  }

  export type CustomerCreateWithoutInteractionsInput = {
    id?: string
    type: string
    status: string
    firstName: string
    lastName: string
    company?: string | null
    email: string
    phone: string
    preferredCommunication: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    billingAddress?: AddressCreateNestedOneWithoutCustomerInput
    properties?: PropertyCreateNestedManyWithoutCustomerInput
    projects?: ProjectCreateNestedManyWithoutCustomerInput
    tags?: TagCreateNestedManyWithoutCustomerInput
    metrics?: CustomerMetricsCreateNestedOneWithoutCustomerInput
    proposals?: ProposalCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutInteractionsInput = {
    id?: string
    type: string
    status: string
    firstName: string
    lastName: string
    company?: string | null
    email: string
    phone: string
    preferredCommunication: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    billingAddress?: AddressUncheckedCreateNestedOneWithoutCustomerInput
    properties?: PropertyUncheckedCreateNestedManyWithoutCustomerInput
    projects?: ProjectUncheckedCreateNestedManyWithoutCustomerInput
    tags?: TagUncheckedCreateNestedManyWithoutCustomerInput
    metrics?: CustomerMetricsUncheckedCreateNestedOneWithoutCustomerInput
    proposals?: ProposalUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutInteractionsInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutInteractionsInput, CustomerUncheckedCreateWithoutInteractionsInput>
  }

  export type CustomerUpsertWithoutInteractionsInput = {
    update: XOR<CustomerUpdateWithoutInteractionsInput, CustomerUncheckedUpdateWithoutInteractionsInput>
    create: XOR<CustomerCreateWithoutInteractionsInput, CustomerUncheckedCreateWithoutInteractionsInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutInteractionsInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutInteractionsInput, CustomerUncheckedUpdateWithoutInteractionsInput>
  }

  export type CustomerUpdateWithoutInteractionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    company?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    preferredCommunication?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    billingAddress?: AddressUpdateOneWithoutCustomerNestedInput
    properties?: PropertyUpdateManyWithoutCustomerNestedInput
    projects?: ProjectUpdateManyWithoutCustomerNestedInput
    tags?: TagUpdateManyWithoutCustomerNestedInput
    metrics?: CustomerMetricsUpdateOneWithoutCustomerNestedInput
    proposals?: ProposalUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutInteractionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    company?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    preferredCommunication?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    billingAddress?: AddressUncheckedUpdateOneWithoutCustomerNestedInput
    properties?: PropertyUncheckedUpdateManyWithoutCustomerNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutCustomerNestedInput
    tags?: TagUncheckedUpdateManyWithoutCustomerNestedInput
    metrics?: CustomerMetricsUncheckedUpdateOneWithoutCustomerNestedInput
    proposals?: ProposalUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerCreateWithoutMetricsInput = {
    id?: string
    type: string
    status: string
    firstName: string
    lastName: string
    company?: string | null
    email: string
    phone: string
    preferredCommunication: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    billingAddress?: AddressCreateNestedOneWithoutCustomerInput
    properties?: PropertyCreateNestedManyWithoutCustomerInput
    projects?: ProjectCreateNestedManyWithoutCustomerInput
    interactions?: InteractionCreateNestedManyWithoutCustomerInput
    tags?: TagCreateNestedManyWithoutCustomerInput
    proposals?: ProposalCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutMetricsInput = {
    id?: string
    type: string
    status: string
    firstName: string
    lastName: string
    company?: string | null
    email: string
    phone: string
    preferredCommunication: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    billingAddress?: AddressUncheckedCreateNestedOneWithoutCustomerInput
    properties?: PropertyUncheckedCreateNestedManyWithoutCustomerInput
    projects?: ProjectUncheckedCreateNestedManyWithoutCustomerInput
    interactions?: InteractionUncheckedCreateNestedManyWithoutCustomerInput
    tags?: TagUncheckedCreateNestedManyWithoutCustomerInput
    proposals?: ProposalUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutMetricsInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutMetricsInput, CustomerUncheckedCreateWithoutMetricsInput>
  }

  export type CustomerUpsertWithoutMetricsInput = {
    update: XOR<CustomerUpdateWithoutMetricsInput, CustomerUncheckedUpdateWithoutMetricsInput>
    create: XOR<CustomerCreateWithoutMetricsInput, CustomerUncheckedCreateWithoutMetricsInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutMetricsInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutMetricsInput, CustomerUncheckedUpdateWithoutMetricsInput>
  }

  export type CustomerUpdateWithoutMetricsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    company?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    preferredCommunication?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    billingAddress?: AddressUpdateOneWithoutCustomerNestedInput
    properties?: PropertyUpdateManyWithoutCustomerNestedInput
    projects?: ProjectUpdateManyWithoutCustomerNestedInput
    interactions?: InteractionUpdateManyWithoutCustomerNestedInput
    tags?: TagUpdateManyWithoutCustomerNestedInput
    proposals?: ProposalUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutMetricsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    company?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    preferredCommunication?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    billingAddress?: AddressUncheckedUpdateOneWithoutCustomerNestedInput
    properties?: PropertyUncheckedUpdateManyWithoutCustomerNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutCustomerNestedInput
    interactions?: InteractionUncheckedUpdateManyWithoutCustomerNestedInput
    tags?: TagUncheckedUpdateManyWithoutCustomerNestedInput
    proposals?: ProposalUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerCreateWithoutProposalsInput = {
    id?: string
    type: string
    status: string
    firstName: string
    lastName: string
    company?: string | null
    email: string
    phone: string
    preferredCommunication: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    billingAddress?: AddressCreateNestedOneWithoutCustomerInput
    properties?: PropertyCreateNestedManyWithoutCustomerInput
    projects?: ProjectCreateNestedManyWithoutCustomerInput
    interactions?: InteractionCreateNestedManyWithoutCustomerInput
    tags?: TagCreateNestedManyWithoutCustomerInput
    metrics?: CustomerMetricsCreateNestedOneWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutProposalsInput = {
    id?: string
    type: string
    status: string
    firstName: string
    lastName: string
    company?: string | null
    email: string
    phone: string
    preferredCommunication: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    billingAddress?: AddressUncheckedCreateNestedOneWithoutCustomerInput
    properties?: PropertyUncheckedCreateNestedManyWithoutCustomerInput
    projects?: ProjectUncheckedCreateNestedManyWithoutCustomerInput
    interactions?: InteractionUncheckedCreateNestedManyWithoutCustomerInput
    tags?: TagUncheckedCreateNestedManyWithoutCustomerInput
    metrics?: CustomerMetricsUncheckedCreateNestedOneWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutProposalsInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutProposalsInput, CustomerUncheckedCreateWithoutProposalsInput>
  }

  export type PropertyCreateWithoutProposalsInput = {
    id?: string
    name: string
    type: string
    squareFootage: number
    bedrooms?: number | null
    bathrooms?: number | null
    yearBuilt?: number | null
    address?: AddressCreateNestedOneWithoutPropertyInput
    photos?: PhotoCreateNestedManyWithoutPropertyInput
    documents?: DocumentCreateNestedManyWithoutPropertyInput
    systems?: SystemInstallationCreateNestedManyWithoutPropertyInput
    serviceHistory?: ServiceRecordCreateNestedManyWithoutPropertyInput
    customer: CustomerCreateNestedOneWithoutPropertiesInput
    projects?: ProjectCreateNestedManyWithoutPropertyInput
  }

  export type PropertyUncheckedCreateWithoutProposalsInput = {
    id?: string
    name: string
    type: string
    addressId?: string | null
    squareFootage: number
    bedrooms?: number | null
    bathrooms?: number | null
    yearBuilt?: number | null
    customerId: string
    photos?: PhotoUncheckedCreateNestedManyWithoutPropertyInput
    documents?: DocumentUncheckedCreateNestedManyWithoutPropertyInput
    systems?: SystemInstallationUncheckedCreateNestedManyWithoutPropertyInput
    serviceHistory?: ServiceRecordUncheckedCreateNestedManyWithoutPropertyInput
    projects?: ProjectUncheckedCreateNestedManyWithoutPropertyInput
  }

  export type PropertyCreateOrConnectWithoutProposalsInput = {
    where: PropertyWhereUniqueInput
    create: XOR<PropertyCreateWithoutProposalsInput, PropertyUncheckedCreateWithoutProposalsInput>
  }

  export type ProjectCreateWithoutProposalsInput = {
    id?: string
    name: string
    description: string
    status: string
    startDate: Date | string
    endDate?: Date | string | null
    property: PropertyCreateNestedOneWithoutProjectsInput
    teamMembers?: ProjectTeamMemberCreateNestedManyWithoutProjectInput
    milestones?: MilestoneCreateNestedManyWithoutProjectInput
    budget?: BudgetCreateNestedOneWithoutProjectInput
    documents?: DocumentCreateNestedManyWithoutProjectInput
    customer: CustomerCreateNestedOneWithoutProjectsInput
  }

  export type ProjectUncheckedCreateWithoutProposalsInput = {
    id?: string
    name: string
    description: string
    status: string
    startDate: Date | string
    endDate?: Date | string | null
    propertyId: string
    customerId: string
    teamMembers?: ProjectTeamMemberUncheckedCreateNestedManyWithoutProjectInput
    milestones?: MilestoneUncheckedCreateNestedManyWithoutProjectInput
    budget?: BudgetUncheckedCreateNestedOneWithoutProjectInput
    documents?: DocumentUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutProposalsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutProposalsInput, ProjectUncheckedCreateWithoutProposalsInput>
  }

  export type ProposalItemCreateWithoutProposalInput = {
    id?: string
    name: string
    description?: string | null
    category: string
    quantity?: number
    unitPrice: number
    totalPrice: number
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    product?: ProductCreateNestedOneWithoutProposalItemsInput
  }

  export type ProposalItemUncheckedCreateWithoutProposalInput = {
    id?: string
    name: string
    description?: string | null
    category: string
    quantity?: number
    unitPrice: number
    totalPrice: number
    productId?: string | null
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProposalItemCreateOrConnectWithoutProposalInput = {
    where: ProposalItemWhereUniqueInput
    create: XOR<ProposalItemCreateWithoutProposalInput, ProposalItemUncheckedCreateWithoutProposalInput>
  }

  export type ProposalItemCreateManyProposalInputEnvelope = {
    data: ProposalItemCreateManyProposalInput | ProposalItemCreateManyProposalInput[]
  }

  export type CustomerUpsertWithoutProposalsInput = {
    update: XOR<CustomerUpdateWithoutProposalsInput, CustomerUncheckedUpdateWithoutProposalsInput>
    create: XOR<CustomerCreateWithoutProposalsInput, CustomerUncheckedCreateWithoutProposalsInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutProposalsInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutProposalsInput, CustomerUncheckedUpdateWithoutProposalsInput>
  }

  export type CustomerUpdateWithoutProposalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    company?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    preferredCommunication?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    billingAddress?: AddressUpdateOneWithoutCustomerNestedInput
    properties?: PropertyUpdateManyWithoutCustomerNestedInput
    projects?: ProjectUpdateManyWithoutCustomerNestedInput
    interactions?: InteractionUpdateManyWithoutCustomerNestedInput
    tags?: TagUpdateManyWithoutCustomerNestedInput
    metrics?: CustomerMetricsUpdateOneWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutProposalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    company?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    preferredCommunication?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    billingAddress?: AddressUncheckedUpdateOneWithoutCustomerNestedInput
    properties?: PropertyUncheckedUpdateManyWithoutCustomerNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutCustomerNestedInput
    interactions?: InteractionUncheckedUpdateManyWithoutCustomerNestedInput
    tags?: TagUncheckedUpdateManyWithoutCustomerNestedInput
    metrics?: CustomerMetricsUncheckedUpdateOneWithoutCustomerNestedInput
  }

  export type PropertyUpsertWithoutProposalsInput = {
    update: XOR<PropertyUpdateWithoutProposalsInput, PropertyUncheckedUpdateWithoutProposalsInput>
    create: XOR<PropertyCreateWithoutProposalsInput, PropertyUncheckedCreateWithoutProposalsInput>
    where?: PropertyWhereInput
  }

  export type PropertyUpdateToOneWithWhereWithoutProposalsInput = {
    where?: PropertyWhereInput
    data: XOR<PropertyUpdateWithoutProposalsInput, PropertyUncheckedUpdateWithoutProposalsInput>
  }

  export type PropertyUpdateWithoutProposalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    squareFootage?: FloatFieldUpdateOperationsInput | number
    bedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    bathrooms?: NullableIntFieldUpdateOperationsInput | number | null
    yearBuilt?: NullableIntFieldUpdateOperationsInput | number | null
    address?: AddressUpdateOneWithoutPropertyNestedInput
    photos?: PhotoUpdateManyWithoutPropertyNestedInput
    documents?: DocumentUpdateManyWithoutPropertyNestedInput
    systems?: SystemInstallationUpdateManyWithoutPropertyNestedInput
    serviceHistory?: ServiceRecordUpdateManyWithoutPropertyNestedInput
    customer?: CustomerUpdateOneRequiredWithoutPropertiesNestedInput
    projects?: ProjectUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateWithoutProposalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    addressId?: NullableStringFieldUpdateOperationsInput | string | null
    squareFootage?: FloatFieldUpdateOperationsInput | number
    bedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    bathrooms?: NullableIntFieldUpdateOperationsInput | number | null
    yearBuilt?: NullableIntFieldUpdateOperationsInput | number | null
    customerId?: StringFieldUpdateOperationsInput | string
    photos?: PhotoUncheckedUpdateManyWithoutPropertyNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutPropertyNestedInput
    systems?: SystemInstallationUncheckedUpdateManyWithoutPropertyNestedInput
    serviceHistory?: ServiceRecordUncheckedUpdateManyWithoutPropertyNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutPropertyNestedInput
  }

  export type ProjectUpsertWithoutProposalsInput = {
    update: XOR<ProjectUpdateWithoutProposalsInput, ProjectUncheckedUpdateWithoutProposalsInput>
    create: XOR<ProjectCreateWithoutProposalsInput, ProjectUncheckedCreateWithoutProposalsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutProposalsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutProposalsInput, ProjectUncheckedUpdateWithoutProposalsInput>
  }

  export type ProjectUpdateWithoutProposalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    property?: PropertyUpdateOneRequiredWithoutProjectsNestedInput
    teamMembers?: ProjectTeamMemberUpdateManyWithoutProjectNestedInput
    milestones?: MilestoneUpdateManyWithoutProjectNestedInput
    budget?: BudgetUpdateOneWithoutProjectNestedInput
    documents?: DocumentUpdateManyWithoutProjectNestedInput
    customer?: CustomerUpdateOneRequiredWithoutProjectsNestedInput
  }

  export type ProjectUncheckedUpdateWithoutProposalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    propertyId?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    teamMembers?: ProjectTeamMemberUncheckedUpdateManyWithoutProjectNestedInput
    milestones?: MilestoneUncheckedUpdateManyWithoutProjectNestedInput
    budget?: BudgetUncheckedUpdateOneWithoutProjectNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProposalItemUpsertWithWhereUniqueWithoutProposalInput = {
    where: ProposalItemWhereUniqueInput
    update: XOR<ProposalItemUpdateWithoutProposalInput, ProposalItemUncheckedUpdateWithoutProposalInput>
    create: XOR<ProposalItemCreateWithoutProposalInput, ProposalItemUncheckedCreateWithoutProposalInput>
  }

  export type ProposalItemUpdateWithWhereUniqueWithoutProposalInput = {
    where: ProposalItemWhereUniqueInput
    data: XOR<ProposalItemUpdateWithoutProposalInput, ProposalItemUncheckedUpdateWithoutProposalInput>
  }

  export type ProposalItemUpdateManyWithWhereWithoutProposalInput = {
    where: ProposalItemScalarWhereInput
    data: XOR<ProposalItemUpdateManyMutationInput, ProposalItemUncheckedUpdateManyWithoutProposalInput>
  }

  export type ProposalItemScalarWhereInput = {
    AND?: ProposalItemScalarWhereInput | ProposalItemScalarWhereInput[]
    OR?: ProposalItemScalarWhereInput[]
    NOT?: ProposalItemScalarWhereInput | ProposalItemScalarWhereInput[]
    id?: StringFilter<"ProposalItem"> | string
    name?: StringFilter<"ProposalItem"> | string
    description?: StringNullableFilter<"ProposalItem"> | string | null
    category?: StringFilter<"ProposalItem"> | string
    quantity?: IntFilter<"ProposalItem"> | number
    unitPrice?: FloatFilter<"ProposalItem"> | number
    totalPrice?: FloatFilter<"ProposalItem"> | number
    productId?: StringNullableFilter<"ProposalItem"> | string | null
    proposalId?: StringFilter<"ProposalItem"> | string
    sortOrder?: IntFilter<"ProposalItem"> | number
    createdAt?: DateTimeFilter<"ProposalItem"> | Date | string
    updatedAt?: DateTimeFilter<"ProposalItem"> | Date | string
  }

  export type ProductCreateWithoutProposalItemsInput = {
    id?: string
    name: string
    description?: string | null
    category: string
    brand?: string | null
    model?: string | null
    sku?: string | null
    basePrice: number
    goodTierPrice?: number | null
    betterTierPrice?: number | null
    bestTierPrice?: number | null
    isActive?: boolean
    specifications?: string | null
    compatibility?: string | null
    installation?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductUncheckedCreateWithoutProposalItemsInput = {
    id?: string
    name: string
    description?: string | null
    category: string
    brand?: string | null
    model?: string | null
    sku?: string | null
    basePrice: number
    goodTierPrice?: number | null
    betterTierPrice?: number | null
    bestTierPrice?: number | null
    isActive?: boolean
    specifications?: string | null
    compatibility?: string | null
    installation?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductCreateOrConnectWithoutProposalItemsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutProposalItemsInput, ProductUncheckedCreateWithoutProposalItemsInput>
  }

  export type ProposalCreateWithoutItemsInput = {
    id?: string
    name: string
    description?: string | null
    status: string
    customerPersona: string
    voiceTranscript?: string | null
    aiSummary?: string | null
    totalAmount?: number
    validUntil?: Date | string | null
    isExistingCustomer?: boolean
    prospectName?: string | null
    prospectCompany?: string | null
    prospectEmail?: string | null
    prospectPhone?: string | null
    prospectStatus?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    customer?: CustomerCreateNestedOneWithoutProposalsInput
    property?: PropertyCreateNestedOneWithoutProposalsInput
    project?: ProjectCreateNestedOneWithoutProposalsInput
  }

  export type ProposalUncheckedCreateWithoutItemsInput = {
    id?: string
    name: string
    description?: string | null
    status: string
    customerPersona: string
    voiceTranscript?: string | null
    aiSummary?: string | null
    totalAmount?: number
    validUntil?: Date | string | null
    isExistingCustomer?: boolean
    customerId?: string | null
    prospectName?: string | null
    prospectCompany?: string | null
    prospectEmail?: string | null
    prospectPhone?: string | null
    prospectStatus?: string | null
    propertyId?: string | null
    projectId?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProposalCreateOrConnectWithoutItemsInput = {
    where: ProposalWhereUniqueInput
    create: XOR<ProposalCreateWithoutItemsInput, ProposalUncheckedCreateWithoutItemsInput>
  }

  export type ProductUpsertWithoutProposalItemsInput = {
    update: XOR<ProductUpdateWithoutProposalItemsInput, ProductUncheckedUpdateWithoutProposalItemsInput>
    create: XOR<ProductCreateWithoutProposalItemsInput, ProductUncheckedCreateWithoutProposalItemsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutProposalItemsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutProposalItemsInput, ProductUncheckedUpdateWithoutProposalItemsInput>
  }

  export type ProductUpdateWithoutProposalItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: FloatFieldUpdateOperationsInput | number
    goodTierPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    betterTierPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    bestTierPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    specifications?: NullableStringFieldUpdateOperationsInput | string | null
    compatibility?: NullableStringFieldUpdateOperationsInput | string | null
    installation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUncheckedUpdateWithoutProposalItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    basePrice?: FloatFieldUpdateOperationsInput | number
    goodTierPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    betterTierPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    bestTierPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    specifications?: NullableStringFieldUpdateOperationsInput | string | null
    compatibility?: NullableStringFieldUpdateOperationsInput | string | null
    installation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProposalUpsertWithoutItemsInput = {
    update: XOR<ProposalUpdateWithoutItemsInput, ProposalUncheckedUpdateWithoutItemsInput>
    create: XOR<ProposalCreateWithoutItemsInput, ProposalUncheckedCreateWithoutItemsInput>
    where?: ProposalWhereInput
  }

  export type ProposalUpdateToOneWithWhereWithoutItemsInput = {
    where?: ProposalWhereInput
    data: XOR<ProposalUpdateWithoutItemsInput, ProposalUncheckedUpdateWithoutItemsInput>
  }

  export type ProposalUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    customerPersona?: StringFieldUpdateOperationsInput | string
    voiceTranscript?: NullableStringFieldUpdateOperationsInput | string | null
    aiSummary?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: FloatFieldUpdateOperationsInput | number
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isExistingCustomer?: BoolFieldUpdateOperationsInput | boolean
    prospectName?: NullableStringFieldUpdateOperationsInput | string | null
    prospectCompany?: NullableStringFieldUpdateOperationsInput | string | null
    prospectEmail?: NullableStringFieldUpdateOperationsInput | string | null
    prospectPhone?: NullableStringFieldUpdateOperationsInput | string | null
    prospectStatus?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneWithoutProposalsNestedInput
    property?: PropertyUpdateOneWithoutProposalsNestedInput
    project?: ProjectUpdateOneWithoutProposalsNestedInput
  }

  export type ProposalUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    customerPersona?: StringFieldUpdateOperationsInput | string
    voiceTranscript?: NullableStringFieldUpdateOperationsInput | string | null
    aiSummary?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: FloatFieldUpdateOperationsInput | number
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isExistingCustomer?: BoolFieldUpdateOperationsInput | boolean
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    prospectName?: NullableStringFieldUpdateOperationsInput | string | null
    prospectCompany?: NullableStringFieldUpdateOperationsInput | string | null
    prospectEmail?: NullableStringFieldUpdateOperationsInput | string | null
    prospectPhone?: NullableStringFieldUpdateOperationsInput | string | null
    prospectStatus?: NullableStringFieldUpdateOperationsInput | string | null
    propertyId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProposalItemCreateWithoutProductInput = {
    id?: string
    name: string
    description?: string | null
    category: string
    quantity?: number
    unitPrice: number
    totalPrice: number
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    proposal: ProposalCreateNestedOneWithoutItemsInput
  }

  export type ProposalItemUncheckedCreateWithoutProductInput = {
    id?: string
    name: string
    description?: string | null
    category: string
    quantity?: number
    unitPrice: number
    totalPrice: number
    proposalId: string
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProposalItemCreateOrConnectWithoutProductInput = {
    where: ProposalItemWhereUniqueInput
    create: XOR<ProposalItemCreateWithoutProductInput, ProposalItemUncheckedCreateWithoutProductInput>
  }

  export type ProposalItemCreateManyProductInputEnvelope = {
    data: ProposalItemCreateManyProductInput | ProposalItemCreateManyProductInput[]
  }

  export type ProposalItemUpsertWithWhereUniqueWithoutProductInput = {
    where: ProposalItemWhereUniqueInput
    update: XOR<ProposalItemUpdateWithoutProductInput, ProposalItemUncheckedUpdateWithoutProductInput>
    create: XOR<ProposalItemCreateWithoutProductInput, ProposalItemUncheckedCreateWithoutProductInput>
  }

  export type ProposalItemUpdateWithWhereUniqueWithoutProductInput = {
    where: ProposalItemWhereUniqueInput
    data: XOR<ProposalItemUpdateWithoutProductInput, ProposalItemUncheckedUpdateWithoutProductInput>
  }

  export type ProposalItemUpdateManyWithWhereWithoutProductInput = {
    where: ProposalItemScalarWhereInput
    data: XOR<ProposalItemUpdateManyMutationInput, ProposalItemUncheckedUpdateManyWithoutProductInput>
  }

  export type PropertyCreateManyCustomerInput = {
    id?: string
    name: string
    type: string
    addressId?: string | null
    squareFootage: number
    bedrooms?: number | null
    bathrooms?: number | null
    yearBuilt?: number | null
  }

  export type ProjectCreateManyCustomerInput = {
    id?: string
    name: string
    description: string
    status: string
    startDate: Date | string
    endDate?: Date | string | null
    propertyId: string
  }

  export type InteractionCreateManyCustomerInput = {
    id?: string
    type: string
    date: Date | string
    summary: string
    details: string
    followUpDate?: Date | string | null
    followUpNotes?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TagCreateManyCustomerInput = {
    id?: string
    name: string
  }

  export type ProposalCreateManyCustomerInput = {
    id?: string
    name: string
    description?: string | null
    status: string
    customerPersona: string
    voiceTranscript?: string | null
    aiSummary?: string | null
    totalAmount?: number
    validUntil?: Date | string | null
    isExistingCustomer?: boolean
    prospectName?: string | null
    prospectCompany?: string | null
    prospectEmail?: string | null
    prospectPhone?: string | null
    prospectStatus?: string | null
    propertyId?: string | null
    projectId?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PropertyUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    squareFootage?: FloatFieldUpdateOperationsInput | number
    bedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    bathrooms?: NullableIntFieldUpdateOperationsInput | number | null
    yearBuilt?: NullableIntFieldUpdateOperationsInput | number | null
    address?: AddressUpdateOneWithoutPropertyNestedInput
    photos?: PhotoUpdateManyWithoutPropertyNestedInput
    documents?: DocumentUpdateManyWithoutPropertyNestedInput
    systems?: SystemInstallationUpdateManyWithoutPropertyNestedInput
    serviceHistory?: ServiceRecordUpdateManyWithoutPropertyNestedInput
    projects?: ProjectUpdateManyWithoutPropertyNestedInput
    proposals?: ProposalUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    addressId?: NullableStringFieldUpdateOperationsInput | string | null
    squareFootage?: FloatFieldUpdateOperationsInput | number
    bedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    bathrooms?: NullableIntFieldUpdateOperationsInput | number | null
    yearBuilt?: NullableIntFieldUpdateOperationsInput | number | null
    photos?: PhotoUncheckedUpdateManyWithoutPropertyNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutPropertyNestedInput
    systems?: SystemInstallationUncheckedUpdateManyWithoutPropertyNestedInput
    serviceHistory?: ServiceRecordUncheckedUpdateManyWithoutPropertyNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutPropertyNestedInput
    proposals?: ProposalUncheckedUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    addressId?: NullableStringFieldUpdateOperationsInput | string | null
    squareFootage?: FloatFieldUpdateOperationsInput | number
    bedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    bathrooms?: NullableIntFieldUpdateOperationsInput | number | null
    yearBuilt?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ProjectUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    property?: PropertyUpdateOneRequiredWithoutProjectsNestedInput
    teamMembers?: ProjectTeamMemberUpdateManyWithoutProjectNestedInput
    milestones?: MilestoneUpdateManyWithoutProjectNestedInput
    budget?: BudgetUpdateOneWithoutProjectNestedInput
    documents?: DocumentUpdateManyWithoutProjectNestedInput
    proposals?: ProposalUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    propertyId?: StringFieldUpdateOperationsInput | string
    teamMembers?: ProjectTeamMemberUncheckedUpdateManyWithoutProjectNestedInput
    milestones?: MilestoneUncheckedUpdateManyWithoutProjectNestedInput
    budget?: BudgetUncheckedUpdateOneWithoutProjectNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutProjectNestedInput
    proposals?: ProposalUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    propertyId?: StringFieldUpdateOperationsInput | string
  }

  export type InteractionUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    summary?: StringFieldUpdateOperationsInput | string
    details?: StringFieldUpdateOperationsInput | string
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followUpNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InteractionUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    summary?: StringFieldUpdateOperationsInput | string
    details?: StringFieldUpdateOperationsInput | string
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followUpNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InteractionUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    summary?: StringFieldUpdateOperationsInput | string
    details?: StringFieldUpdateOperationsInput | string
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followUpNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type TagUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type TagUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ProposalUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    customerPersona?: StringFieldUpdateOperationsInput | string
    voiceTranscript?: NullableStringFieldUpdateOperationsInput | string | null
    aiSummary?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: FloatFieldUpdateOperationsInput | number
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isExistingCustomer?: BoolFieldUpdateOperationsInput | boolean
    prospectName?: NullableStringFieldUpdateOperationsInput | string | null
    prospectCompany?: NullableStringFieldUpdateOperationsInput | string | null
    prospectEmail?: NullableStringFieldUpdateOperationsInput | string | null
    prospectPhone?: NullableStringFieldUpdateOperationsInput | string | null
    prospectStatus?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    property?: PropertyUpdateOneWithoutProposalsNestedInput
    project?: ProjectUpdateOneWithoutProposalsNestedInput
    items?: ProposalItemUpdateManyWithoutProposalNestedInput
  }

  export type ProposalUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    customerPersona?: StringFieldUpdateOperationsInput | string
    voiceTranscript?: NullableStringFieldUpdateOperationsInput | string | null
    aiSummary?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: FloatFieldUpdateOperationsInput | number
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isExistingCustomer?: BoolFieldUpdateOperationsInput | boolean
    prospectName?: NullableStringFieldUpdateOperationsInput | string | null
    prospectCompany?: NullableStringFieldUpdateOperationsInput | string | null
    prospectEmail?: NullableStringFieldUpdateOperationsInput | string | null
    prospectPhone?: NullableStringFieldUpdateOperationsInput | string | null
    prospectStatus?: NullableStringFieldUpdateOperationsInput | string | null
    propertyId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: ProposalItemUncheckedUpdateManyWithoutProposalNestedInput
  }

  export type ProposalUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    customerPersona?: StringFieldUpdateOperationsInput | string
    voiceTranscript?: NullableStringFieldUpdateOperationsInput | string | null
    aiSummary?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: FloatFieldUpdateOperationsInput | number
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isExistingCustomer?: BoolFieldUpdateOperationsInput | boolean
    prospectName?: NullableStringFieldUpdateOperationsInput | string | null
    prospectCompany?: NullableStringFieldUpdateOperationsInput | string | null
    prospectEmail?: NullableStringFieldUpdateOperationsInput | string | null
    prospectPhone?: NullableStringFieldUpdateOperationsInput | string | null
    prospectStatus?: NullableStringFieldUpdateOperationsInput | string | null
    propertyId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PhotoCreateManyPropertyInput = {
    id?: string
    url: string
    uploadedAt?: Date | string
    uploadedBy: string
  }

  export type DocumentCreateManyPropertyInput = {
    id?: string
    name: string
    url: string
    type: string
    projectId?: string | null
    uploadedAt?: Date | string
    uploadedBy: string
  }

  export type SystemInstallationCreateManyPropertyInput = {
    id?: string
    type: string
    details: string
    installDate?: Date | string | null
    lastService?: Date | string | null
  }

  export type ServiceRecordCreateManyPropertyInput = {
    id?: string
    date: Date | string
    type: string
    description: string
    technician: string
    cost: number
  }

  export type ProjectCreateManyPropertyInput = {
    id?: string
    name: string
    description: string
    status: string
    startDate: Date | string
    endDate?: Date | string | null
    customerId: string
  }

  export type ProposalCreateManyPropertyInput = {
    id?: string
    name: string
    description?: string | null
    status: string
    customerPersona: string
    voiceTranscript?: string | null
    aiSummary?: string | null
    totalAmount?: number
    validUntil?: Date | string | null
    isExistingCustomer?: boolean
    customerId?: string | null
    prospectName?: string | null
    prospectCompany?: string | null
    prospectEmail?: string | null
    prospectPhone?: string | null
    prospectStatus?: string | null
    projectId?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PhotoUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedBy?: StringFieldUpdateOperationsInput | string
  }

  export type PhotoUncheckedUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedBy?: StringFieldUpdateOperationsInput | string
  }

  export type PhotoUncheckedUpdateManyWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedBy?: StringFieldUpdateOperationsInput | string
  }

  export type DocumentUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedBy?: StringFieldUpdateOperationsInput | string
    project?: ProjectUpdateOneWithoutDocumentsNestedInput
  }

  export type DocumentUncheckedUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedBy?: StringFieldUpdateOperationsInput | string
  }

  export type DocumentUncheckedUpdateManyWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedBy?: StringFieldUpdateOperationsInput | string
  }

  export type SystemInstallationUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    details?: StringFieldUpdateOperationsInput | string
    installDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastService?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SystemInstallationUncheckedUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    details?: StringFieldUpdateOperationsInput | string
    installDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastService?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SystemInstallationUncheckedUpdateManyWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    details?: StringFieldUpdateOperationsInput | string
    installDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastService?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ServiceRecordUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    technician?: StringFieldUpdateOperationsInput | string
    cost?: FloatFieldUpdateOperationsInput | number
  }

  export type ServiceRecordUncheckedUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    technician?: StringFieldUpdateOperationsInput | string
    cost?: FloatFieldUpdateOperationsInput | number
  }

  export type ServiceRecordUncheckedUpdateManyWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    technician?: StringFieldUpdateOperationsInput | string
    cost?: FloatFieldUpdateOperationsInput | number
  }

  export type ProjectUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    teamMembers?: ProjectTeamMemberUpdateManyWithoutProjectNestedInput
    milestones?: MilestoneUpdateManyWithoutProjectNestedInput
    budget?: BudgetUpdateOneWithoutProjectNestedInput
    documents?: DocumentUpdateManyWithoutProjectNestedInput
    customer?: CustomerUpdateOneRequiredWithoutProjectsNestedInput
    proposals?: ProposalUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customerId?: StringFieldUpdateOperationsInput | string
    teamMembers?: ProjectTeamMemberUncheckedUpdateManyWithoutProjectNestedInput
    milestones?: MilestoneUncheckedUpdateManyWithoutProjectNestedInput
    budget?: BudgetUncheckedUpdateOneWithoutProjectNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutProjectNestedInput
    proposals?: ProposalUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateManyWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customerId?: StringFieldUpdateOperationsInput | string
  }

  export type ProposalUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    customerPersona?: StringFieldUpdateOperationsInput | string
    voiceTranscript?: NullableStringFieldUpdateOperationsInput | string | null
    aiSummary?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: FloatFieldUpdateOperationsInput | number
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isExistingCustomer?: BoolFieldUpdateOperationsInput | boolean
    prospectName?: NullableStringFieldUpdateOperationsInput | string | null
    prospectCompany?: NullableStringFieldUpdateOperationsInput | string | null
    prospectEmail?: NullableStringFieldUpdateOperationsInput | string | null
    prospectPhone?: NullableStringFieldUpdateOperationsInput | string | null
    prospectStatus?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneWithoutProposalsNestedInput
    project?: ProjectUpdateOneWithoutProposalsNestedInput
    items?: ProposalItemUpdateManyWithoutProposalNestedInput
  }

  export type ProposalUncheckedUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    customerPersona?: StringFieldUpdateOperationsInput | string
    voiceTranscript?: NullableStringFieldUpdateOperationsInput | string | null
    aiSummary?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: FloatFieldUpdateOperationsInput | number
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isExistingCustomer?: BoolFieldUpdateOperationsInput | boolean
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    prospectName?: NullableStringFieldUpdateOperationsInput | string | null
    prospectCompany?: NullableStringFieldUpdateOperationsInput | string | null
    prospectEmail?: NullableStringFieldUpdateOperationsInput | string | null
    prospectPhone?: NullableStringFieldUpdateOperationsInput | string | null
    prospectStatus?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: ProposalItemUncheckedUpdateManyWithoutProposalNestedInput
  }

  export type ProposalUncheckedUpdateManyWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    customerPersona?: StringFieldUpdateOperationsInput | string
    voiceTranscript?: NullableStringFieldUpdateOperationsInput | string | null
    aiSummary?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: FloatFieldUpdateOperationsInput | number
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isExistingCustomer?: BoolFieldUpdateOperationsInput | boolean
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    prospectName?: NullableStringFieldUpdateOperationsInput | string | null
    prospectCompany?: NullableStringFieldUpdateOperationsInput | string | null
    prospectEmail?: NullableStringFieldUpdateOperationsInput | string | null
    prospectPhone?: NullableStringFieldUpdateOperationsInput | string | null
    prospectStatus?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectTeamMemberCreateManyProjectInput = {
    id?: string
    teamMemberId: string
  }

  export type MilestoneCreateManyProjectInput = {
    id?: string
    name: string
    description: string
    status: string
    dueDate: Date | string
    completedDate?: Date | string | null
    assignedTo?: string | null
  }

  export type DocumentCreateManyProjectInput = {
    id?: string
    name: string
    url: string
    type: string
    propertyId?: string | null
    uploadedAt?: Date | string
    uploadedBy: string
  }

  export type ProposalCreateManyProjectInput = {
    id?: string
    name: string
    description?: string | null
    status: string
    customerPersona: string
    voiceTranscript?: string | null
    aiSummary?: string | null
    totalAmount?: number
    validUntil?: Date | string | null
    isExistingCustomer?: boolean
    customerId?: string | null
    prospectName?: string | null
    prospectCompany?: string | null
    prospectEmail?: string | null
    prospectPhone?: string | null
    prospectStatus?: string | null
    propertyId?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectTeamMemberUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    teamMember?: TeamMemberUpdateOneRequiredWithoutProjectsNestedInput
  }

  export type ProjectTeamMemberUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    teamMemberId?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectTeamMemberUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    teamMemberId?: StringFieldUpdateOperationsInput | string
  }

  export type MilestoneUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MilestoneUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MilestoneUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DocumentUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedBy?: StringFieldUpdateOperationsInput | string
    property?: PropertyUpdateOneWithoutDocumentsNestedInput
  }

  export type DocumentUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    propertyId?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedBy?: StringFieldUpdateOperationsInput | string
  }

  export type DocumentUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    propertyId?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedBy?: StringFieldUpdateOperationsInput | string
  }

  export type ProposalUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    customerPersona?: StringFieldUpdateOperationsInput | string
    voiceTranscript?: NullableStringFieldUpdateOperationsInput | string | null
    aiSummary?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: FloatFieldUpdateOperationsInput | number
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isExistingCustomer?: BoolFieldUpdateOperationsInput | boolean
    prospectName?: NullableStringFieldUpdateOperationsInput | string | null
    prospectCompany?: NullableStringFieldUpdateOperationsInput | string | null
    prospectEmail?: NullableStringFieldUpdateOperationsInput | string | null
    prospectPhone?: NullableStringFieldUpdateOperationsInput | string | null
    prospectStatus?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneWithoutProposalsNestedInput
    property?: PropertyUpdateOneWithoutProposalsNestedInput
    items?: ProposalItemUpdateManyWithoutProposalNestedInput
  }

  export type ProposalUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    customerPersona?: StringFieldUpdateOperationsInput | string
    voiceTranscript?: NullableStringFieldUpdateOperationsInput | string | null
    aiSummary?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: FloatFieldUpdateOperationsInput | number
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isExistingCustomer?: BoolFieldUpdateOperationsInput | boolean
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    prospectName?: NullableStringFieldUpdateOperationsInput | string | null
    prospectCompany?: NullableStringFieldUpdateOperationsInput | string | null
    prospectEmail?: NullableStringFieldUpdateOperationsInput | string | null
    prospectPhone?: NullableStringFieldUpdateOperationsInput | string | null
    prospectStatus?: NullableStringFieldUpdateOperationsInput | string | null
    propertyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: ProposalItemUncheckedUpdateManyWithoutProposalNestedInput
  }

  export type ProposalUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    customerPersona?: StringFieldUpdateOperationsInput | string
    voiceTranscript?: NullableStringFieldUpdateOperationsInput | string | null
    aiSummary?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: FloatFieldUpdateOperationsInput | number
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isExistingCustomer?: BoolFieldUpdateOperationsInput | boolean
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    prospectName?: NullableStringFieldUpdateOperationsInput | string | null
    prospectCompany?: NullableStringFieldUpdateOperationsInput | string | null
    prospectEmail?: NullableStringFieldUpdateOperationsInput | string | null
    prospectPhone?: NullableStringFieldUpdateOperationsInput | string | null
    prospectStatus?: NullableStringFieldUpdateOperationsInput | string | null
    propertyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectTeamMemberCreateManyTeamMemberInput = {
    id?: string
    projectId: string
  }

  export type ProjectTeamMemberUpdateWithoutTeamMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    project?: ProjectUpdateOneRequiredWithoutTeamMembersNestedInput
  }

  export type ProjectTeamMemberUncheckedUpdateWithoutTeamMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectTeamMemberUncheckedUpdateManyWithoutTeamMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
  }

  export type BudgetLineItemCreateManyBudgetInput = {
    id?: string
    description: string
    amount: number
    category: string
  }

  export type BudgetLineItemUpdateWithoutBudgetInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
  }

  export type BudgetLineItemUncheckedUpdateWithoutBudgetInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
  }

  export type BudgetLineItemUncheckedUpdateManyWithoutBudgetInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
  }

  export type ProposalItemCreateManyProposalInput = {
    id?: string
    name: string
    description?: string | null
    category: string
    quantity?: number
    unitPrice: number
    totalPrice: number
    productId?: string | null
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProposalItemUpdateWithoutProposalInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneWithoutProposalItemsNestedInput
  }

  export type ProposalItemUncheckedUpdateWithoutProposalInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProposalItemUncheckedUpdateManyWithoutProposalInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProposalItemCreateManyProductInput = {
    id?: string
    name: string
    description?: string | null
    category: string
    quantity?: number
    unitPrice: number
    totalPrice: number
    proposalId: string
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProposalItemUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    proposal?: ProposalUpdateOneRequiredWithoutItemsNestedInput
  }

  export type ProposalItemUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    proposalId?: StringFieldUpdateOperationsInput | string
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProposalItemUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    proposalId?: StringFieldUpdateOperationsInput | string
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}